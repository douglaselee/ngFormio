/*! ng-formio v2.16.6 | https://unpkg.com/ng-formio@2.16.6/LICENSE.txt */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.formio = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
;!function(undefined) {

  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {
      this._conf = conf;

      conf.delimiter && (this.delimiter = conf.delimiter);
      this._events.maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;
      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this.newListener = conf.newListener);
      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    } else {
      this._events.maxListeners = defaultMaxListeners;
    }
  }

  function logPossibleMemoryLeak(count, eventName) {
    var errorMsg = '(node) warning: possible EventEmitter memory ' +
        'leak detected. %d listeners added. ' +
        'Use emitter.setMaxListeners() to increase limit.';

    if(this.verboseMemoryLeak){
      errorMsg += ' Event name: %s.';
      console.error(errorMsg, count, eventName);
    } else {
      console.error(errorMsg, count);
    }

    if (console.trace){
      console.trace();
    }
  }

  function EventEmitter(conf) {
    this._events = {};
    this.newListener = false;
    this.verboseMemoryLeak = false;
    configure.call(this, conf);
  }
  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

  //
  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i) {
    if (!tree) {
      return [];
    }
    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
        typeLength = type.length, currentType = type[i], nextType = type[i+1];
    if (i === typeLength && tree._listeners) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //
      if (typeof tree._listeners === 'function') {
        handlers && handlers.push(tree._listeners);
        return [tree];
      } else {
        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
          handlers && handlers.push(tree._listeners[leaf]);
        }
        return [tree];
      }
    }

    if ((currentType === '*' || currentType === '**') || tree[currentType]) {
      //
      // If the event emitted is '*' at this part
      // or there is a concrete match at this patch
      //
      if (currentType === '*') {
        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
          }
        }
        return listeners;
      } else if(currentType === '**') {
        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
        if(endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
        }

        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            if(branch === '*' || branch === '**') {
              if(tree[branch]._listeners && !endReached) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
              }
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            } else if(branch === nextType) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
            } else {
              // No match on this one, shift into the tree but not in the type array.
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            }
          }
        }
        return listeners;
      }

      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
    }

    xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i+1);
    }

    xxTree = tree['**'];
    if(xxTree) {
      if(i < typeLength) {
        if(xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength);
        }

        // Build arrays of matching next branches and others.
        for(branch in xxTree) {
          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
            if(branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i+2);
            } else if(branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i+1);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
            }
          }
        }
      } else if(xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength);
      } else if(xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener) {

    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    for(var i = 0, len = type.length; i+1 < len; i++) {
      if(type[i] === '**' && type[i+1] === '**') {
        return;
      }
    }

    var tree = this.listenerTree;
    var name = type.shift();

    while (name !== undefined) {

      if (!tree[name]) {
        tree[name] = {};
      }

      tree = tree[name];

      if (type.length === 0) {

        if (!tree._listeners) {
          tree._listeners = listener;
        }
        else {
          if (typeof tree._listeners === 'function') {
            tree._listeners = [tree._listeners];
          }

          tree._listeners.push(listener);

          if (
            !tree._listeners.warned &&
            this._events.maxListeners > 0 &&
            tree._listeners.length > this._events.maxListeners
          ) {
            tree._listeners.warned = true;
            logPossibleMemoryLeak.call(this, tree._listeners.length, name);
          }
        }
        return true;
      }
      name = type.shift();
    }
    return true;
  }

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    if (n !== undefined) {
      this._events || init.call(this);
      this._events.maxListeners = n;
      if (!this._conf) this._conf = {};
      this._conf.maxListeners = n;
    }
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn) {
    this.many(event, 1, fn);
    return this;
  };

  EventEmitter.prototype.many = function(event, ttl, fn) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      fn.apply(this, arguments);
    }

    listener._origin = fn;

    this.on(event, listener);

    return self;
  };

  EventEmitter.prototype.emit = function() {

    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
      if (!this._events.newListener) {
        return false;
      }
    }

    var al = arguments.length;
    var args,l,i,j;
    var handler;

    if (this._all && this._all.length) {
      handler = this._all.slice();
      if (al > 3) {
        args = new Array(al);
        for (j = 0; j < al; j++) args[j] = arguments[j];
      }

      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this, type);
          break;
        case 2:
          handler[i].call(this, type, arguments[1]);
          break;
        case 3:
          handler[i].call(this, type, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, args);
        }
      }
    }

    if (this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    } else {
      handler = this._events[type];
      if (typeof handler === 'function') {
        this.event = type;
        switch (al) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          args = new Array(al - 1);
          for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          handler.apply(this, args);
        }
        return true;
      } else if (handler) {
        // need to make copy of handlers because list can change in the middle
        // of emit call
        handler = handler.slice();
      }
    }

    if (handler && handler.length) {
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this);
          break;
        case 2:
          handler[i].call(this, arguments[1]);
          break;
        case 3:
          handler[i].call(this, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, args);
        }
      }
      return true;
    } else if (!this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }

    return !!this._all;
  };

  EventEmitter.prototype.emitAsync = function() {

    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
        if (!this._events.newListener) { return Promise.resolve([false]); }
    }

    var promises= [];

    var al = arguments.length;
    var args,l,i,j;
    var handler;

    if (this._all) {
      if (al > 3) {
        args = new Array(al);
        for (j = 1; j < al; j++) args[j] = arguments[j];
      }
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(this._all[i].call(this, type));
          break;
        case 2:
          promises.push(this._all[i].call(this, type, arguments[1]));
          break;
        case 3:
          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
          break;
        default:
          promises.push(this._all[i].apply(this, args));
        }
      }
    }

    if (this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    } else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      switch (al) {
      case 1:
        promises.push(handler.call(this));
        break;
      case 2:
        promises.push(handler.call(this, arguments[1]));
        break;
      case 3:
        promises.push(handler.call(this, arguments[1], arguments[2]));
        break;
      default:
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
        promises.push(handler.apply(this, args));
      }
    } else if (handler && handler.length) {
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(handler[i].call(this));
          break;
        case 2:
          promises.push(handler[i].call(this, arguments[1]));
          break;
        case 3:
          promises.push(handler[i].call(this, arguments[1], arguments[2]));
          break;
        default:
          promises.push(handler[i].apply(this, args));
        }
      }
    } else if (!this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        return Promise.reject(arguments[1]); // Unhandled 'error' event
      } else {
        return Promise.reject("Uncaught, unspecified 'error' event.");
      }
    }

    return Promise.all(promises);
  };

  EventEmitter.prototype.on = function(type, listener) {
    if (typeof type === 'function') {
      this.onAny(type);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);

    if (this.wildcard) {
      growListenerTree.call(this, type, listener);
      return this;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    }
    else {
      if (typeof this._events[type] === 'function') {
        // Change to array.
        this._events[type] = [this._events[type]];
      }

      // If we've already got an array, just append.
      this._events[type].push(listener);

      // Check for listener leak
      if (
        !this._events[type].warned &&
        this._events.maxListeners > 0 &&
        this._events[type].length > this._events.maxListeners
      ) {
        this._events[type].warned = true;
        logPossibleMemoryLeak.call(this, this._events[type].length, type);
      }
    }

    return this;
  };

  EventEmitter.prototype.onAny = function(fn) {
    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    if (!this._all) {
      this._all = [];
    }

    // Add the function to the event listener collection.
    this._all.push(fn);
    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
    }
    else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          continue;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1);
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }

        this.emit("removeListener", type, listener);

        return this;
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }

        this.emit("removeListener", type, listener);
      }
    }

    function recursivelyGarbageCollect(root) {
      if (root === undefined) {
        return;
      }
      var keys = Object.keys(root);
      for (var i in keys) {
        var key = keys[i];
        var obj = root[key];
        if ((obj instanceof Function) || (typeof obj !== "object") || (obj === null))
          continue;
        if (Object.keys(obj).length > 0) {
          recursivelyGarbageCollect(root[key]);
        }
        if (Object.keys(obj).length === 0) {
          delete root[key];
        }
      }
    }
    recursivelyGarbageCollect(this.listenerTree);

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          this.emit("removeListenerAny", fn);
          return this;
        }
      }
    } else {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++)
        this.emit("removeListenerAny", fns[i]);
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function(type) {
    if (arguments.length === 0) {
      !this._events || init.call(this);
      return this;
    }

    if (this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        leaf._listeners = null;
      }
    }
    else if (this._events) {
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    if (this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers;
    }

    this._events || init.call(this);

    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  EventEmitter.prototype.listenerCount = function(type) {
    return this.listeners(type).length;
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  if (typeof define === 'function' && define.amd) {
     // AMD. Register as an anonymous module.
    define(function() {
      return EventEmitter;
    });
  } else if (typeof exports === 'object') {
    // CommonJS
    module.exports = EventEmitter;
  }
  else {
    // Browser global.
    window.EventEmitter2 = EventEmitter;
  }
}();

},{}],2:[function(_dereq_,module,exports){
(function (global){
'use strict';

// Intentionally use native-promise-only here... Other promise libraries (es6-promise)
// duck-punch the global Promise definition which messes up Angular 2 since it
// also duck-punches the global Promise definition. For now, keep native-promise-only.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Promise = _dereq_("native-promise-only");
_dereq_('whatwg-fetch');
var EventEmitter = _dereq_('eventemitter2').EventEmitter2;
var copy = _dereq_('shallow-copy');

/**
 * The Formio interface class.
 *
 *   let formio = new Formio('https://examples.form.io/example');
 */

var Formio = function () {
  function Formio(path) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Formio);

    // Ensure we have an instance of Formio.
    if (!(this instanceof Formio)) {
      return new Formio(path);
    }

    // Initialize our variables.
    this.base = '';
    this.projectsUrl = '';
    this.projectUrl = '';
    this.projectId = '';
    this.formUrl = '';
    this.formsUrl = '';
    this.formId = '';
    this.submissionsUrl = '';
    this.submissionUrl = '';
    this.submissionId = '';
    this.actionsUrl = '';
    this.actionId = '';
    this.actionUrl = '';
    this.query = '';

    if (options.hasOwnProperty('base')) {
      this.base = options.base;
    } else if (Formio.baseUrl) {
      this.base = Formio.baseUrl;
    } else {
      this.base = window.location.href.match(/http[s]?:\/\/api./)[0];
    }

    if (!path) {
      // Allow user to create new projects if this was instantiated without
      // a url
      this.projectUrl = this.base + '/project';
      this.projectsUrl = this.base + '/project';
      this.projectId = false;
      this.query = '';
      return;
    }

    if (options.hasOwnProperty('project')) {
      this.projectUrl = options.project;
    }

    var project = this.projectUrl || Formio.projectUrl;

    // The baseURL is the same as the projectUrl. This is almost certainly against
    // the Open Source server.
    if (project && this.base === project) {
      this.noProject = true;
      this.projectUrl = this.base;
    }

    // Normalize to an absolute path.
    if (path.indexOf('http') !== 0 && path.indexOf('//') !== 0) {
      path = this.base + path;
    }

    var hostparts = Formio.getUrlParts(path);
    var parts = [];
    var hostName = hostparts[1] + hostparts[2];
    path = hostparts.length > 3 ? hostparts[3] : '';
    var queryparts = path.split('?');
    if (queryparts.length > 1) {
      path = queryparts[0];
      this.query = '?' + queryparts[1];
    }

    // Register a specific path.
    var registerPath = function registerPath(name, base) {
      _this[name + 'sUrl'] = base + '/' + name;
      var regex = new RegExp('\/' + name + '\/([^/]+)');
      if (path.search(regex) !== -1) {
        parts = path.match(regex);
        _this[name + 'Url'] = parts ? base + parts[0] : '';
        _this[name + 'Id'] = parts.length > 1 ? parts[1] : '';
        base += parts[0];
      }
      return base;
    };

    // Register an array of items.
    var registerItems = function registerItems(items, base, staticBase) {
      for (var i in items) {
        if (items.hasOwnProperty(i)) {
          var item = items[i];
          if (item instanceof Array) {
            registerItems(item, base, true);
          } else {
            var newBase = registerPath(item, base);
            base = staticBase ? base : newBase;
          }
        }
      }
    };

    if (!this.projectUrl || this.projectUrl === this.base) {
      this.projectUrl = hostName;
    }

    if (!this.noProject) {
      // Determine the projectUrl and projectId
      if (path.search(/(^|\/)(project)($|\/)/) !== -1) {
        // Get project id as project/:projectId.
        registerItems(['project'], hostName);
      } else if (hostName === this.base) {
        // Get project id as first part of path (subdirectory).
        if (hostparts.length > 3 && path.split('/').length > 1) {
          var pathParts = path.split('/');
          pathParts.shift(); // Throw away the first /.
          this.projectId = pathParts.shift();
          path = '/' + pathParts.join('/');
          this.projectUrl = hostName + '/' + this.projectId;
        }
      } else {
        // Get project id from subdomain.
        if (hostparts.length > 2 && (hostparts[2].split('.').length > 2 || hostName.indexOf('localhost') !== -1)) {
          this.projectUrl = hostName;
          this.projectId = hostparts[2].split('.')[0];
        }
      }
      this.projectsUrl = this.projectsUrl || this.base + '/project';
    }

    // Configure Form urls and form ids.
    if (path.search(/(^|\/)(project|form)($|\/)/) !== -1) {
      registerItems(['form', ['submission', 'action']], this.projectUrl);
    } else {
      var subRegEx = new RegExp('\/(submission|action)($|\/.*)');
      var subs = path.match(subRegEx);
      this.pathType = subs && subs.length > 1 ? subs[1] : '';
      path = path.replace(subRegEx, '');
      path = path.replace(/\/$/, '');
      this.formsUrl = this.projectUrl + '/form';
      this.formUrl = this.projectUrl + path;
      this.formId = path.replace(/^\/+|\/+$/g, '');
      var items = ['submission', 'action'];
      for (var i in items) {
        if (items.hasOwnProperty(i)) {
          var item = items[i];
          this[item + 'sUrl'] = this.projectUrl + path + '/' + item;
          if (this.pathType === item && subs.length > 2 && subs[2]) {
            this[item + 'Id'] = subs[2].replace(/^\/+|\/+$/g, '');
            this[item + 'Url'] = this.projectUrl + path + subs[0];
          }
        }
      }
    }

    // Set the app url if it is not set.
    if (!Formio.projectUrlSet) {
      Formio.projectUrl = this.projectUrl;
    }
  }

  _createClass(Formio, [{
    key: 'delete',
    value: function _delete(type, opts) {
      var _id = type + 'Id';
      var _url = type + 'Url';
      if (!this[_id]) {
        Promise.reject('Nothing to delete');
      }
      Formio.cache = {};
      return this.makeRequest(type, this[_url], 'delete', null, opts);
    }
  }, {
    key: 'index',
    value: function index(type, query, opts) {
      var _url = type + 'Url';
      query = query || '';
      if (query && (typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
        query = '?' + Formio.serialize(query.params);
      }
      return this.makeRequest(type, this[_url] + query, 'get', null, opts);
    }
  }, {
    key: 'save',
    value: function save(type, data, opts) {
      var _id = type + 'Id';
      var _url = type + 'Url';
      var method = this[_id] || data._id ? 'put' : 'post';
      var reqUrl = this[_id] ? this[_url] : this[type + 'sUrl'];
      if (!this[_id] && data._id && method === 'put' && reqUrl.indexOf(data._id) === -1) {
        reqUrl += '/' + data._id;
      }
      Formio.cache = {};
      return this.makeRequest(type, reqUrl + this.query, method, data, opts);
    }
  }, {
    key: 'load',
    value: function load(type, query, opts) {
      var _id = type + 'Id';
      var _url = type + 'Url';
      if (query && (typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
        query = Formio.serialize(query.params);
      }
      if (query) {
        query = this.query ? this.query + '&' + query : '?' + query;
      } else {
        query = this.query;
      }
      if (!this[_id]) {
        return Promise.reject('Missing ' + _id);
      }
      return this.makeRequest(type, this[_url] + query, 'get', null, opts);
    }
  }, {
    key: 'makeRequest',
    value: function makeRequest(type, url, method, data, opts) {
      method = (method || 'GET').toUpperCase();
      if (!opts || (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        opts = {};
      }

      var requestArgs = {
        formio: this,
        type: type,
        url: url,
        method: method,
        data: data,
        opts: opts
      };

      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('request', requestArgs).then(function (result) {
          if (result === null || result === undefined) {
            return Formio.request(url, method, data, opts.header, opts);
          }
          return result;
        });
      });

      return Formio.pluginAlter('wrapRequestPromise', request, requestArgs);
    }
  }, {
    key: 'loadProject',
    value: function loadProject(query, opts) {
      return this.load('project', query, opts);
    }
  }, {
    key: 'saveProject',
    value: function saveProject(data, opts) {
      return this.save('project', data, opts);
    }
  }, {
    key: 'deleteProject',
    value: function deleteProject(opts) {
      return this.delete('project', opts);
    }
  }, {
    key: 'loadForm',
    value: function loadForm(query, opts) {
      return this.load('form', query, opts);
    }
  }, {
    key: 'saveForm',
    value: function saveForm(data, opts) {
      return this.save('form', data, opts);
    }
  }, {
    key: 'deleteForm',
    value: function deleteForm(opts) {
      return this.delete('form', opts);
    }
  }, {
    key: 'loadForms',
    value: function loadForms(query, opts) {
      return this.index('forms', query, opts);
    }
  }, {
    key: 'loadSubmission',
    value: function loadSubmission(query, opts) {
      return this.load('submission', query, opts);
    }
  }, {
    key: 'saveSubmission',
    value: function saveSubmission(data, opts) {
      return this.save('submission', data, opts);
    }
  }, {
    key: 'deleteSubmission',
    value: function deleteSubmission(opts) {
      return this.delete('submission', opts);
    }
  }, {
    key: 'loadSubmissions',
    value: function loadSubmissions(query, opts) {
      return this.index('submissions', query, opts);
    }
  }, {
    key: 'loadAction',
    value: function loadAction(query, opts) {
      return this.load('action', query, opts);
    }
  }, {
    key: 'saveAction',
    value: function saveAction(data, opts) {
      return this.save('action', data, opts);
    }
  }, {
    key: 'deleteAction',
    value: function deleteAction(opts) {
      return this.delete('action', opts);
    }
  }, {
    key: 'loadActions',
    value: function loadActions(query, opts) {
      return this.index('actions', query, opts);
    }
  }, {
    key: 'availableActions',
    value: function availableActions() {
      return this.makeRequest('availableActions', this.formUrl + '/actions');
    }
  }, {
    key: 'actionInfo',
    value: function actionInfo(name) {
      return this.makeRequest('actionInfo', this.formUrl + '/actions/' + name);
    }

    /**
     * Returns a temporary authentication token for single purpose token generation.
     */

  }, {
    key: 'getTempToken',
    value: function getTempToken(expire, allowed) {
      var token = Formio.getToken();
      if (!token) {
        return Promise.reject('You must be authenticated to generate a temporary auth token.');
      }
      return this.makeRequest('tempToken', this.projectUrl + '/token', 'GET', null, {
        header: new Headers({
          'x-expire': expire,
          'x-allow': allowed
        })
      });
    }
  }, {
    key: 'uploadFile',
    value: function uploadFile(storage, file, fileName, dir, progressCallback, url) {
      var requestArgs = {
        provider: storage,
        method: 'upload',
        file: file,
        fileName: fileName,
        dir: dir
      };
      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('fileRequest', requestArgs).then(function (result) {
          if (storage && (result === null || result === undefined)) {
            if (Formio.providers.storage.hasOwnProperty(storage)) {
              var provider = new Formio.providers.storage[storage](this);
              return provider.uploadFile(file, fileName, dir, progressCallback, url);
            } else {
              throw 'Storage provider not found';
            }
          }
          return result || { url: '' };
        }.bind(this));
      }.bind(this));

      return Formio.pluginAlter('wrapFileRequestPromise', request, requestArgs);
    }
  }, {
    key: 'downloadFile',
    value: function downloadFile(file) {
      var requestArgs = {
        method: 'download',
        file: file
      };

      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('fileRequest', requestArgs).then(function (result) {
          if (file.storage && (result === null || result === undefined)) {
            if (Formio.providers.storage.hasOwnProperty(file.storage)) {
              var provider = new Formio.providers.storage[file.storage](this);
              return provider.downloadFile(file);
            } else {
              throw 'Storage provider not found';
            }
          }
          return result || { url: '' };
        }.bind(this));
      }.bind(this));

      return Formio.pluginAlter('wrapFileRequestPromise', request, requestArgs);
    }
  }], [{
    key: 'loadProjects',
    value: function loadProjects(query, opts) {
      query = query || '';
      if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
        query = '?' + serialize(query.params);
      }
      return Formio.makeStaticRequest(Formio.baseUrl + '/project' + query);
    }
  }, {
    key: 'getUrlParts',
    value: function getUrlParts(url) {
      var regex = '^(http[s]?:\\/\\/)';
      if (this.base && url.indexOf(this.base) === 0) {
        regex += '(' + this.base.replace(/^http[s]?:\/\//, '') + ')';
      } else {
        regex += '([^/]+)';
      }
      regex += '($|\\/.*)';
      return url.match(new RegExp(regex));
    }
  }, {
    key: 'serialize',
    value: function serialize(obj) {
      var str = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        }
      }return str.join("&");
    }
  }, {
    key: 'makeStaticRequest',
    value: function makeStaticRequest(url, method, data, opts) {
      method = (method || 'GET').toUpperCase();
      if (!opts || (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        opts = {};
      }
      var requestArgs = {
        url: url,
        method: method,
        data: data
      };

      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('staticRequest', requestArgs).then(function (result) {
          if (result === null || result === undefined) {
            return Formio.request(url, method, data, opts.header, opts);
          }
          return result;
        });
      });

      return Formio.pluginAlter('wrapStaticRequestPromise', request, requestArgs);
    }
  }, {
    key: 'request',
    value: function request(url, method, data, header, opts) {
      if (!url) {
        return Promise.reject('No url provided');
      }
      method = (method || 'GET').toUpperCase();

      // For reverse compatibility, if they provided the ignoreCache parameter,
      // then change it back to the options format where that is a parameter.
      if (typeof opts === 'boolean') {
        opts = { ignoreCache: opts };
      }
      if (!opts || (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        opts = {};
      }

      var cacheKey = btoa(url);

      return new Promise(function (resolve, reject) {
        // Get the cached promise to save multiple loads.
        if (!opts.ignoreCache && method === 'GET' && Formio.cache.hasOwnProperty(cacheKey)) {
          return resolve(Formio.cache[cacheKey]);
        }

        var requestToken = '';
        resolve(new Promise(function (resolve, reject) {
          // Set up and fetch request
          var headers = header || new Headers({
            'Accept': 'application/json',
            'Content-type': 'application/json; charset=UTF-8'
          });
          var token = Formio.getToken();
          if (token && !opts.noToken) {
            headers.append('x-jwt-token', token);
          }

          var options = {
            method: method,
            headers: headers,
            mode: 'cors'
          };
          if (data) {
            options.body = JSON.stringify(data);
          }

          requestToken = headers.get('x-jwt-token');
          resolve(fetch(url, options));
        }).catch(function (err) {
          err.message = 'Could not connect to API server (' + err.message + ')';
          err.networkError = true;
          throw err;
        }).then(function (response) {
          if (!response.ok) {
            if (response.status === 440) {
              Formio.setToken(null);
              Formio.events.emit('formio.sessionExpired', response.body);
            } else if (response.status === 401) {
              Formio.events.emit('formio.unauthorized', response.body);
            }
            // Parse and return the error as a rejected promise to reject this promise
            return (response.headers.get('content-type').indexOf('application/json') !== -1 ? response.json() : response.text()).then(function (error) {
              throw error;
            });
          }

          // Handle fetch results
          var token = response.headers.get('x-jwt-token');

          // In some strange cases, the fetch library will return an x-jwt-token without sending
          // one to the server. This has even been debugged on the server to verify that no token
          // was introduced with the request, but the response contains a token. This is an Invalid
          // case where we do not send an x-jwt-token and get one in return for any GET request.
          var tokenIntroduced = false;
          if (method === 'GET' && !requestToken && token && url.indexOf('token=') === -1 && url.indexOf('x-jwt-token=' === -1)) {
            console.warn('Token was introduced in request.');
            tokenIntroduced = true;
          }

          if (response.status >= 200 && response.status < 300 && token && token !== '' && !tokenIntroduced) {
            Formio.setToken(token);
          }
          // 204 is no content. Don't try to .json() it.
          if (response.status === 204) {
            return {};
          }
          return (response.headers.get('content-type').indexOf('application/json') !== -1 ? response.json() : response.text()).then(function (result) {
            // Add some content-range metadata to the result here
            var range = response.headers.get('content-range');
            if (range && (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
              range = range.split('/');
              if (range[0] !== '*') {
                var skipLimit = range[0].split('-');
                result.skip = Number(skipLimit[0]);
                result.limit = skipLimit[1] - skipLimit[0] + 1;
              }
              result.serverCount = range[1] === '*' ? range[1] : Number(range[1]);
            }

            if (!opts.getHeaders) {
              return result;
            }

            var headers = {};
            response.headers.forEach(function (item, key) {
              headers[key] = item;
            });

            return new Promise(function (resolve, reject) {
              resolve({ result: result, headers: headers });
            });
          });
        }).catch(function (err) {
          if (err === 'Bad Token') {
            Formio.setToken(null);
            Formio.events.emit('formio.badToken', err);
          }
          if (Formio.cache.hasOwnProperty(cacheKey)) {
            // Remove failed promises from cache
            delete Formio.cache[cacheKey];
          }
          // Propagate error so client can handle accordingly
          throw err;
        }));
      }).then(function (result) {
        // Save the cache
        if (method === 'GET') {
          Formio.cache[cacheKey] = Promise.resolve(result);
        }

        // Shallow copy result so modifications don't end up in cache
        if (Array.isArray(result)) {
          var resultCopy = result.map(copy);
          resultCopy.skip = result.skip;
          resultCopy.limit = result.limit;
          resultCopy.serverCount = result.serverCount;
          return resultCopy;
        }
        return copy(result);
      });
    }
  }, {
    key: 'setToken',
    value: function setToken(token) {
      token = token || '';
      if (token === this.token) {
        return;
      }
      this.token = token;
      if (!token) {
        Formio.setUser(null);
        // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
        try {
          return localStorage.removeItem('formioToken');
        } catch (err) {
          return;
        }
      }
      // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
      try {
        localStorage.setItem('formioToken', token);
      } catch (err) {
        // Do nothing.
      }
      return Formio.currentUser(); // Run this so user is updated if null
    }
  }, {
    key: 'getToken',
    value: function getToken() {
      if (this.token) {
        return this.token;
      }
      try {
        var token = localStorage.getItem('formioToken') || '';
        this.token = token;
        return token;
      } catch (e) {
        return '';
      }
    }
  }, {
    key: 'setUser',
    value: function setUser(user) {
      if (!user) {
        this.setToken(null);
        // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
        try {
          return localStorage.removeItem('formioUser');
        } catch (err) {
          return;
        }
      }
      // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
      try {
        localStorage.setItem('formioUser', JSON.stringify(user));
      } catch (err) {
        // Do nothing.
      }
    }
  }, {
    key: 'getUser',
    value: function getUser() {
      try {
        return JSON.parse(localStorage.getItem('formioUser') || null);
      } catch (e) {
        return;
      }
    }
  }, {
    key: 'setBaseUrl',
    value: function setBaseUrl(url) {
      Formio.baseUrl = url;
      if (!Formio.projectUrlSet) {
        Formio.projectUrl = url;
      }
    }
  }, {
    key: 'getBaseUrl',
    value: function getBaseUrl() {
      return Formio.baseUrl;
    }
  }, {
    key: 'setApiUrl',
    value: function setApiUrl(url) {
      return Formio.setBaseUrl(url);
    }
  }, {
    key: 'getApiUrl',
    value: function getApiUrl() {
      return Formio.getBaseUrl();
    }
  }, {
    key: 'setAppUrl',
    value: function setAppUrl(url) {
      console.warn('Formio.setAppUrl() is deprecated. Use Formio.setProjectUrl instead.');
      Formio.projectUrl = url;
      Formio.projectUrlSet = true;
    }
  }, {
    key: 'setProjectUrl',
    value: function setProjectUrl(url) {
      Formio.projectUrl = url;
      Formio.projectUrlSet = true;
    }
  }, {
    key: 'getAppUrl',
    value: function getAppUrl() {
      console.warn('Formio.getAppUrl() is deprecated. Use Formio.getProjectUrl instead.');
      return Formio.projectUrl;
    }
  }, {
    key: 'getProjectUrl',
    value: function getProjectUrl() {
      return Formio.projectUrl;
    }
  }, {
    key: 'clearCache',
    value: function clearCache() {
      Formio.cache = {};
    }
  }, {
    key: 'noop',
    value: function noop() {}
  }, {
    key: 'identity',
    value: function identity(value) {
      return value;
    }
  }, {
    key: 'deregisterPlugin',
    value: function deregisterPlugin(plugin) {
      var beforeLength = Formio.plugins.length;
      Formio.plugins = Formio.plugins.filter(function (p) {
        if (p !== plugin && p.__name !== plugin) return true;
        (p.deregister || Formio.noop).call(p, Formio);
        return false;
      });
      return beforeLength !== Formio.plugins.length;
    }
  }, {
    key: 'registerPlugin',
    value: function registerPlugin(plugin, name) {
      Formio.plugins.push(plugin);
      Formio.plugins.sort(function (a, b) {
        return (b.priority || 0) - (a.priority || 0);
      });
      plugin.__name = name;
      (plugin.init || Formio.noop).call(plugin, Formio);
    }
  }, {
    key: 'getPlugin',
    value: function getPlugin(name) {
      return Formio.plugins.reduce(function (result, plugin) {
        if (result) return result;
        if (plugin.__name === name) return plugin;
      }, null);
    }
  }, {
    key: 'pluginWait',
    value: function pluginWait(pluginFn) {
      var args = [].slice.call(arguments, 1);
      return Promise.all(Formio.plugins.map(function (plugin) {
        return (plugin[pluginFn] || Formio.noop).apply(plugin, args);
      }));
    }
  }, {
    key: 'pluginGet',
    value: function pluginGet(pluginFn) {
      var args = [].slice.call(arguments, 0);
      var callPlugin = function callPlugin(index, pluginFn) {
        var plugin = Formio.plugins[index];
        if (!plugin) return Promise.resolve(null);
        return Promise.resolve((plugin && plugin[pluginFn] || Formio.noop).apply(plugin, [].slice.call(arguments, 2))).then(function (result) {
          if (result !== null && result !== undefined) return result;
          return callPlugin.apply(null, [index + 1].concat(args));
        });
      };
      return callPlugin.apply(null, [0].concat(args));
    }
  }, {
    key: 'pluginAlter',
    value: function pluginAlter(pluginFn, value) {
      var args = [].slice.call(arguments, 2);
      return Formio.plugins.reduce(function (value, plugin) {
        return (plugin[pluginFn] || Formio.identity).apply(plugin, [value].concat(args));
      }, value);
    }
  }, {
    key: 'currentUser',
    value: function currentUser() {
      var url = Formio.baseUrl + '/current';
      var user = this.getUser();
      if (user) {
        return Formio.pluginAlter('wrapStaticRequestPromise', Promise.resolve(user), {
          url: url,
          method: 'GET'
        });
      }
      var token = this.getToken();
      if (!token) {
        return Formio.pluginAlter('wrapStaticRequestPromise', Promise.resolve(null), {
          url: url,
          method: 'GET'
        });
      }
      return Formio.makeStaticRequest(url).then(function (response) {
        Formio.setUser(response);
        return response;
      });
    }
  }, {
    key: 'logout',
    value: function logout() {
      Formio.setToken(null);
      Formio.setUser(null);
      Formio.clearCache();
      return Formio.makeStaticRequest(Formio.baseUrl + '/logout');
    }

    /**
     * Attach an HTML form to Form.io.
     *
     * @param form
     */

  }, {
    key: 'form',
    value: function form(_form, options, done) {
      // Fix the parameters.
      if (!done && typeof options === 'function') {
        done = options;
        options = {};
      }

      done = done || function () {
        console.log(arguments);
      };
      options = options || {};

      // IF they provide a jquery object, then select the element.
      if (_form.jquery) {
        _form = _form[0];
      }
      if (!_form) {
        return done('Invalid Form');
      }

      var getAction = function getAction() {
        return options.form || _form.getAttribute('action');
      };

      /**
       * Returns the current submission object.
       * @returns {{data: {}}}
       */
      var getSubmission = function getSubmission() {
        var submission = { data: {} };
        var setValue = function setValue(path, value) {
          var isArray = path.substr(-2) === '[]';
          if (isArray) {
            path = path.replace('[]', '');
          }
          var paths = path.replace(/\[|\]\[/g, '.').replace(/\]$/g, '').split('.');
          var current = submission;
          while (path = paths.shift()) {
            if (!paths.length) {
              if (isArray) {
                if (!current[path]) {
                  current[path] = [];
                }
                current[path].push(value);
              } else {
                current[path] = value;
              }
            } else {
              if (!current[path]) {
                current[path] = {};
              }
              current = current[path];
            }
          }
        };

        // Get the form data from this form.
        var formData = new FormData(_form);
        var entries = formData.entries();
        var entry = null;
        while (entry = entries.next().value) {
          setValue(entry[0], entry[1]);
        }
        return submission;
      };

      // Submits the form.
      var submit = function submit(event) {
        if (event) {
          event.preventDefault();
        }
        var action = getAction();
        if (!action) {
          return;
        }
        new Formio(action).saveSubmission(getSubmission()).then(function (sub) {
          done(null, sub);
        }, done);
      };

      // Attach formio to the provided form.
      if (_form.attachEvent) {
        _form.attachEvent('submit', submit);
      } else {
        _form.addEventListener('submit', submit);
      }

      return {
        submit: submit,
        getAction: getAction,
        getSubmission: getSubmission
      };
    }
  }, {
    key: 'fieldData',
    value: function fieldData(data, component) {
      if (!data) {
        return '';
      }
      if (!component || !component.key) {
        return data;
      }
      if (component.key.indexOf('.') !== -1) {
        var value = data;
        var parts = component.key.split('.');
        var key = '';
        for (var i = 0; i < parts.length; i++) {
          key = parts[i];

          // Handle nested resources
          if (value.hasOwnProperty('_id')) {
            value = value.data;
          }

          // Return if the key is not found on the value.
          if (!value.hasOwnProperty(key)) {
            return;
          }

          // Convert old single field data in submissions to multiple
          if (key === parts[parts.length - 1] && component.multiple && !Array.isArray(value[key])) {
            value[key] = [value[key]];
          }

          // Set the value of this key.
          value = value[key];
        }
        return value;
      } else {
        // Convert old single field data in submissions to multiple
        if (component.multiple && !Array.isArray(data[component.key])) {
          data[component.key] = [data[component.key]];
        }
        return data[component.key];
      }
    }
  }]);

  return Formio;
}();

// Define all the static properties.


exports.Formio = Formio;
Formio.baseUrl = 'https://api.form.io';
Formio.projectUrl = Formio.baseUrl;
Formio.projectUrlSet = false;
Formio.plugins = [];
Formio.cache = {};
Formio.providers = _dereq_('./providers');
Formio.events = new EventEmitter({
  wildcard: false,
  maxListeners: 0
});

module.exports = global.Formio = Formio;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./providers":3,"eventemitter2":1,"native-promise-only":168,"shallow-copy":169,"whatwg-fetch":171}],3:[function(_dereq_,module,exports){
'use strict';

module.exports = {
  storage: _dereq_('./storage')
};

},{"./storage":5}],4:[function(_dereq_,module,exports){
'use strict';

var Promise = _dereq_("native-promise-only");
var dropbox = function dropbox(formio) {
  return {
    uploadFile: function uploadFile(file, fileName, dir, progressCallback) {
      return new Promise(function (resolve, reject) {
        // Send the file with data.
        var xhr = new XMLHttpRequest();

        if (typeof progressCallback === 'function') {
          xhr.upload.onprogress = progressCallback;
        }

        var fd = new FormData();
        fd.append('name', fileName);
        fd.append('dir', dir);
        fd.append('file', file);

        // Fire on network error.
        xhr.onerror = function (err) {
          err.networkError = true;
          reject(err);
        };

        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            var response = JSON.parse(xhr.response);
            response.storage = 'dropbox';
            response.size = file.size;
            response.type = file.type;
            response.url = response.path_lower;
            resolve(response);
          } else {
            reject(xhr.response || 'Unable to upload file');
          }
        };

        xhr.onabort = function (err) {
          reject(err);
        };

        xhr.open('POST', formio.formUrl + '/storage/dropbox');
        var token = false;
        try {
          token = localStorage.getItem('formioToken');
        } catch (e) {
          // Swallow error.
        }
        if (token) {
          xhr.setRequestHeader('x-jwt-token', token);
        }
        xhr.send(fd);
      });
    },
    downloadFile: function downloadFile(file) {
      var token = false;
      try {
        token = localStorage.getItem('formioToken');
      } catch (e) {
        // Swallow error.
      }
      file.url = formio.formUrl + '/storage/dropbox?path_lower=' + file.path_lower + (token ? '&x-jwt-token=' + token : '');
      return Promise.resolve(file);
    }
  };
};

dropbox.title = 'Dropbox';
module.exports = dropbox;

},{"native-promise-only":168}],5:[function(_dereq_,module,exports){
'use strict';

module.exports = {
  dropbox: _dereq_('./dropbox.js'),
  s3: _dereq_('./s3.js'),
  url: _dereq_('./url.js')
};

},{"./dropbox.js":4,"./s3.js":6,"./url.js":7}],6:[function(_dereq_,module,exports){
'use strict';

var Promise = _dereq_("native-promise-only");
var s3 = function s3(formio) {
  return {
    uploadFile: function uploadFile(file, fileName, dir, progressCallback) {
      return new Promise(function (resolve, reject) {
        // Send the pre response to sign the upload.
        var pre = new XMLHttpRequest();

        var prefd = new FormData();
        prefd.append('name', fileName);
        prefd.append('size', file.size);
        prefd.append('type', file.type);

        // This only fires on a network error.
        pre.onerror = function (err) {
          err.networkError = true;
          reject(err);
        };

        pre.onabort = function (err) {
          reject(err);
        };

        pre.onload = function () {
          if (pre.status >= 200 && pre.status < 300) {
            var response = JSON.parse(pre.response);

            // Send the file with data.
            var xhr = new XMLHttpRequest();

            if (typeof progressCallback === 'function') {
              xhr.upload.onprogress = progressCallback;
            }

            response.data.fileName = fileName;
            response.data.key += dir + fileName;

            var fd = new FormData();
            for (var key in response.data) {
              fd.append(key, response.data[key]);
            }
            fd.append('file', file);

            // Fire on network error.
            xhr.onerror = function (err) {
              err.networkError = true;
              reject(err);
            };

            xhr.onload = function () {
              if (xhr.status >= 200 && xhr.status < 300) {
                resolve({
                  storage: 's3',
                  name: fileName,
                  bucket: response.bucket,
                  key: response.data.key,
                  url: response.url + response.data.key,
                  acl: response.data.acl,
                  size: file.size,
                  type: file.type
                });
              } else {
                reject(xhr.response || 'Unable to upload file');
              }
            };

            xhr.onabort = function (err) {
              reject(err);
            };

            xhr.open('POST', response.url);

            xhr.send(fd);
          } else {
            reject(pre.response || 'Unable to sign file');
          }
        };

        pre.open('POST', formio.formUrl + '/storage/s3');

        pre.setRequestHeader('Accept', 'application/json');
        pre.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        var token = false;
        try {
          token = localStorage.getItem('formioToken');
        } catch (e) {
          // swallow error.
        }
        if (token) {
          pre.setRequestHeader('x-jwt-token', token);
        }

        pre.send(JSON.stringify({
          name: fileName,
          size: file.size,
          type: file.type
        }));
      });
    },
    downloadFile: function downloadFile(file) {
      if (file.acl !== 'public-read') {
        return formio.makeRequest('file', formio.formUrl + '/storage/s3?bucket=' + file.bucket + '&key=' + file.key, 'GET');
      } else {
        return Promise.resolve(file);
      }
    }
  };
};

s3.title = 'S3';
module.exports = s3;

},{"native-promise-only":168}],7:[function(_dereq_,module,exports){
'use strict';

var Promise = _dereq_("native-promise-only");
var url = function url(formio) {
  return {
    title: 'Url',
    name: 'url',
    uploadFile: function uploadFile(file, fileName, dir, progressCallback, url) {
      return new Promise(function (resolve, reject) {
        var data = {
          dir: dir,
          name: fileName,
          file: file
        };

        // Send the file with data.
        var xhr = new XMLHttpRequest();

        if (typeof progressCallback === 'function') {
          xhr.upload.onprogress = progressCallback;
        }

        var fd = new FormData();
        for (var key in data) {
          fd.append(key, data[key]);
        }

        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            // Need to test if xhr.response is decoded or not.
            var respData = {};
            try {
              respData = typeof xhr.response === 'string' ? JSON.parse(xhr.response) : {};
              respData = respData && respData.data ? respData.data : {};
            } catch (err) {
              respData = {};
            }

            resolve({
              storage: 'url',
              name: fileName,
              url: xhr.responseURL + '/' + fileName,
              size: file.size,
              type: file.type,
              data: respData
            });
          } else {
            reject(xhr.response || 'Unable to upload file');
          }
        };

        // Fire on network error.
        xhr.onerror = function () {
          reject(xhr);
        };

        xhr.onabort = function () {
          reject(xhr);
        };

        xhr.open('POST', url);
        var token = localStorage.getItem('formioToken');
        if (token) {
          xhr.setRequestHeader('x-jwt-token', token);
        }
        xhr.send(fd);
      });
    },
    downloadFile: function downloadFile(file) {
      // Return the original as there is nothing to do.
      return Promise.resolve(file);
    }
  };
};

url.title = 'Url';
module.exports = url;

},{"native-promise-only":168}],8:[function(_dereq_,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _jsonLogicJs = _dereq_('json-logic-js');

var _jsonLogicJs2 = _interopRequireDefault(_jsonLogicJs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _get = _dereq_('lodash/get');

module.exports = {
  /**
   * Determine if a component is a layout component or not.
   *
   * @param {Object} component
   *   The component to check.
   *
   * @returns {Boolean}
   *   Whether or not the component is a layout component.
   */
  isLayoutComponent: function isLayoutComponent(component) {
    return component.columns && Array.isArray(component.columns) || component.rows && Array.isArray(component.rows) || component.components && Array.isArray(component.components) ? true : false;
  },

  /**
   * Iterate through each component within a form.
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {Function} fn
   *   The iteration function to invoke for each component.
   * @param {Boolean} includeAll
   *   Whether or not to include layout components.
   * @param {String} path
   *   The current data path of the element. Example: data.user.firstName
   */
  eachComponent: function eachComponent(components, fn, includeAll, path) {
    if (!components) return;
    path = path || '';
    components.forEach(function (component) {
      var hasColumns = component.columns && Array.isArray(component.columns);
      var hasRows = component.rows && Array.isArray(component.rows);
      var hasComps = component.components && Array.isArray(component.components);
      var noRecurse = false;
      var newPath = component.key ? path ? path + '.' + component.key : component.key : '';

      if (includeAll || component.tree || !hasColumns && !hasRows && !hasComps) {
        noRecurse = fn(component, newPath);
      }

      var subPath = function subPath() {
        if (component.key && (component.type === 'datagrid' || component.type === 'container')) {
          return newPath;
        }
        return path;
      };

      if (!noRecurse) {
        if (hasColumns) {
          component.columns.forEach(function (column) {
            eachComponent(column.components, fn, includeAll, subPath());
          });
        } else if (hasRows) {
          [].concat.apply([], component.rows).forEach(function (row) {
            eachComponent(row.components, fn, includeAll, subPath());
          });
        } else if (hasComps) {
          eachComponent(component.components, fn, includeAll, subPath());
        }
      }
    });
  },

  /**
   * Get a component by its key
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {String} key
   *   The key of the component to get.
   *
   * @returns {Object}
   *   The component that matches the given key, or undefined if not found.
   */
  getComponent: function getComponent(components, key) {
    var result;
    module.exports.eachComponent(components, function (component) {
      if (component.key === key) {
        result = component;
      }
    });
    return result;
  },

  /**
   * Flatten the form components for data manipulation.
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {Boolean} includeAll
   *   Whether or not to include layout components.
   *
   * @returns {Object}
   *   The flattened components map.
   */
  flattenComponents: function flattenComponents(components, includeAll) {
    var flattened = {};
    module.exports.eachComponent(components, function (component, path) {
      flattened[path] = component;
    }, includeAll);
    return flattened;
  },

  /**
   * Checks the conditions for a provided component and data.
   *
   * @param component
   *   The component to check for the condition.
   * @param row
   *   The data within a row
   * @param data
   *   The full submission data.
   *
   * @returns {boolean}
   */
  checkCondition: function checkCondition(component, row, data) {
    if (component.hasOwnProperty('customConditional') && component.customConditional) {
      try {
        var script = '(function() { var show = true;';
        script += component.customConditional.toString();
        script += '; return show; })()';
        var result = eval(script);
        return result.toString() === 'true';
      } catch (e) {
        console.warn('An error occurred in a custom conditional statement for component ' + component.key, e);
        return true;
      }
    } else if (component.hasOwnProperty('conditional') && component.conditional && component.conditional.when) {
      var cond = component.conditional;
      var value = null;
      if (row) {
        value = this.getValue({ data: row }, cond.when);
      }
      if (data && (value === null || typeof value === 'undefined')) {
        value = this.getValue({ data: data }, cond.when);
      }
      // FOR-400 - Fix issue where falsey values were being evaluated as show=true
      if (value === null || typeof value === 'undefined') {
        return false;
      }
      // Special check for selectboxes component.
      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.hasOwnProperty(cond.eq)) {
        return value[cond.eq].toString() === cond.show.toString();
      }
      // FOR-179 - Check for multiple values.
      if (value instanceof Array && value.indexOf(cond.eq) !== -1) {
        return cond.show.toString() === 'true';
      }

      return value.toString() === cond.eq.toString() === (cond.show.toString() === 'true');
    } else if (component.hasOwnProperty('conditional') && component.conditional && component.conditional.json) {
      return _jsonLogicJs2.default.apply(component.conditional.json, {
        data: data,
        row: row
      });
    }

    // Default to show.
    return true;
  },

  /**
   * Get the value for a component key, in the given submission.
   *
   * @param {Object} submission
   *   A submission object to search.
   * @param {String} key
   *   A for components API key to search for.
   */
  getValue: function getValue(submission, key) {
    var data = submission.data || {};

    var search = function search(data) {
      var i;
      var value;

      if (!data) {
        return null;
      }

      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && !(data instanceof Array)) {
        if (data.hasOwnProperty(key)) {
          return data[key];
        }

        var keys = Object.keys(data);
        for (i = 0; i < keys.length; i++) {
          if (_typeof(data[keys[i]]) === 'object') {
            value = search(data[keys[i]]);
          }

          if (value) {
            return value;
          }
        }
      }
    };

    return search(data);
  },

  /**
   * Interpolate a string and add data replacements.
   *
   * @param string
   * @param data
   * @returns {XML|string|*|void}
   */
  interpolate: function interpolate(string, data) {
    return string.replace(/\{\{\s*([^\s]*)\s*\}\}/g, function (match, token) {
      return _get(data, token);
    });
  }
};

},{"json-logic-js":10,"lodash/get":146}],9:[function(_dereq_,module,exports){
'use strict';

module.exports = _dereq_('./build/utils');

},{"./build/utils":8}],10:[function(_dereq_,module,exports){
/* globals define,module */
/*
Using a Universal Module Loader that should be browser, require, and AMD friendly
http://ricostacruz.com/cheatsheets/umdjs.html
*/
;(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory);
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    root.jsonLogic = factory();
  }
}(this, function() {
  "use strict";
  /* globals console:false */

  if ( ! Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
  }

  function arrayUnique(array) {
    var a = [];
    for (var i=0, l=array.length; i<l; i++) {
      if (a.indexOf(array[i]) === -1) {
        a.push(array[i]);
      }
    }
    return a;
  }

  var jsonLogic = {};
  var operations = {
    "==": function(a, b) {
      return a == b;
    },
    "===": function(a, b) {
      return a === b;
    },
    "!=": function(a, b) {
      return a != b;
    },
    "!==": function(a, b) {
      return a !== b;
    },
    ">": function(a, b) {
      return a > b;
    },
    ">=": function(a, b) {
      return a >= b;
    },
    "<": function(a, b, c) {
      return (c === undefined) ? a < b : (a < b) && (b < c);
    },
    "<=": function(a, b, c) {
      return (c === undefined) ? a <= b : (a <= b) && (b <= c);
    },
    "!!": function(a) {
      return jsonLogic.truthy(a);
    },
    "!": function(a) {
      return !jsonLogic.truthy(a);
    },
    "%": function(a, b) {
      return a % b;
    },
    "log": function(a) {
      console.log(a); return a;
    },
    "in": function(a, b) {
      if(typeof b.indexOf === "undefined") return false;
      return (b.indexOf(a) !== -1);
    },
    "cat": function() {
      return Array.prototype.join.call(arguments, "");
    },
    "+": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return parseFloat(a, 10) + parseFloat(b, 10);
      }, 0);
    },
    "*": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return parseFloat(a, 10) * parseFloat(b, 10);
      });
    },
    "-": function(a, b) {
      if(b === undefined) {
        return -a;
      }else{
        return a - b;
      }
    },
    "/": function(a, b) { return a / b; },
    "min": function() {
      return Math.min.apply(this, arguments);
    },
    "max": function() {
      return Math.max.apply(this, arguments);
    },
    "merge": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return a.concat(b);
      }, []);
    },
    "var": function(a, b) {
      var not_found = (b === undefined) ? null : b;
      var sub_props = String(a).split(".");
      var data = this;
      for(var i = 0; i < sub_props.length; i++) {
        // Descending into data
        data = data[sub_props[i]];
        if(data === undefined) {
          return not_found;
        }
      }
      return data;
    },
    "missing": function() {
      /*
      Missing can receive many keys as many arguments, like {"missing:[1,2]}
      Missing can also receive *one* argument that is an array of keys,
      which typically happens if it's actually acting on the output of another command
      (like 'if' or 'merge')
      */

      var missing = [];
      var keys = Array.isArray(arguments[0]) ? arguments[0] : arguments;

      for(var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = jsonLogic.apply({"var": key}, this);
        if(value === null || value === "") {
          missing.push(key);
        }
      }

      return missing;
    },
    "missing_some": function(need_count, options) {
      // missing_some takes two arguments, how many (minimum) items must be present, and an array of keys (just like 'missing') to check for presence.
      var are_missing = jsonLogic.apply({"missing": options}, this);

      if(options.length - are_missing.length >= need_count) {
        return [];
      }else{
        return are_missing;
      }
    },
    "method": function(obj, method, args) {
      return obj[method].apply(obj, args);
    },

  };

  jsonLogic.is_logic = function(logic) {
    return (
      logic !== null && typeof logic === "object" && ! Array.isArray(logic)
    );
  };

  /*
  This helper will defer to the JsonLogic spec as a tie-breaker when different language interpreters define different behavior for the truthiness of primitives.  E.g., PHP considers empty arrays to be falsy, but Javascript considers them to be truthy. JsonLogic, as an ecosystem, needs one consistent answer.

  Literal | JS    |  PHP  |  JsonLogic
  --------+-------+-------+---------------
  []      | true  | false | false
  "0"     | true  | false | true
  */
  jsonLogic.truthy = function(value) {
    if(Array.isArray(value) && value.length === 0) {
      return false;
    }
    return !! value;
  };


  jsonLogic.get_operator = function(logic){
    return Object.keys(logic)[0];
  };

  jsonLogic.get_values = function(logic){
    return logic[ jsonLogic.get_operator(logic) ];
  };

  jsonLogic.apply = function(logic, data) {
    // Does this array contain logic? Only one way to find out.
    if(Array.isArray(logic)) {
      return logic.map(function(l) {
        return jsonLogic.apply(l, data);
      });
    }
    // You've recursed to a primitive, stop!
    if( ! jsonLogic.is_logic(logic) ) {
      return logic;
    }

    data = data || {};

    var op = jsonLogic.get_operator(logic);
    var values = logic[op];
    var i;
    var current;

    // easy syntax for unary operators, like {"var" : "x"} instead of strict {"var" : ["x"]}
    if( ! Array.isArray(values)) {
      values = [values];
    }

    // 'if', 'and', and 'or' violate the normal rule of depth-first calculating consequents, let each manage recursion as needed.
    if(op === "if" || op == "?:") {
      /* 'if' should be called with a odd number of parameters, 3 or greater
      This works on the pattern:
      if( 0 ){ 1 }else{ 2 };
      if( 0 ){ 1 }else if( 2 ){ 3 }else{ 4 };
      if( 0 ){ 1 }else if( 2 ){ 3 }else if( 4 ){ 5 }else{ 6 };

      The implementation is:
      For pairs of values (0,1 then 2,3 then 4,5 etc)
      If the first evaluates truthy, evaluate and return the second
      If the first evaluates falsy, jump to the next pair (e.g, 0,1 to 2,3)
      given one parameter, evaluate and return it. (it's an Else and all the If/ElseIf were false)
      given 0 parameters, return NULL (not great practice, but there was no Else)
      */
      for(i = 0; i < values.length - 1; i += 2) {
        if( jsonLogic.truthy( jsonLogic.apply(values[i], data) ) ) {
          return jsonLogic.apply(values[i+1], data);
        }
      }
      if(values.length === i+1) return jsonLogic.apply(values[i], data);
      return null;
    }else if(op === "and") { // Return first falsy, or last
      for(i=0; i < values.length; i+=1) {
        current = jsonLogic.apply(values[i], data);
        if( ! jsonLogic.truthy(current)) {
          return current;
        }
      }
      return current; // Last
    }else if(op === "or") {// Return first truthy, or last
      for(i=0; i < values.length; i+=1) {
        current = jsonLogic.apply(values[i], data);
        if( jsonLogic.truthy(current) ) {
          return current;
        }
      }
      return current; // Last
    }


    // Everyone else gets immediate depth-first recursion
    values = values.map(function(val) {
      return jsonLogic.apply(val, data);
    });


    if(typeof operations[op] === "function") {
      return operations[op].apply(data, values);
    }else if(op.indexOf(".") > 0) { // Contains a dot, and not in the 0th position
      var sub_ops = String(op).split(".");
      var operation = operations;
      for(i = 0; i < sub_ops.length; i++) {
        // Descending into operations
        operation = operation[sub_ops[i]];
        if(operation === undefined) {
          throw new Error("Unrecognized operation " + op +
          " (failed at " + sub_ops.slice(0, i+1).join(".") + ")");
        }
      }

      return operation.apply(data, values);
    }else{
      throw new Error("Unrecognized operation " + op );
    }

    // The operation is called with "data" bound to its "this" and "values" passed as arguments.
    // Structured commands like % or > can name formal arguments while flexible commands (like missing or merge) can operate on the pseudo-array arguments
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
    return operations[op].apply(data, values);
  };

  jsonLogic.uses_data = function(logic) {
    var collection = [];

    if( jsonLogic.is_logic(logic) ) {
      var op = jsonLogic.get_operator(logic);
      var values = logic[op];

      if( ! Array.isArray(values)) {
        values = [values];
      }

      if(op === "var") {
        // This doesn't cover the case where the arg to var is itself a rule.
        collection.push(values[0]);
      }else{
        // Recursion!
        values.map(function(val) {
          collection.push.apply(collection, jsonLogic.uses_data(val) );
        });
      }
    }

    return arrayUnique(collection);
  };

  jsonLogic.add_operation = function(name, code) {
    operations[name] = code;
  };


  jsonLogic.rule_like = function(rule, pattern){
		//console.log("Is ". JSON.stringify(rule) . " like " . JSON.stringify(pattern) . "?");
	  if(pattern === rule){ return true; } //TODO : Deep object equivalency?
	  if(pattern === "@"){ return true; } //Wildcard!
	  if(pattern === "number"){ return (typeof rule === 'number'); }
	  if(pattern === "string"){ return (typeof rule === 'string'); }
	  if(pattern === "array"){
      //!logic test might be superfluous in JavaScript
      return Array.isArray(rule) && ! jsonLogic.is_logic(rule);
    }

	  if(jsonLogic.is_logic(pattern)){
	    if(jsonLogic.is_logic(rule)){
	      var pattern_op = jsonLogic.get_operator(pattern);
        var rule_op = jsonLogic.get_operator(rule);

	      if(pattern_op === "@" || pattern_op === rule_op){
					//echo "\nOperators match, go deeper\n";
	        return jsonLogic.rule_like(
						jsonLogic.get_values(rule, false),
						jsonLogic.get_values(pattern, false)
					);
	      }

	    }
	    return false; //pattern is logic, rule isn't, can't be eq
	  }

	  if(Array.isArray(pattern)){
	    if(Array.isArray(rule)){
	      if(pattern.length !== rule.length){ return false; }
				/*
					Note, array order MATTERS, because we're using this array test logic to consider arguments, where order can matter. (e.g., + is commutative, but '-' or 'if' or 'var' are NOT)
				*/
	      for(var i = 0 ; i < pattern.length ; i += 1){
	        //If any fail, we fail
	        if( ! jsonLogic.rule_like(rule[i], pattern[i])){ return false; }
	      }
	      return true; //If they *all* passed, we pass
	    }else{
	      return false; //Pattern is array, rule isn't
	    }

	  }

		//Not logic, not array, not a === match for rule.
		return false;
	};



  return jsonLogic;
}));

},{}],11:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":90,"./_root":131}],12:[function(_dereq_,module,exports){
var hashClear = _dereq_('./_hashClear'),
    hashDelete = _dereq_('./_hashDelete'),
    hashGet = _dereq_('./_hashGet'),
    hashHas = _dereq_('./_hashHas'),
    hashSet = _dereq_('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":98,"./_hashDelete":99,"./_hashGet":100,"./_hashHas":101,"./_hashSet":102}],13:[function(_dereq_,module,exports){
var listCacheClear = _dereq_('./_listCacheClear'),
    listCacheDelete = _dereq_('./_listCacheDelete'),
    listCacheGet = _dereq_('./_listCacheGet'),
    listCacheHas = _dereq_('./_listCacheHas'),
    listCacheSet = _dereq_('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":112,"./_listCacheDelete":113,"./_listCacheGet":114,"./_listCacheHas":115,"./_listCacheSet":116}],14:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":90,"./_root":131}],15:[function(_dereq_,module,exports){
var mapCacheClear = _dereq_('./_mapCacheClear'),
    mapCacheDelete = _dereq_('./_mapCacheDelete'),
    mapCacheGet = _dereq_('./_mapCacheGet'),
    mapCacheHas = _dereq_('./_mapCacheHas'),
    mapCacheSet = _dereq_('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":117,"./_mapCacheDelete":118,"./_mapCacheGet":119,"./_mapCacheHas":120,"./_mapCacheSet":121}],16:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":90,"./_root":131}],17:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":90,"./_root":131}],18:[function(_dereq_,module,exports){
var MapCache = _dereq_('./_MapCache'),
    setCacheAdd = _dereq_('./_setCacheAdd'),
    setCacheHas = _dereq_('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":15,"./_setCacheAdd":132,"./_setCacheHas":133}],19:[function(_dereq_,module,exports){
var ListCache = _dereq_('./_ListCache'),
    stackClear = _dereq_('./_stackClear'),
    stackDelete = _dereq_('./_stackDelete'),
    stackGet = _dereq_('./_stackGet'),
    stackHas = _dereq_('./_stackHas'),
    stackSet = _dereq_('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":13,"./_stackClear":135,"./_stackDelete":136,"./_stackGet":137,"./_stackHas":138,"./_stackSet":139}],20:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":131}],21:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":131}],22:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":90,"./_root":131}],23:[function(_dereq_,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],24:[function(_dereq_,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],25:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],26:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],27:[function(_dereq_,module,exports){
var baseTimes = _dereq_('./_baseTimes'),
    isArguments = _dereq_('./isArguments'),
    isArray = _dereq_('./isArray'),
    isBuffer = _dereq_('./isBuffer'),
    isIndex = _dereq_('./_isIndex'),
    isTypedArray = _dereq_('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":61,"./_isIndex":106,"./isArguments":149,"./isArray":150,"./isBuffer":152,"./isTypedArray":159}],28:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],29:[function(_dereq_,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],30:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],31:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],32:[function(_dereq_,module,exports){
var baseAssignValue = _dereq_('./_baseAssignValue'),
    eq = _dereq_('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":36,"./eq":144}],33:[function(_dereq_,module,exports){
var eq = _dereq_('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":144}],34:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    keys = _dereq_('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":75,"./keys":160}],35:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    keysIn = _dereq_('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":75,"./keysIn":161}],36:[function(_dereq_,module,exports){
var defineProperty = _dereq_('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":81}],37:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    arrayEach = _dereq_('./_arrayEach'),
    assignValue = _dereq_('./_assignValue'),
    baseAssign = _dereq_('./_baseAssign'),
    baseAssignIn = _dereq_('./_baseAssignIn'),
    cloneBuffer = _dereq_('./_cloneBuffer'),
    copyArray = _dereq_('./_copyArray'),
    copySymbols = _dereq_('./_copySymbols'),
    copySymbolsIn = _dereq_('./_copySymbolsIn'),
    getAllKeys = _dereq_('./_getAllKeys'),
    getAllKeysIn = _dereq_('./_getAllKeysIn'),
    getTag = _dereq_('./_getTag'),
    initCloneArray = _dereq_('./_initCloneArray'),
    initCloneByTag = _dereq_('./_initCloneByTag'),
    initCloneObject = _dereq_('./_initCloneObject'),
    isArray = _dereq_('./isArray'),
    isBuffer = _dereq_('./isBuffer'),
    isObject = _dereq_('./isObject'),
    keys = _dereq_('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":19,"./_arrayEach":25,"./_assignValue":32,"./_baseAssign":34,"./_baseAssignIn":35,"./_cloneBuffer":67,"./_copyArray":74,"./_copySymbols":76,"./_copySymbolsIn":77,"./_getAllKeys":86,"./_getAllKeysIn":87,"./_getTag":95,"./_initCloneArray":103,"./_initCloneByTag":104,"./_initCloneObject":105,"./isArray":150,"./isBuffer":152,"./isObject":156,"./keys":160}],38:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":156}],39:[function(_dereq_,module,exports){
var baseForOwn = _dereq_('./_baseForOwn'),
    createBaseEach = _dereq_('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":42,"./_createBaseEach":79}],40:[function(_dereq_,module,exports){
var baseEach = _dereq_('./_baseEach');

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

},{"./_baseEach":39}],41:[function(_dereq_,module,exports){
var createBaseFor = _dereq_('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":80}],42:[function(_dereq_,module,exports){
var baseFor = _dereq_('./_baseFor'),
    keys = _dereq_('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":41,"./keys":160}],43:[function(_dereq_,module,exports){
var castPath = _dereq_('./_castPath'),
    toKey = _dereq_('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":65,"./_toKey":141}],44:[function(_dereq_,module,exports){
var arrayPush = _dereq_('./_arrayPush'),
    isArray = _dereq_('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":29,"./isArray":150}],45:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol'),
    getRawTag = _dereq_('./_getRawTag'),
    objectToString = _dereq_('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":20,"./_getRawTag":92,"./_objectToString":129}],46:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],47:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":45,"./isObjectLike":157}],48:[function(_dereq_,module,exports){
var baseIsEqualDeep = _dereq_('./_baseIsEqualDeep'),
    isObjectLike = _dereq_('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":49,"./isObjectLike":157}],49:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    equalArrays = _dereq_('./_equalArrays'),
    equalByTag = _dereq_('./_equalByTag'),
    equalObjects = _dereq_('./_equalObjects'),
    getTag = _dereq_('./_getTag'),
    isArray = _dereq_('./isArray'),
    isBuffer = _dereq_('./isBuffer'),
    isTypedArray = _dereq_('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":19,"./_equalArrays":82,"./_equalByTag":83,"./_equalObjects":84,"./_getTag":95,"./isArray":150,"./isBuffer":152,"./isTypedArray":159}],50:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    baseIsEqual = _dereq_('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":19,"./_baseIsEqual":48}],51:[function(_dereq_,module,exports){
var isFunction = _dereq_('./isFunction'),
    isMasked = _dereq_('./_isMasked'),
    isObject = _dereq_('./isObject'),
    toSource = _dereq_('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":109,"./_toSource":142,"./isFunction":154,"./isObject":156}],52:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isLength = _dereq_('./isLength'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":45,"./isLength":155,"./isObjectLike":157}],53:[function(_dereq_,module,exports){
var baseMatches = _dereq_('./_baseMatches'),
    baseMatchesProperty = _dereq_('./_baseMatchesProperty'),
    identity = _dereq_('./identity'),
    isArray = _dereq_('./isArray'),
    property = _dereq_('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":56,"./_baseMatchesProperty":57,"./identity":148,"./isArray":150,"./property":163}],54:[function(_dereq_,module,exports){
var isPrototype = _dereq_('./_isPrototype'),
    nativeKeys = _dereq_('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":110,"./_nativeKeys":126}],55:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject'),
    isPrototype = _dereq_('./_isPrototype'),
    nativeKeysIn = _dereq_('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":110,"./_nativeKeysIn":127,"./isObject":156}],56:[function(_dereq_,module,exports){
var baseIsMatch = _dereq_('./_baseIsMatch'),
    getMatchData = _dereq_('./_getMatchData'),
    matchesStrictComparable = _dereq_('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":50,"./_getMatchData":89,"./_matchesStrictComparable":123}],57:[function(_dereq_,module,exports){
var baseIsEqual = _dereq_('./_baseIsEqual'),
    get = _dereq_('./get'),
    hasIn = _dereq_('./hasIn'),
    isKey = _dereq_('./_isKey'),
    isStrictComparable = _dereq_('./_isStrictComparable'),
    matchesStrictComparable = _dereq_('./_matchesStrictComparable'),
    toKey = _dereq_('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":48,"./_isKey":107,"./_isStrictComparable":111,"./_matchesStrictComparable":123,"./_toKey":141,"./get":146,"./hasIn":147}],58:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],59:[function(_dereq_,module,exports){
var baseGet = _dereq_('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":43}],60:[function(_dereq_,module,exports){
var assignValue = _dereq_('./_assignValue'),
    castPath = _dereq_('./_castPath'),
    isIndex = _dereq_('./_isIndex'),
    isObject = _dereq_('./isObject'),
    toKey = _dereq_('./_toKey');

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;

},{"./_assignValue":32,"./_castPath":65,"./_isIndex":106,"./_toKey":141,"./isObject":156}],61:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],62:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol'),
    arrayMap = _dereq_('./_arrayMap'),
    isArray = _dereq_('./isArray'),
    isSymbol = _dereq_('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":20,"./_arrayMap":28,"./isArray":150,"./isSymbol":158}],63:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],64:[function(_dereq_,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],65:[function(_dereq_,module,exports){
var isArray = _dereq_('./isArray'),
    isKey = _dereq_('./_isKey'),
    stringToPath = _dereq_('./_stringToPath'),
    toString = _dereq_('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":107,"./_stringToPath":140,"./isArray":150,"./toString":167}],66:[function(_dereq_,module,exports){
var Uint8Array = _dereq_('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":21}],67:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":131}],68:[function(_dereq_,module,exports){
var cloneArrayBuffer = _dereq_('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":66}],69:[function(_dereq_,module,exports){
var addMapEntry = _dereq_('./_addMapEntry'),
    arrayReduce = _dereq_('./_arrayReduce'),
    mapToArray = _dereq_('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":23,"./_arrayReduce":30,"./_mapToArray":122}],70:[function(_dereq_,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],71:[function(_dereq_,module,exports){
var addSetEntry = _dereq_('./_addSetEntry'),
    arrayReduce = _dereq_('./_arrayReduce'),
    setToArray = _dereq_('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":24,"./_arrayReduce":30,"./_setToArray":134}],72:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":20}],73:[function(_dereq_,module,exports){
var cloneArrayBuffer = _dereq_('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":66}],74:[function(_dereq_,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],75:[function(_dereq_,module,exports){
var assignValue = _dereq_('./_assignValue'),
    baseAssignValue = _dereq_('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":32,"./_baseAssignValue":36}],76:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    getSymbols = _dereq_('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":75,"./_getSymbols":93}],77:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    getSymbolsIn = _dereq_('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":75,"./_getSymbolsIn":94}],78:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":131}],79:[function(_dereq_,module,exports){
var isArrayLike = _dereq_('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":151}],80:[function(_dereq_,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],81:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":90}],82:[function(_dereq_,module,exports){
var SetCache = _dereq_('./_SetCache'),
    arraySome = _dereq_('./_arraySome'),
    cacheHas = _dereq_('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":18,"./_arraySome":31,"./_cacheHas":64}],83:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol'),
    Uint8Array = _dereq_('./_Uint8Array'),
    eq = _dereq_('./eq'),
    equalArrays = _dereq_('./_equalArrays'),
    mapToArray = _dereq_('./_mapToArray'),
    setToArray = _dereq_('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":20,"./_Uint8Array":21,"./_equalArrays":82,"./_mapToArray":122,"./_setToArray":134,"./eq":144}],84:[function(_dereq_,module,exports){
var getAllKeys = _dereq_('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":86}],85:[function(_dereq_,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],86:[function(_dereq_,module,exports){
var baseGetAllKeys = _dereq_('./_baseGetAllKeys'),
    getSymbols = _dereq_('./_getSymbols'),
    keys = _dereq_('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":44,"./_getSymbols":93,"./keys":160}],87:[function(_dereq_,module,exports){
var baseGetAllKeys = _dereq_('./_baseGetAllKeys'),
    getSymbolsIn = _dereq_('./_getSymbolsIn'),
    keysIn = _dereq_('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":44,"./_getSymbolsIn":94,"./keysIn":161}],88:[function(_dereq_,module,exports){
var isKeyable = _dereq_('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":108}],89:[function(_dereq_,module,exports){
var isStrictComparable = _dereq_('./_isStrictComparable'),
    keys = _dereq_('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":111,"./keys":160}],90:[function(_dereq_,module,exports){
var baseIsNative = _dereq_('./_baseIsNative'),
    getValue = _dereq_('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":51,"./_getValue":96}],91:[function(_dereq_,module,exports){
var overArg = _dereq_('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":130}],92:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":20}],93:[function(_dereq_,module,exports){
var arrayFilter = _dereq_('./_arrayFilter'),
    stubArray = _dereq_('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":26,"./stubArray":165}],94:[function(_dereq_,module,exports){
var arrayPush = _dereq_('./_arrayPush'),
    getPrototype = _dereq_('./_getPrototype'),
    getSymbols = _dereq_('./_getSymbols'),
    stubArray = _dereq_('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":29,"./_getPrototype":91,"./_getSymbols":93,"./stubArray":165}],95:[function(_dereq_,module,exports){
var DataView = _dereq_('./_DataView'),
    Map = _dereq_('./_Map'),
    Promise = _dereq_('./_Promise'),
    Set = _dereq_('./_Set'),
    WeakMap = _dereq_('./_WeakMap'),
    baseGetTag = _dereq_('./_baseGetTag'),
    toSource = _dereq_('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":11,"./_Map":14,"./_Promise":16,"./_Set":17,"./_WeakMap":22,"./_baseGetTag":45,"./_toSource":142}],96:[function(_dereq_,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],97:[function(_dereq_,module,exports){
var castPath = _dereq_('./_castPath'),
    isArguments = _dereq_('./isArguments'),
    isArray = _dereq_('./isArray'),
    isIndex = _dereq_('./_isIndex'),
    isLength = _dereq_('./isLength'),
    toKey = _dereq_('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":65,"./_isIndex":106,"./_toKey":141,"./isArguments":149,"./isArray":150,"./isLength":155}],98:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":125}],99:[function(_dereq_,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],100:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":125}],101:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":125}],102:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":125}],103:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],104:[function(_dereq_,module,exports){
var cloneArrayBuffer = _dereq_('./_cloneArrayBuffer'),
    cloneDataView = _dereq_('./_cloneDataView'),
    cloneMap = _dereq_('./_cloneMap'),
    cloneRegExp = _dereq_('./_cloneRegExp'),
    cloneSet = _dereq_('./_cloneSet'),
    cloneSymbol = _dereq_('./_cloneSymbol'),
    cloneTypedArray = _dereq_('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":66,"./_cloneDataView":68,"./_cloneMap":69,"./_cloneRegExp":70,"./_cloneSet":71,"./_cloneSymbol":72,"./_cloneTypedArray":73}],105:[function(_dereq_,module,exports){
var baseCreate = _dereq_('./_baseCreate'),
    getPrototype = _dereq_('./_getPrototype'),
    isPrototype = _dereq_('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":38,"./_getPrototype":91,"./_isPrototype":110}],106:[function(_dereq_,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],107:[function(_dereq_,module,exports){
var isArray = _dereq_('./isArray'),
    isSymbol = _dereq_('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":150,"./isSymbol":158}],108:[function(_dereq_,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],109:[function(_dereq_,module,exports){
var coreJsData = _dereq_('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":78}],110:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],111:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":156}],112:[function(_dereq_,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],113:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":33}],114:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":33}],115:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":33}],116:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":33}],117:[function(_dereq_,module,exports){
var Hash = _dereq_('./_Hash'),
    ListCache = _dereq_('./_ListCache'),
    Map = _dereq_('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":12,"./_ListCache":13,"./_Map":14}],118:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":88}],119:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":88}],120:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":88}],121:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":88}],122:[function(_dereq_,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],123:[function(_dereq_,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],124:[function(_dereq_,module,exports){
var memoize = _dereq_('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":162}],125:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":90}],126:[function(_dereq_,module,exports){
var overArg = _dereq_('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":130}],127:[function(_dereq_,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],128:[function(_dereq_,module,exports){
var freeGlobal = _dereq_('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":85}],129:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],130:[function(_dereq_,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],131:[function(_dereq_,module,exports){
var freeGlobal = _dereq_('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":85}],132:[function(_dereq_,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],133:[function(_dereq_,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],134:[function(_dereq_,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],135:[function(_dereq_,module,exports){
var ListCache = _dereq_('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":13}],136:[function(_dereq_,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],137:[function(_dereq_,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],138:[function(_dereq_,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],139:[function(_dereq_,module,exports){
var ListCache = _dereq_('./_ListCache'),
    Map = _dereq_('./_Map'),
    MapCache = _dereq_('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":13,"./_Map":14,"./_MapCache":15}],140:[function(_dereq_,module,exports){
var memoizeCapped = _dereq_('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":124}],141:[function(_dereq_,module,exports){
var isSymbol = _dereq_('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":158}],142:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],143:[function(_dereq_,module,exports){
var baseClone = _dereq_('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":37}],144:[function(_dereq_,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],145:[function(_dereq_,module,exports){
var arrayFilter = _dereq_('./_arrayFilter'),
    baseFilter = _dereq_('./_baseFilter'),
    baseIteratee = _dereq_('./_baseIteratee'),
    isArray = _dereq_('./isArray');

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;

},{"./_arrayFilter":26,"./_baseFilter":40,"./_baseIteratee":53,"./isArray":150}],146:[function(_dereq_,module,exports){
var baseGet = _dereq_('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":43}],147:[function(_dereq_,module,exports){
var baseHasIn = _dereq_('./_baseHasIn'),
    hasPath = _dereq_('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":46,"./_hasPath":97}],148:[function(_dereq_,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],149:[function(_dereq_,module,exports){
var baseIsArguments = _dereq_('./_baseIsArguments'),
    isObjectLike = _dereq_('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":47,"./isObjectLike":157}],150:[function(_dereq_,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],151:[function(_dereq_,module,exports){
var isFunction = _dereq_('./isFunction'),
    isLength = _dereq_('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":154,"./isLength":155}],152:[function(_dereq_,module,exports){
var root = _dereq_('./_root'),
    stubFalse = _dereq_('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":131,"./stubFalse":166}],153:[function(_dereq_,module,exports){
var baseIsEqual = _dereq_('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

},{"./_baseIsEqual":48}],154:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObject = _dereq_('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":45,"./isObject":156}],155:[function(_dereq_,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],156:[function(_dereq_,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],157:[function(_dereq_,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],158:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":45,"./isObjectLike":157}],159:[function(_dereq_,module,exports){
var baseIsTypedArray = _dereq_('./_baseIsTypedArray'),
    baseUnary = _dereq_('./_baseUnary'),
    nodeUtil = _dereq_('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":52,"./_baseUnary":63,"./_nodeUtil":128}],160:[function(_dereq_,module,exports){
var arrayLikeKeys = _dereq_('./_arrayLikeKeys'),
    baseKeys = _dereq_('./_baseKeys'),
    isArrayLike = _dereq_('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":27,"./_baseKeys":54,"./isArrayLike":151}],161:[function(_dereq_,module,exports){
var arrayLikeKeys = _dereq_('./_arrayLikeKeys'),
    baseKeysIn = _dereq_('./_baseKeysIn'),
    isArrayLike = _dereq_('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":27,"./_baseKeysIn":55,"./isArrayLike":151}],162:[function(_dereq_,module,exports){
var MapCache = _dereq_('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":15}],163:[function(_dereq_,module,exports){
var baseProperty = _dereq_('./_baseProperty'),
    basePropertyDeep = _dereq_('./_basePropertyDeep'),
    isKey = _dereq_('./_isKey'),
    toKey = _dereq_('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":58,"./_basePropertyDeep":59,"./_isKey":107,"./_toKey":141}],164:[function(_dereq_,module,exports){
var baseSet = _dereq_('./_baseSet');

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;

},{"./_baseSet":60}],165:[function(_dereq_,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],166:[function(_dereq_,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],167:[function(_dereq_,module,exports){
var baseToString = _dereq_('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":62}],168:[function(_dereq_,module,exports){
(function (global){
/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/

(function UMD(name,context,definition){
	// special form of UMD for polyfilling across evironments
	context[name] = context[name] || definition();
	if (typeof module != "undefined" && module.exports) { module.exports = context[name]; }
	else if (typeof define == "function" && define.amd) { define(function $AMD$(){ return context[name]; }); }
})("Promise",typeof global != "undefined" ? global : this,function DEF(){
	/*jshint validthis:true */
	"use strict";

	var builtInProp, cycle, scheduling_queue,
		ToString = Object.prototype.toString,
		timer = (typeof setImmediate != "undefined") ?
			function timer(fn) { return setImmediate(fn); } :
			setTimeout
	;

	// dammit, IE8.
	try {
		Object.defineProperty({},"x",{});
		builtInProp = function builtInProp(obj,name,val,config) {
			return Object.defineProperty(obj,name,{
				value: val,
				writable: true,
				configurable: config !== false
			});
		};
	}
	catch (err) {
		builtInProp = function builtInProp(obj,name,val) {
			obj[name] = val;
			return obj;
		};
	}

	// Note: using a queue instead of array for efficiency
	scheduling_queue = (function Queue() {
		var first, last, item;

		function Item(fn,self) {
			this.fn = fn;
			this.self = self;
			this.next = void 0;
		}

		return {
			add: function add(fn,self) {
				item = new Item(fn,self);
				if (last) {
					last.next = item;
				}
				else {
					first = item;
				}
				last = item;
				item = void 0;
			},
			drain: function drain() {
				var f = first;
				first = last = cycle = void 0;

				while (f) {
					f.fn.call(f.self);
					f = f.next;
				}
			}
		};
	})();

	function schedule(fn,self) {
		scheduling_queue.add(fn,self);
		if (!cycle) {
			cycle = timer(scheduling_queue.drain);
		}
	}

	// promise duck typing
	function isThenable(o) {
		var _then, o_type = typeof o;

		if (o != null &&
			(
				o_type == "object" || o_type == "function"
			)
		) {
			_then = o.then;
		}
		return typeof _then == "function" ? _then : false;
	}

	function notify() {
		for (var i=0; i<this.chain.length; i++) {
			notifyIsolated(
				this,
				(this.state === 1) ? this.chain[i].success : this.chain[i].failure,
				this.chain[i]
			);
		}
		this.chain.length = 0;
	}

	// NOTE: This is a separate function to isolate
	// the `try..catch` so that other code can be
	// optimized better
	function notifyIsolated(self,cb,chain) {
		var ret, _then;
		try {
			if (cb === false) {
				chain.reject(self.msg);
			}
			else {
				if (cb === true) {
					ret = self.msg;
				}
				else {
					ret = cb.call(void 0,self.msg);
				}

				if (ret === chain.promise) {
					chain.reject(TypeError("Promise-chain cycle"));
				}
				else if (_then = isThenable(ret)) {
					_then.call(ret,chain.resolve,chain.reject);
				}
				else {
					chain.resolve(ret);
				}
			}
		}
		catch (err) {
			chain.reject(err);
		}
	}

	function resolve(msg) {
		var _then, self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		try {
			if (_then = isThenable(msg)) {
				schedule(function(){
					var def_wrapper = new MakeDefWrapper(self);
					try {
						_then.call(msg,
							function $resolve$(){ resolve.apply(def_wrapper,arguments); },
							function $reject$(){ reject.apply(def_wrapper,arguments); }
						);
					}
					catch (err) {
						reject.call(def_wrapper,err);
					}
				})
			}
			else {
				self.msg = msg;
				self.state = 1;
				if (self.chain.length > 0) {
					schedule(notify,self);
				}
			}
		}
		catch (err) {
			reject.call(new MakeDefWrapper(self),err);
		}
	}

	function reject(msg) {
		var self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		self.msg = msg;
		self.state = 2;
		if (self.chain.length > 0) {
			schedule(notify,self);
		}
	}

	function iteratePromises(Constructor,arr,resolver,rejecter) {
		for (var idx=0; idx<arr.length; idx++) {
			(function IIFE(idx){
				Constructor.resolve(arr[idx])
				.then(
					function $resolver$(msg){
						resolver(idx,msg);
					},
					rejecter
				);
			})(idx);
		}
	}

	function MakeDefWrapper(self) {
		this.def = self;
		this.triggered = false;
	}

	function MakeDef(self) {
		this.promise = self;
		this.state = 0;
		this.triggered = false;
		this.chain = [];
		this.msg = void 0;
	}

	function Promise(executor) {
		if (typeof executor != "function") {
			throw TypeError("Not a function");
		}

		if (this.__NPO__ !== 0) {
			throw TypeError("Not a promise");
		}

		// instance shadowing the inherited "brand"
		// to signal an already "initialized" promise
		this.__NPO__ = 1;

		var def = new MakeDef(this);

		this["then"] = function then(success,failure) {
			var o = {
				success: typeof success == "function" ? success : true,
				failure: typeof failure == "function" ? failure : false
			};
			// Note: `then(..)` itself can be borrowed to be used against
			// a different promise constructor for making the chained promise,
			// by substituting a different `this` binding.
			o.promise = new this.constructor(function extractChain(resolve,reject) {
				if (typeof resolve != "function" || typeof reject != "function") {
					throw TypeError("Not a function");
				}

				o.resolve = resolve;
				o.reject = reject;
			});
			def.chain.push(o);

			if (def.state !== 0) {
				schedule(notify,def);
			}

			return o.promise;
		};
		this["catch"] = function $catch$(failure) {
			return this.then(void 0,failure);
		};

		try {
			executor.call(
				void 0,
				function publicResolve(msg){
					resolve.call(def,msg);
				},
				function publicReject(msg) {
					reject.call(def,msg);
				}
			);
		}
		catch (err) {
			reject.call(def,err);
		}
	}

	var PromisePrototype = builtInProp({},"constructor",Promise,
		/*configurable=*/false
	);

	// Note: Android 4 cannot use `Object.defineProperty(..)` here
	Promise.prototype = PromisePrototype;

	// built-in "brand" to signal an "uninitialized" promise
	builtInProp(PromisePrototype,"__NPO__",0,
		/*configurable=*/false
	);

	builtInProp(Promise,"resolve",function Promise$resolve(msg) {
		var Constructor = this;

		// spec mandated checks
		// note: best "isPromise" check that's practical for now
		if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
			return msg;
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			resolve(msg);
		});
	});

	builtInProp(Promise,"reject",function Promise$reject(msg) {
		return new this(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			reject(msg);
		});
	});

	builtInProp(Promise,"all",function Promise$all(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}
		if (arr.length === 0) {
			return Constructor.resolve([]);
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			var len = arr.length, msgs = Array(len), count = 0;

			iteratePromises(Constructor,arr,function resolver(idx,msg) {
				msgs[idx] = msg;
				if (++count === len) {
					resolve(msgs);
				}
			},reject);
		});
	});

	builtInProp(Promise,"race",function Promise$race(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			iteratePromises(Constructor,arr,function resolver(idx,msg){
				resolve(msg);
			},reject);
		});
	});

	return Promise;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],169:[function(_dereq_,module,exports){
module.exports = function (obj) {
    if (!obj || typeof obj !== 'object') return obj;
    
    var copy;
    
    if (isArray(obj)) {
        var len = obj.length;
        copy = Array(len);
        for (var i = 0; i < len; i++) {
            copy[i] = obj[i];
        }
    }
    else {
        var keys = objectKeys(obj);
        copy = {};
        
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            copy[key] = obj[key];
        }
    }
    return copy;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
        if ({}.hasOwnProperty.call(obj, key)) keys.push(key);
    }
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return {}.toString.call(xs) === '[object Array]';
};

},{}],170:[function(_dereq_,module,exports){
/*!
 * Signature Pad v1.6.0
 * https://github.com/szimek/signature_pad
 *
 * Copyright 2017 Szymon Nowak
 * Released under the MIT license
 *
 * The main idea and some parts of the code (e.g. drawing variable width Bézier curve) are taken from:
 * http://corner.squareup.com/2012/07/smoother-signatures.html
 *
 * Implementation of interpolation using cubic Bézier curves is taken from:
 * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
 *
 * Algorithm for approximated length of a Bézier curve is taken from:
 * http://www.lemoda.net/maths/bezier-length/index.html
 *
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.SignaturePad = factory());
}(this, (function () { 'use strict';

function Point(x, y, time) {
  this.x = x;
  this.y = y;
  this.time = time || new Date().getTime();
}

Point.prototype.velocityFrom = function (start) {
  return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;
};

Point.prototype.distanceTo = function (start) {
  return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
};

function Bezier(startPoint, control1, control2, endPoint) {
  this.startPoint = startPoint;
  this.control1 = control1;
  this.control2 = control2;
  this.endPoint = endPoint;
}

// Returns approximated length.
Bezier.prototype.length = function () {
  var steps = 10;
  var length = 0;
  var px = void 0;
  var py = void 0;

  for (var i = 0; i <= steps; i += 1) {
    var t = i / steps;
    var cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
    var cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
    if (i > 0) {
      var xdiff = cx - px;
      var ydiff = cy - py;
      length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }
    px = cx;
    py = cy;
  }

  return length;
};

/* eslint-disable no-multi-spaces, space-in-parens */
Bezier.prototype._point = function (t, start, c1, c2, end) {
  return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
};

function SignaturePad(canvas, options) {
  var self = this;
  var opts = options || {};

  this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
  this.minWidth = opts.minWidth || 0.5;
  this.maxWidth = opts.maxWidth || 2.5;
  this.dotSize = opts.dotSize || function () {
    return (this.minWidth + this.maxWidth) / 2;
  };
  this.penColor = opts.penColor || 'black';
  this.backgroundColor = opts.backgroundColor || 'rgba(0,0,0,0)';
  this.onBegin = opts.onBegin;
  this.onEnd = opts.onEnd;

  this._canvas = canvas;
  this._ctx = canvas.getContext('2d');
  this.clear();

  // We need add these inline so they are available to unbind while still having
  // access to 'self' we could use _.bind but it's not worth adding a dependency.
  this._handleMouseDown = function (event) {
    if (event.which === 1) {
      self._mouseButtonDown = true;
      self._strokeBegin(event);
    }
  };

  this._handleMouseMove = function (event) {
    if (self._mouseButtonDown) {
      self._strokeUpdate(event);
    }
  };

  this._handleMouseUp = function (event) {
    if (event.which === 1 && self._mouseButtonDown) {
      self._mouseButtonDown = false;
      self._strokeEnd(event);
    }
  };

  this._handleTouchStart = function (event) {
    if (event.targetTouches.length === 1) {
      var touch = event.changedTouches[0];
      self._strokeBegin(touch);
    }
  };

  this._handleTouchMove = function (event) {
    // Prevent scrolling.
    event.preventDefault();

    var touch = event.targetTouches[0];
    self._strokeUpdate(touch);
  };

  this._handleTouchEnd = function (event) {
    var wasCanvasTouched = event.target === self._canvas;
    if (wasCanvasTouched) {
      event.preventDefault();
      self._strokeEnd(event);
    }
  };

  // Enable mouse and touch event handlers
  this.on();
}

// Public methods
SignaturePad.prototype.clear = function () {
  var ctx = this._ctx;
  var canvas = this._canvas;

  ctx.fillStyle = this.backgroundColor;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  this._data = [];
  this._reset();
  this._isEmpty = true;
};

SignaturePad.prototype.fromDataURL = function (dataUrl) {
  var _this = this;

  var image = new Image();
  var ratio = window.devicePixelRatio || 1;
  var width = this._canvas.width / ratio;
  var height = this._canvas.height / ratio;

  this._reset();
  image.src = dataUrl;
  image.onload = function () {
    _this._ctx.drawImage(image, 0, 0, width, height);
  };
  this._isEmpty = false;
};

SignaturePad.prototype.toDataURL = function (type) {
  var _canvas;

  switch (type) {
    case 'image/svg+xml':
      return this._toSVG();
    default:
      for (var _len = arguments.length, options = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        options[_key - 1] = arguments[_key];
      }

      return (_canvas = this._canvas).toDataURL.apply(_canvas, [type].concat(options));
  }
};

SignaturePad.prototype.on = function () {
  this._handleMouseEvents();
  this._handleTouchEvents();
};

SignaturePad.prototype.off = function () {
  this._canvas.removeEventListener('mousedown', this._handleMouseDown);
  this._canvas.removeEventListener('mousemove', this._handleMouseMove);
  document.removeEventListener('mouseup', this._handleMouseUp);

  this._canvas.removeEventListener('touchstart', this._handleTouchStart);
  this._canvas.removeEventListener('touchmove', this._handleTouchMove);
  this._canvas.removeEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype.isEmpty = function () {
  return this._isEmpty;
};

// Private methods
SignaturePad.prototype._strokeBegin = function (event) {
  this._data.push([]);
  this._reset();
  this._strokeUpdate(event);

  if (typeof this.onBegin === 'function') {
    this.onBegin(event);
  }
};

SignaturePad.prototype._strokeUpdate = function (event) {
  var x = event.clientX;
  var y = event.clientY;

  var point = this._createPoint(x, y);

  var _addPoint = this._addPoint(point),
      curve = _addPoint.curve,
      widths = _addPoint.widths;

  if (curve && widths) {
    this._drawCurve(curve, widths.start, widths.end);
  }

  this._data[this._data.length - 1].push({
    x: point.x,
    y: point.y,
    time: point.time
  });
};

SignaturePad.prototype._strokeEnd = function (event) {
  var canDrawCurve = this.points.length > 2;
  var point = this.points[0];

  if (!canDrawCurve && point) {
    this._drawDot(point);
  }

  if (typeof this.onEnd === 'function') {
    this.onEnd(event);
  }
};

SignaturePad.prototype._handleMouseEvents = function () {
  this._mouseButtonDown = false;

  this._canvas.addEventListener('mousedown', this._handleMouseDown);
  this._canvas.addEventListener('mousemove', this._handleMouseMove);
  document.addEventListener('mouseup', this._handleMouseUp);
};

SignaturePad.prototype._handleTouchEvents = function () {
  // Pass touch events to canvas element on mobile IE11 and Edge.
  this._canvas.style.msTouchAction = 'none';
  this._canvas.style.touchAction = 'none';

  this._canvas.addEventListener('touchstart', this._handleTouchStart);
  this._canvas.addEventListener('touchmove', this._handleTouchMove);
  this._canvas.addEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype._reset = function () {
  this.points = [];
  this._lastVelocity = 0;
  this._lastWidth = (this.minWidth + this.maxWidth) / 2;
  this._ctx.fillStyle = this.penColor;
};

SignaturePad.prototype._createPoint = function (x, y, time) {
  var rect = this._canvas.getBoundingClientRect();

  return new Point(x - rect.left, y - rect.top, time || new Date().getTime());
};

SignaturePad.prototype._addPoint = function (point) {
  var points = this.points;
  var tmp = void 0;

  points.push(point);

  if (points.length > 2) {
    // To reduce the initial lag make it work with 3 points
    // by copying the first point to the beginning.
    if (points.length === 3) points.unshift(points[0]);

    tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
    var c2 = tmp.c2;
    tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
    var c3 = tmp.c1;
    var curve = new Bezier(points[1], c2, c3, points[2]);
    var widths = this._calculateCurveWidths(curve);

    // Remove the first element from the list,
    // so that we always have no more than 4 points in points array.
    points.shift();

    return { curve: curve, widths: widths };
  }

  return {};
};

SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
  var dx1 = s1.x - s2.x;
  var dy1 = s1.y - s2.y;
  var dx2 = s2.x - s3.x;
  var dy2 = s2.y - s3.y;

  var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
  var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };

  var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

  var dxm = m1.x - m2.x;
  var dym = m1.y - m2.y;

  var k = l2 / (l1 + l2);
  var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };

  var tx = s2.x - cm.x;
  var ty = s2.y - cm.y;

  return {
    c1: new Point(m1.x + tx, m1.y + ty),
    c2: new Point(m2.x + tx, m2.y + ty)
  };
};

SignaturePad.prototype._calculateCurveWidths = function (curve) {
  var startPoint = curve.startPoint;
  var endPoint = curve.endPoint;
  var widths = { start: null, end: null };

  var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;

  var newWidth = this._strokeWidth(velocity);

  widths.start = this._lastWidth;
  widths.end = newWidth;

  this._lastVelocity = velocity;
  this._lastWidth = newWidth;

  return widths;
};

SignaturePad.prototype._strokeWidth = function (velocity) {
  return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
};

SignaturePad.prototype._drawPoint = function (x, y, size) {
  var ctx = this._ctx;

  ctx.moveTo(x, y);
  ctx.arc(x, y, size, 0, 2 * Math.PI, false);
  this._isEmpty = false;
};

SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
  var ctx = this._ctx;
  var widthDelta = endWidth - startWidth;
  var drawSteps = Math.floor(curve.length());

  ctx.beginPath();

  for (var i = 0; i < drawSteps; i += 1) {
    // Calculate the Bezier (x, y) coordinate for this step.
    var t = i / drawSteps;
    var tt = t * t;
    var ttt = tt * t;
    var u = 1 - t;
    var uu = u * u;
    var uuu = uu * u;

    var x = uuu * curve.startPoint.x;
    x += 3 * uu * t * curve.control1.x;
    x += 3 * u * tt * curve.control2.x;
    x += ttt * curve.endPoint.x;

    var y = uuu * curve.startPoint.y;
    y += 3 * uu * t * curve.control1.y;
    y += 3 * u * tt * curve.control2.y;
    y += ttt * curve.endPoint.y;

    var width = startWidth + ttt * widthDelta;
    this._drawPoint(x, y, width);
  }

  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._drawDot = function (point) {
  var ctx = this._ctx;
  var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;

  ctx.beginPath();
  this._drawPoint(point.x, point.y, width);
  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {
  for (var i = 0; i < pointGroups.length; i += 1) {
    var group = pointGroups[i];

    if (group.length > 1) {
      for (var j = 0; j < group.length; j += 1) {
        var rawPoint = group[j];
        var point = new Point(rawPoint.x, rawPoint.y, rawPoint.time);

        if (j === 0) {
          // First point in a group. Nothing to draw yet.
          this._reset();
          this._addPoint(point);
        } else if (j !== group.length - 1) {
          // Middle point in a group.
          var _addPoint2 = this._addPoint(point),
              curve = _addPoint2.curve,
              widths = _addPoint2.widths;

          if (curve && widths) {
            drawCurve(curve, widths);
          }
        } else {
          // Last point in a group. Do nothing.
        }
      }
    } else {
      this._reset();
      var _rawPoint = group[0];
      drawDot(_rawPoint);
    }
  }
};

SignaturePad.prototype._toSVG = function () {
  var _this2 = this;

  var pointGroups = this._data;
  var canvas = this._canvas;
  var ratio = Math.max(window.devicePixelRatio || 1, 1);
  var minX = 0;
  var minY = 0;
  var maxX = canvas.width / ratio;
  var maxY = canvas.height / ratio;
  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

  svg.setAttributeNS(null, 'width', canvas.width);
  svg.setAttributeNS(null, 'height', canvas.height);

  this._fromData(pointGroups, function (curve, widths) {
    var path = document.createElement('path');

    // Need to check curve for NaN values, these pop up when drawing
    // lines on the canvas that are not continuous. E.g. Sharp corners
    // or stopping mid-stroke and than continuing without lifting mouse.
    if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
      var attr = 'M ' + curve.startPoint.x.toFixed(3) + ',' + curve.startPoint.y.toFixed(3) + ' ' + ('C ' + curve.control1.x.toFixed(3) + ',' + curve.control1.y.toFixed(3) + ' ') + (curve.control2.x.toFixed(3) + ',' + curve.control2.y.toFixed(3) + ' ') + (curve.endPoint.x.toFixed(3) + ',' + curve.endPoint.y.toFixed(3));

      path.setAttribute('d', attr);
      path.setAttribute('stroke-width', (widths.end * 2.25).toFixed(3));
      path.setAttribute('stroke', _this2.penColor);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-linecap', 'round');

      svg.appendChild(path);
    }
  }, function (rawPoint) {
    var circle = document.createElement('circle');
    var dotSize = typeof _this2.dotSize === 'function' ? _this2.dotSize() : _this2.dotSize;
    circle.setAttribute('r', dotSize);
    circle.setAttribute('cx', rawPoint.x);
    circle.setAttribute('cy', rawPoint.y);
    circle.setAttribute('fill', _this2.penColor);

    svg.appendChild(circle);
  });

  var prefix = 'data:image/svg+xml;base64,';
  var header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"' + (' viewBox="' + minX + ' ' + minY + ' ' + maxX + ' ' + maxY + '"') + (' width="' + maxX + '"') + (' height="' + maxY + '"') + '>';
  var body = svg.innerHTML;

  // IE hack for missing innerHTML property on SVGElement
  if (body === undefined) {
    var dummy = document.createElement('dummy');
    var nodes = svg.childNodes;
    dummy.innerHTML = '';

    for (var i = 0; i < nodes.length; i += 1) {
      dummy.appendChild(nodes[i].cloneNode(true));
    }

    body = dummy.innerHTML;
  }

  var footer = '</svg>';
  var data = header + body + footer;

  return prefix + btoa(data);
};

SignaturePad.prototype.fromData = function (pointGroups) {
  var _this3 = this;

  this.clear();

  this._fromData(pointGroups, function (curve, widths) {
    return _this3._drawCurve(curve, widths.start, widths.end);
  }, function (rawPoint) {
    return _this3._drawDot(rawPoint);
  });
};

SignaturePad.prototype.toData = function () {
  return this._data;
};

return SignaturePad;

})));

},{}],171:[function(_dereq_,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],172:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  /*jshint camelcase: false */
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('address', {
        title: 'Address',
        template: function($scope) {
          return $scope.component.multiple ? 'formio/components/address-multiple.html' : 'formio/components/address.html';
        },
        controller: ['$scope', '$http', function($scope, $http) {
          if ($scope.builder) return;
          $scope.address = {};
          $scope.addresses = [];
          $scope.refreshAddress = function(address) {
            var params = {
              address: address,
              sensor: false
            };
            if (!address) {
              return;
            }
            if ($scope.component.map && $scope.component.map.region) {
              params.region = $scope.component.map.region;
            }
            if ($scope.component.map && $scope.component.map.key) {
              params.key = $scope.component.map.key;
            }
            return $http.get(
              'https://maps.googleapis.com/maps/api/geocode/json',
              {
                disableJWT: true,
                params: params,
                headers: {
                  Authorization: undefined,
                  Pragma: undefined,
                  'Cache-Control': undefined
                }
              }
            ).then(function(response) {
              $scope.addresses = response.data.results;
            });
          };
        }],
        tableView: function(data) {
          return data ? data.formatted_address : '';
        },
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'addressField',
          placeholder: '',
          multiple: false,
          protected: false,
          clearOnHide: true,
          unique: false,
          persistent: true,
          hidden: false,
          map: {
            region: '',
            key: ''
          },
          validate: {
            required: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/address.html',
        "<label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\n<span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\n<ui-select ng-model=\"data[component.key]\" safe-multiple-to-single ng-disabled=\"readOnly\" ng-required=\"isRequired(component)\" id=\"{{ componentId }}\" name=\"{{ componentId }}\" tabindex=\"{{ component.tabindex || 0 }}\" theme=\"bootstrap\">\n  <ui-select-match class=\"ui-select-match\" placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\">{{$item.formatted_address || $select.selected.formatted_address}}</ui-select-match>\n  <ui-select-choices class=\"ui-select-choices\" repeat=\"address in addresses\" refresh=\"refreshAddress($select.search)\" refresh-delay=\"500\">\n    <div ng-bind-html=\"address.formatted_address | highlight: $select.search\"></div>\n  </ui-select-choices>\n</ui-select>\n<formio-errors ng-if=\"::!builder\"></formio-errors>\n"
      );

      // Change the ui-select to ui-select multiple.
      $templateCache.put('formio/components/address-multiple.html',
        $templateCache.get('formio/components/address.html').replace('<ui-select', '<ui-select multiple')
      );
    }
  ]);
};

},{}],173:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('button', {
        title: 'Button',
        template: 'formio/components/button.html',
        settings: {
          input: true,
          label: 'Submit',
          tableView: false,
          key: 'submit',
          size: 'md',
          leftIcon: '',
          rightIcon: '',
          block: false,
          action: 'submit',
          disableOnInvalid: false,
          theme: 'primary'
        },
        controller: ['$scope', function($scope) {
          if ($scope.builder) return;
          var settings = $scope.component;
          $scope.getButtonType = function() {
            switch (settings.action) {
              case 'submit':
                return 'submit';
              case 'reset':
                return 'reset';
              case 'event':
              case 'oauth':
              default:
                return 'button';
            }
          };

          var onClick = function() {
            switch (settings.action) {
              case 'submit':
                return;
              case 'event':
                $scope.$emit($scope.component.event, $scope.data);
                break;
              case 'reset':
                $scope.resetForm();
                break;
              case 'oauth':
                if (!settings.oauth) {
                  $scope.showAlerts({
                    type: 'danger',
                    message: 'You must assign this button to an OAuth action before it will work.'
                  });
                  break;
                }
                if (settings.oauth.error) {
                  $scope.showAlerts({
                    type: 'danger',
                    message: settings.oauth.error
                  });
                  break;
                }
                $scope.openOAuth(settings.oauth);
                break;
            }
          };

          $scope.$on('buttonClick', function(event, component, componentId) {
            // Ensure the componentId's match (even though they always should).
            if (componentId !== $scope.componentId) {
              return;
            }
            onClick();
          });

          $scope.openOAuth = function(settings) {
            /*eslint-disable camelcase */
            var params = {
              response_type: 'code',
              client_id: settings.clientId,
              redirect_uri: window.location.origin || window.location.protocol + '//' + window.location.host,
              state: settings.state,
              scope: settings.scope
            };
            /*eslint-enable camelcase */

            // Make display optional.
            if (settings.display) {
              params.display = settings.display;
            }
            params = Object.keys(params).map(function(key) {
              return key + '=' + encodeURIComponent(params[key]);
            }).join('&');

            var url = settings.authURI + '?' + params;

            // TODO: make window options from oauth settings, have better defaults
            var popup = window.open(url, settings.provider, 'width=1020,height=618');
            var interval = setInterval(function() {
              try {
                var popupHost = popup.location.host;
                var currentHost = window.location.host;
                if (popup && !popup.closed && popupHost === currentHost && popup.location.search) {
                  popup.close();
                  var params = popup.location.search.substr(1).split('&').reduce(function(params, param) {
                    var split = param.split('=');
                    params[split[0]] = split[1];
                    return params;
                  }, {});
                  if (params.error) {
                    $scope.showAlerts({
                      type: 'danger',
                      message: params.error_description || params.error
                    });
                    return;
                  }
                  // TODO: check for error response here
                  if (settings.state !== params.state) {
                    $scope.showAlerts({
                      type: 'danger',
                      message: 'OAuth state does not match. Please try logging in again.'
                    });
                    return;
                  }
                  var submission = {data: {}, oauth: {}};
                  submission.oauth[settings.provider] = params;
                  submission.oauth[settings.provider].redirectURI = window.location.origin || window.location.protocol + '//' + window.location.host;
                  $scope.formioForm.submitting = true;
                  $scope.formio.saveSubmission(submission)
                  .then(function(submission) {
                    // Trigger the form submission.
                    $scope.$emit('formSubmission', submission);
                  })
                  .catch(function(error) {
                    $scope.showAlerts({
                      type: 'danger',
                      message: error.message || error
                    });
                  })
                  .finally(function() {
                    $scope.formioForm.submitting = false;
                  });
                }
              }
              catch (error) {
                if (error.name !== 'SecurityError') {
                  $scope.showAlerts({
                    type: 'danger',
                    message: error.message || error
                  });
                }
              }
              if (!popup || popup.closed || popup.closed === undefined) {
                clearInterval(interval);
              }
            }, 100);
          };
        }],
        viewTemplate: 'formio/componentsView/button.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/button.html',
        "<button ng-attr-type=\"{{ getButtonType() }}\"\n  id=\"{{ componentId }}\"\n  name=\"{{ componentId }}\"\n  ng-class=\"{'btn-block': component.block}\"\n  class=\"btn btn-{{ component.theme }} btn-{{ component.size }}\"\n  ng-disabled=\"readOnly || formioForm.submitting || (component.disableOnInvalid && formioForm.$invalid)\"\n  tabindex=\"{{ component.tabindex || 0 }}\"\n  ng-click=\"$emit('buttonClick', component, componentId)\">\n  <span ng-if=\"component.leftIcon\" class=\"{{ component.leftIcon }}\" aria-hidden=\"true\"></span>\n  <span ng-if=\"component.leftIcon && component.label\">&nbsp;</span>{{ component.label | formioTranslate:null:builder }}<span ng-if=\"component.rightIcon && component.label\">&nbsp;</span>\n  <span ng-if=\"component.rightIcon\" class=\"{{ component.rightIcon }}\" aria-hidden=\"true\"></span>\n   <i ng-if=\"component.action == 'submit' && formioForm.submitting\" class=\"glyphicon glyphicon-refresh glyphicon-spin\"></i>\n</button>\n"
      );

      $templateCache.put('formio/componentsView/button.html',
        ""
      );
    }
  ]);
};

},{}],174:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('checkbox', {
        title: 'Check Box',
        template: 'formio/components/checkbox.html',
        tableView: function(data) {
          return data ? 'Yes' : 'No';
        },
        controller: ['$scope', '$timeout', function($scope, $timeout) {
          if ($scope.builder) return;
          var boolean = {
            true: true,
            false: false
          };
          var defaultValue = $scope.component.hasOwnProperty('defaultValue')
            ? boolean[$scope.component.defaultValue] || false
            : false;

          // FOR-440 - Only use the default value if the data isn't defined.
          // On the first load, attempt to set the default value.
          $scope.data[$scope.component.key] = $scope.data.hasOwnProperty($scope.component.key) && boolean.hasOwnProperty($scope.data[$scope.component.key])
            ? boolean[$scope.data[$scope.component.key]]
            : defaultValue;

          // FA-850 - Ensure the checked value is always a boolean object when loaded, then unbind the watch.
          if ($scope.component.inputType === 'checkbox') {
            $scope.$watch('data.' + $scope.component.key, function() {
              if (!$scope.data || !$scope.component.key) return;

              // If the component is required, and its current value is false, delete the entry.
              if (
                $scope.component.validate
                && $scope.component.validate.required
                && (boolean[$scope.data[$scope.component.key]] || false) === false
              ) {
                $timeout(function() {
                  delete $scope.data[$scope.component.key];
                });
              }
            });
          }
        }],
        settings: {
          input: true,
          inputType: 'checkbox',
          tableView: true,
          // This hides the default label layout so we can use a special inline label
          hideLabel: true,
          label: '',
          datagridLabel: true,
          key: 'checkboxField',
          defaultValue: false,
          protected: false,
          persistent: true,
          hidden: false,
          name: '',
          value: '',
          clearOnHide: true,
          validate: {
            required: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/checkbox.html',
        "<div class=\"checkbox\">\n  <label for=\"{{ componentId }}\" ng-class=\"{'field-required': isRequired(component)}\">\n    <input\n      ng-if=\"component.name\"\n      type=\"{{ component.inputType }}\"\n      id=\"{{ componentId }}\"\n      name=\"{{ component.name }}\"\n      value=\"{{ component.value }}\"\n      tabindex=\"{{ component.tabindex || 0 }}\"\n      ng-disabled=\"readOnly\"\n      ng-model=\"data[component.name]\"\n      ng-required=\"component.validate.required\"\n    >\n    <input\n      ng-if=\"!component.name\"\n      type=\"{{ component.inputType }}\"\n      id=\"{{ componentId }}\"\n      tabindex=\"{{ component.tabindex || 0 }}\"\n      ng-disabled=\"readOnly\"\n      ng-model=\"data[component.key]\"\n      ng-required=\"isRequired(component)\"\n      custom-validator=\"component.validate.custom\"\n    >\n    <span ng-if=\"!(component.hideLabel && component.datagridLabel === false)\">{{ component.label | formioTranslate:null:builder }}</span>\n  </label>\n</div>\n<div ng-if=\"!!component.description\" class=\"help-block\">\n  <span>{{ component.description }}</span>\n</div>\n"
      );
    }
  ]);
};

},{}],175:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('columns', {
        title: 'Columns',
        template: 'formio/components/columns.html',
        group: 'layout',
        settings: {
          input: false,
          key: 'columns',
          columns: [{components: []}, {components: []}]
        },
        viewTemplate: 'formio/componentsView/columns.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/columns.html',
        "<div class=\"row\">\n  <div class=\"col-sm-6\" ng-repeat=\"column in component.columns track by $index\">\n    <formio-component\n      ng-repeat=\"_component in column.components track by $index\"\n      component=\"_component\"\n      data=\"data\"\n      formio=\"formio\"\n      submission=\"submission\"\n      hide-components=\"hideComponents\"\n      ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n      formio-form=\"formioForm\"\n      read-only=\"isDisabled(_component, data)\"\n      grid-row=\"gridRow\"\n      grid-col=\"gridCol\"\n      builder=\"builder\"\n    ></formio-component>\n  </div>\n</div>\n"
      );

      $templateCache.put('formio/componentsView/columns.html',
        "<div class=\"row\">\n  <div class=\"col-sm-6\" ng-repeat=\"column in component.columns track by $index\">\n    <formio-component-view\n      ng-repeat=\"_component in column.components track by $index\"\n      component=\"_component\"\n      data=\"data\"\n      form=\"form\"\n      submission=\"submission\"\n      ignore=\"ignore\"\n      ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n      builder=\"builder\"\n    ></formio-component-view>\n  </div>\n</div>\n"
      );
    }
  ]);
};

},{}],176:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.provider('formioComponents', function() {
    var components = {};
    var groups = {
      __component: {
        title: 'Basic Components'
      },
      advanced: {
        title: 'Special Components'
      },
      layout: {
        title: 'Layout Components'
      }
    };
    return {
      addGroup: function(name, group) {
        groups[name] = group;
      },
      register: function(type, component, group) {
        if (!components[type]) {
          components[type] = component;
        }
        else {
          angular.extend(components[type], component);
        }

        // Set the type for this component.
        if (!components[type].group) {
          components[type].group = group || '__component';
        }
        components[type].settings.type = type;
      },
      $get: function() {
        return {
          components: components,
          groups: groups
        };
      }
    };
  });

  app.directive('safeMultipleToSingle', [function() {
    return {
      require: 'ngModel',
      restrict: 'A',
      link: function($scope, el, attrs, ngModel) {
        ngModel.$formatters.push(function(modelValue) {
          if (!$scope.component.multiple && Array.isArray(modelValue)) {
            return modelValue[0] || '';
          }

          return modelValue;
        });
      }
    };
  }]);
};

},{}],177:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('container', {
        title: 'Container',
        template: 'formio/components/container.html',
        viewTemplate: 'formio/componentsView/container.html',
        group: 'advanced',
        icon: 'fa fa-folder-open',
        tableView: function(data, component, $interpolate, componentInfo) {
          var view = '<table class="table table-striped table-bordered"><thead><tr>';
          angular.forEach(component.components, function(component) {
            view += '<th>' + component.label + '</th>';
          });
          view += '</tr></thead>';
          view += '<tbody>';
          view += '<tr>';
          angular.forEach(component.components, function(component) {
            var info = componentInfo.components.hasOwnProperty(component.type) ? componentInfo.components[component.type] : {};
            if (info.tableView) {
              view += '<td>' +
                info.tableView(
                  data && component.key && data.hasOwnProperty(component.key) ? data[component.key] : '',
                  component,
                  $interpolate,
                  componentInfo
                ) + '</td>';
              return;
            }

            view += '<td>';
            if (component.prefix) {
              view += component.prefix;
            }
            view += data && component.key && data.hasOwnProperty(component.key) ? data[component.key] : '';
            if (component.suffix) {
              view += ' ' + component.suffix;
            }
            view += '</td>';
          });
          view += '</tr>';
          view += '</tbody></table>';
          return view;
        },
        settings: {
          input: true,
          tree: true,
          components: [],
          tableView: true,
          label: '',
          key: 'container',
          protected: false,
          persistent: true,
          clearOnHide: true
        }
      });
    }
  ]);
  app.controller('formioContainerComponent', [
    '$scope',
    function($scope) {
      $scope.data[$scope.component.key] = $scope.data[$scope.component.key] || {};
      $scope.parentKey = $scope.component.key;
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/container.html', FormioUtils.fieldWrap(
        "<div ng-controller=\"formioContainerComponent\" class=\"formio-container-component\">\n  <formio-component\n    ng-repeat=\"_component in component.components track by $index\"\n    component=\"_component\"\n    data=\"data[parentKey]\"\n    formio=\"formio\"\n    submission=\"submission\"\n    hide-components=\"hideComponents\"\n    ng-if=\"builder ? '::true' : isVisible(_component, data[parentKey])\"\n    formio-form=\"formioForm\"\n    read-only=\"isDisabled(_component, data[parentKey])\"\n    grid-row=\"gridRow\"\n    grid-col=\"gridCol\"\n    builder=\"builder\"\n  ></formio-component>\n</div>\n"
      ));
    }
  ]);
};

},{}],178:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('content', {
        title: 'Content',
        template: 'formio/components/content.html',
        settings: {
          key: 'content',
          input: false,
          html: ''
        },
        viewTemplate: 'formio/components/content.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/content.html',
        "<div ng-bind-html=\"component.html | safehtml | formioTranslate:component.key:builder\" id=\"{{ component.key }}\"></div>\n"
      );
    }
  ]);
};

},{}],179:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.directive('currencyInput', function() {
    // May be better way than adding to prototype.
    var splice = function(string, idx, rem, s) {
      return (string.slice(0, idx) + s + string.slice(idx + Math.abs(rem)));
    };
    return {
      restrict: 'A',
      link: function(scope, element) {
        if (scope.builder) return;
        element.bind('keyup', function() {
          var data = scope.data[scope.component.key];

          //clearing left side zeros
          while (data.charAt(0) === '0') {
            data = data.substr(1);
          }

          data = data.replace(/[^\d.\',']/g, '');

          var point = data.indexOf('.');
          if (point >= 0) {
            data = data.slice(0, point + 3);
          }

          var decimalSplit = data.split('.');
          var intPart = decimalSplit[0];
          var decPart = decimalSplit[1];

          intPart = intPart.replace(/[^\d]/g, '');
          if (intPart.length > 3) {
            var intDiv = Math.floor(intPart.length / 3);
            while (intDiv > 0) {
              var lastComma = intPart.indexOf(',');
              if (lastComma < 0) {
                lastComma = intPart.length;
              }

              if (lastComma - 3 > 0) {
                intPart = splice(intPart, lastComma - 3, 0, ',');
              }
              intDiv--;
            }
          }

          if (decPart === undefined) {
            decPart = '';
          }
          else {
            decPart = '.' + decPart;
          }
          var res = intPart + decPart;
          scope.$apply(function() {
            scope.data[scope.component.key] = res;
          });
        });
      }
    };
  });
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('currency', {
        title: 'Currency',
        template: 'formio/components/currency.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          inputType: 'text',
          inputMask: '',
          label: '',
          key: 'currencyField',
          placeholder: '',
          prefix: '',
          suffix: '',
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            multiple: '',
            custom: ''
          },
          conditional: {
            show: null,
            when: null,
            eq: ''
          }
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/currency.html', FormioUtils.fieldWrap(
        "<input\n  type=\"{{ component.inputType }}\"\n  class=\"form-control\"\n  id=\"{{ componentId }}\"\n  name=\"{{ componentId }}\"\n  tabindex=\"{{ component.tabindex || 0 }}\"\n  ng-model=\"data[component.key]\"\n  ng-required=\"isRequired(component)\"\n  ng-disabled=\"readOnly\"\n  safe-multiple-to-single\n  ng-attr-placeholder=\"{{ component.placeholder }}\"\n  custom-validator=\"component.validate.custom\"\n  currency-input\n  ui-mask-placeholder=\"\"\n  ui-options=\"uiMaskOptions\"\n>\n"
      ));
    }
  ]);
};

},{}],180:[function(_dereq_,module,exports){
"use strict";

var GridUtils = _dereq_('../factories/GridUtils')();

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('custom', {
        title: 'Custom',
        template: 'formio/components/custom.html',
        group: 'advanced',
        settings: {},
        tableView: GridUtils.generic
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/custom.html',
        "<div class=\"panel panel-default\">\n  <div class=\"panel-body text-muted text-center\">\n    Custom Component ({{ component.type }})\n  </div>\n</div>\n"
      );
    }
  ]);
};

},{"../factories/GridUtils":218}],181:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('datagrid', {
        title: 'Data Grid',
        template: 'formio/components/datagrid.html',
        group: 'advanced',
        tableView: function(data, component, $interpolate, componentInfo) {
          var view = '<table class="table table-striped table-bordered"><thead><tr>';
          angular.forEach(component.components, function(component) {
            view += '<th>' + component.label + '</th>';
          });
          view += '</tr></thead>';
          view += '<tbody>';
          angular.forEach(data, function(row) {
            view += '<tr>';
            angular.forEach(component.components, function(component) {
              var info = componentInfo.components.hasOwnProperty(component.type) ? componentInfo.components[component.type] : {};
              if (info.tableView) {
                view += '<td>' + info.tableView(row[component.key] || '', component, $interpolate, componentInfo) + '</td>';
              }
              else {
                view += '<td>';
                if (component.prefix) {
                  view += component.prefix;
                }
                view += row[component.key] || '';
                if (component.suffix) {
                  view += ' ' + component.suffix;
                }
                view += '</td>';
              }
            });
            view += '</tr>';
          });
          view += '</tbody></table>';
          return view;
        },
        settings: {
          input: true,
          tree: true,
          components: [],
          tableView: true,
          label: '',
          key: 'datagrid',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true
        }
      });
    }
  ]);
  app.controller('formioDataGrid', [
    '$scope',
    'FormioUtils',
    function($scope, FormioUtils) {
      if ($scope.builder) return;
      // Ensure each data grid has a valid data model.
      $scope.data = $scope.data || {};
      $scope.data[$scope.component.key] = $scope.data[$scope.component.key] || [{}];

      // Determine if any component is visible.
      $scope.anyVisible = function(component) {
        var data = $scope.data[$scope.component.key];
        var visible = false;
        angular.forEach(data, function(rowData) {
          visible = (visible || FormioUtils.isVisible(component, rowData, $scope.data, $scope.hideComponents));
        });
        return visible;
      };

      // Pull out the rows and cols for easy iteration.
      $scope.rows = $scope.data[$scope.component.key];
      // If less than minLength, add that many rows.
      if ($scope.component.validate && $scope.component.validate.hasOwnProperty('minLength') && $scope.rows.length < $scope.component.validate.minLength) {
        var toAdd = $scope.component.validate.minLength - $scope.rows.length;
        for (var i = 0; i < toAdd; i++) {
          $scope.rows.push({});
        }
      }
      // If more than maxLength, remove extra rows.
      if ($scope.component.validate && $scope.component.validate.hasOwnProperty('maxLength') && $scope.rows.length < $scope.component.validate.maxLength) {
        $scope.rows = $scope.rows.slice(0, $scope.component.validate.maxLength);
      }
      $scope.cols = $scope.component.components;
      $scope.localKeys = $scope.component.components.map(function(component) {
        return component.key;
      });

      // Add a row the to grid.
      $scope.addRow = function() {
        if (!Array.isArray($scope.rows)) {
          $scope.rows = [];
        }
        $scope.rows.push({});
      };

      // Remove a row from the grid.
      $scope.removeRow = function(index) {
        $scope.rows.splice(index, 1);
      };
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/datagrid.html', FormioUtils.fieldWrap(
        "<div class=\"formio-data-grid\" ng-controller=\"formioDataGrid\">\n  <table ng-class=\"{'table-striped': component.striped, 'table-bordered': component.bordered, 'table-hover': component.hover, 'table-condensed': component.condensed}\" class=\"table datagrid-table\">\n    <tr>\n      <th\n        ng-repeat=\"col in cols track by $index\"\n        ng-class=\"{'field-required': col.validate.required}\"\n        ng-if=\"builder ? '::true' : anyVisible(col)\"\n      >{{ col.label | formioTranslate:null:builder }}</th>\n    </tr>\n    <tr ng-repeat=\"row in rows track by $index\" ng-init=\"rowIndex = $index\">\n      <td ng-repeat=\"col in cols track by $index\" ng-init=\"col.hideLabel = true; colIndex = $index\" class=\"formio-data-grid-row\" ng-if=\"builder ? '::true' : anyVisible(col)\">\n        <formio-component\n          component=\"col\"\n          data=\"rows[rowIndex]\"\n          formio-form=\"formioForm\"\n          formio=\"formio\"\n          submission=\"submission\"\n          hide-components=\"hideComponents\"\n          ng-if=\"builder ? '::true' : isVisible(col, row)\"\n          read-only=\"isDisabled(col, row)\"\n          grid-row=\"rowIndex\"\n          grid-col=\"colIndex\"\n          builder=\"builder\"\n        ></formio-component>\n      </td>\n      <td ng-if=\"!component.hasOwnProperty('validate') || !component.validate.hasOwnProperty('minLength') || rows.length > component.validate.minLength\">\n        <a ng-click=\"removeRow(rowIndex)\" class=\"btn btn-default\">\n          <span class=\"glyphicon glyphicon-remove-circle\"></span>\n        </a>\n      </td>\n    </tr>\n  </table>\n  <div class=\"datagrid-add\" ng-if=\"!component.hasOwnProperty('validate') || !component.validate.hasOwnProperty('maxLength') || rows.length < component.validate.maxLength\">\n    <a ng-click=\"addRow()\" class=\"btn btn-primary\">\n      <span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"></span> {{ component.addAnother || \"Add Another\" | formioTranslate:null:builder }}\n    </a>\n  </div>\n</div>\n"
      ));
    }
  ]);
};

},{}],182:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('datetime', {
        title: 'Date / Time',
        template: 'formio/components/datetime.html',
        tableView: function(data, component, $interpolate) {
          return $interpolate('<span>{{ "' + data + '" | date: "' + component.format + '" }}</span>')();
        },
        group: 'advanced',
        controller: ['$scope', '$timeout', function($scope, $timeout) {
          // Close calendar pop up when tabbing off button
          $scope.onKeyDown = function(event) {
            return event.keyCode === 9 ? false : $scope.calendarOpen;
          };

          var dateValue = function() {
            // If the date is set, then return the true date value.
            if ($scope.data[$scope.component.key]) {
              return ($scope.data[$scope.component.key] instanceof Date) ? $scope.data[$scope.component.key] : new Date($scope.data[$scope.component.key]);
            }

            // See if a default date is set.
            if ($scope.component.defaultDate) {
              var defaultDate = new Date($scope.component.defaultDate);
              if (!defaultDate || isNaN(defaultDate.getDate())) {
                try {
                  defaultDate = new Date(eval($scope.component.defaultDate));
                }
                catch (e) {
                  defaultDate = '';
                }
              }

              if (defaultDate && !isNaN(defaultDate.getDate())) {
                return defaultDate;
              }
            }

            // Default to empty.
            return '';
          };

          // Ensure the date value is always a date object when loaded, then unbind the watch.
          $scope.$watch('data.' + $scope.component.key, function() {
            var newValue = dateValue();
            if (newValue) {
              $scope.data[$scope.component.key] = newValue;
            }
          });

          // Watch for changes to the meridian settings to synchronize the submissionGrid and component view.
          $scope.$watch('component.timePicker.showMeridian', function(update) {
            // Remove any meridian reference, because were not in 12 hr.
            if (!$scope.component.enableTime || !update) {
              $scope.component.format = $scope.component.format.replace(/ a/, '');
              return;
            }

            // If we're missing the meridian string and were in 12 hr, add it.
            if (update && $scope.component.format.indexOf(' a') === -1) {
              $scope.component.format += ' a';
            }
          });

          if (!$scope.component.datePicker.maxDate) {
            delete $scope.component.datePicker.maxDate;
          }
          else {
            var maxDate = new Date($scope.component.datePicker.maxDate);
            $scope.component.datePicker.maxDate = new Date(
              maxDate.getUTCFullYear(),
              maxDate.getUTCMonth(),
              maxDate.getUTCDate(),
              23,
              59,
              59,
              999
            );
          }

          if (!$scope.component.datePicker.minDate) {
            delete $scope.component.datePicker.minDate;
          }
          else {
            var minDate = new Date($scope.component.datePicker.minDate);
            $scope.component.datePicker.minDate = new Date(
              minDate.getUTCFullYear(),
              minDate.getUTCMonth(),
              minDate.getUTCDate(),
              0,
              0,
              0,
              0
            );
          }

          $scope.autoOpen = true;
          $scope.onClosed = function() {
            $scope.autoOpen = false;
            $timeout(function() {
              $scope.autoOpen = true;
            }, 250);
          };
        }],
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'datetimeField',
          placeholder: '',
          format: 'yyyy-MM-dd HH:mm a',
          enableDate: true,
          enableTime: true,
          defaultDate: '',
          datepickerMode: 'day',
          datePicker: {
            showWeeks: true,
            startingDay: 0,
            initDate: '',
            minMode: 'day',
            maxMode: 'year',
            yearRows: 4,
            yearColumns: 5,
            minDate: null,
            maxDate: null
          },
          timePicker: {
            hourStep: 1,
            minuteStep: 1,
            showMeridian: true,
            readonlyInput: false,
            mousewheel: true,
            arrowkeys: true
          },
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            custom: ''
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/datetime.html', FormioUtils.fieldWrap(
        "<div class=\"input-group\">\n  <input\n    type=\"text\"\n    class=\"form-control\"\n    name=\"{{ componentId }}\"\n    id=\"{{ componentId }}\"\n    ng-focus=\"calendarOpen = autoOpen\"\n    ng-click=\"calendarOpen = true\"\n    ng-init=\"calendarOpen = false\"\n    ng-disabled=\"readOnly\"\n    ng-required=\"isRequired(component)\"\n    is-open=\"calendarOpen\"\n    datetime-picker=\"{{ component.format }}\"\n    datepicker-mode=\"component.datepickerMode\"\n    when-closed=\"onClosed()\"\n    custom-validator=\"component.validate.custom\"\n    enable-date=\"component.enableDate\"\n    enable-time=\"component.enableTime\"\n    ng-model=\"data[component.key]\"\n    tabindex=\"{{ component.tabindex || 0 }}\"\n    ng-attr-placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\"\n    datepicker-options=\"component.datePicker\"\n    timepicker-options=\"component.timePicker\"\n  />\n  <span class=\"input-group-btn\">\n    <button type=\"button\" ng-disabled=\"readOnly\" class=\"btn btn-default\" ng-click=\"calendarOpen = true\" ng-keydown=\"calendarOpen = onKeyDown($event)\">\n      <i ng-if=\"component.enableDate\" class=\"glyphicon glyphicon-calendar\"></i>\n      <i ng-if=\"!component.enableDate\" class=\"glyphicon glyphicon-time\"></i>\n    </button>\n  </span>\n</div>\n"
      ));
    }
  ]);
};

},{}],183:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.directive('dayPart', function() {
    return {
      restrict: 'A',
      replace: true,
      require: 'ngModel',
      link: function(scope, elem, attrs, ngModel) {
        if (scope.builder) return;
        var limitLength = attrs.characters || 2;
        scope.$watch(attrs.ngModel, function() {
          if (!ngModel.$viewValue) {
            return;
          }
          var render = false;
          if (ngModel.$viewValue.length > limitLength) {
            ngModel.$setViewValue(ngModel.$viewValue.substring(0, limitLength));
            render = true;
          }
          if (isNaN(ngModel.$viewValue)) {
            ngModel.$setViewValue(ngModel.$viewValue.replace(/\D/g,''));
            render = true;
          }
          if (
            parseInt(ngModel.$viewValue) < parseInt(attrs.min) ||
            parseInt(ngModel.$viewValue) > parseInt(attrs.max)
          ) {
            ngModel.$setViewValue(ngModel.$viewValue.substring(0, limitLength - 1));
            render = true;
          }
          if (render) {
            ngModel.$render();
          }
        });
      }
    };
  });
  app.directive('dayInput', function() {
    return {
      restrict: 'E',
      replace: true,
      require: 'ngModel',
      scope: {
        component: '=',
        componentId: '=',
        readOnly: '=',
        ngModel: '=',
        gridRow: '=',
        gridCol: '=',
        builder: '=?'
      },
      templateUrl: 'formio/components/day-input.html',
      controller: ['$scope', function($scope) {
        if ($scope.builder) return;
        $scope.months = [
          {value: '', label: $scope.component.fields.month.placeholder},
          {value: '01', label: 'January'},
          {value: '02', label: 'February'},
          {value: '03', label: 'March'},
          {value: '04', label: 'April'},
          {value: '05', label: 'May'},
          {value: '06', label: 'June'},
          {value: '07', label: 'July'},
          {value: '08', label: 'August'},
          {value: '09', label: 'September'},
          {value: '10', label: 'October'},
          {value: '11', label: 'November'},
          {value: '12', label: 'December'}
        ];

        $scope.date = {
          day: '',
          month: '',
          year: ''
        };
      }],
      link: function(scope, elem, attrs, ngModel) {
        if (scope.builder) return;
        // Set the scope values based on the current model.
        scope.$watch('ngModel', function() {
          // Only update on load.
          if (ngModel.$viewValue && !ngModel.$dirty) {
            var parts = typeof ngModel.$viewValue === 'string'
              ? ngModel.$viewValue.split('/')
              : ngModel.$viewValue;
            if ((parts instanceof Array) && parts.length === 3) {
              scope.date.day = parts[(scope.component.dayFirst ? 0 : 1)];
              scope.date.month = parts[(scope.component.dayFirst ? 1 : 0)];
              scope.date.year = parts[2];
            }
          }
        });

        var padLeft = function padLeft(nr, n, str) {
          nr = nr.toString();
          if (nr.length > n) {
            return nr.substr(0, n);
          }

          return Array((n - nr.length) + 1).join(str || '0') + nr;
        };

        scope.onChange = function() {
          var day = padLeft(scope.date.day, 2);
          var month = padLeft(scope.date.month, 2);
          var year = padLeft(scope.date.year, 4);
          var value = scope.component.dayFirst ? day : month;
          value += '/';
          value += scope.component.dayFirst ? month : day;
          value += '/' + year;
          ngModel.$setViewValue(value);
        };

        ngModel.$validators.day = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          var required = scope.component.fields.day.required || scope.component.fields.month.required || scope.component.fields.year.required;

          if (!required) {
            return true;
          }
          if (!value && required) {
            return false;
          }
          var parts = value.split('/');
          if (scope.component.fields.day.required) {
            if (parts[(scope.component.dayFirst ? 0 : 1)] === '00') {
              return false;
            }
          }
          if (scope.component.fields.month.required) {
            if (parts[(scope.component.dayFirst ? 1 : 0)] === '00') {
              return false;
            }
          }
          if (scope.component.fields.year.required) {
            if (parts[2] === '0000') {
              return false;
            }
          }
          return true;
        };
      }
    };
  });
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('day', {
        title: 'Day',
        template: 'formio/components/day.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'dayField',
          fields: {
            day: {
              type: 'text',
              placeholder: '',
              required: false
            },
            month: {
              type: 'select',
              placeholder: '',
              required: false
            },
            year: {
              type: 'text',
              placeholder: '',
              required: false
            }
          },
          dayFirst: false,
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            custom: ''
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/day.html', FormioUtils.fieldWrap(
        "<div class=\"day-input\">\n  <day-input\n    name=\"{{componentId}}\"\n    component-id=\"componentId\"\n    read-only=\"isDisabled(component, data)\"\n    component=\"component\"\n    ng-required=\"isRequired(component)\"\n    custom-validator=\"component.validate.custom\"\n    ng-model=\"data[component.key]\"\n    tabindex=\"{{ component.tabindex || 0 }}\"\n    builder=\"builder\"\n  ></day-input>\n</div>\n"
      ));
      $templateCache.put('formio/components/day-input.html',
        "<div class=\"daySelect form row\">\n  <div class=\"form-group col-xs-3\" ng-if=\"component.dayFirst && !component.fields.day.hide\">\n    <label for=\"{{componentId}}-day\" ng-class=\"{'field-required': component.fields.day.required}\">{{ \"Day\" | formioTranslate:null:builder }}</label>\n    <input\n      class=\"form-control\"\n      type=\"text\"\n      id=\"{{componentId}}-day\"\n      ng-model=\"date.day\"\n      ng-change=\"onChange()\"\n      style=\"padding-right: 10px;\"\n      ng-attr-placeholder=\"{{component.fields.day.placeholder}}\"\n      day-part\n      characters=\"2\"\n      min=\"0\"\n      max=\"31\"\n      ng-disabled=\"readOnly\"\n    />\n  </div>\n  <div class=\"form-group col-xs-4\" ng-if=\"!component.fields.month.hide\">\n    <label for=\"{{componentId}}-month\" ng-class=\"{'field-required': component.fields.month.required}\">{{ \"Month\" | formioTranslate:null:builder }}</label>\n    <select\n      class=\"form-control\"\n      type=\"text\"\n      id=\"{{componentId}}-month\"\n      ng-model=\"date.month\"\n      ng-change=\"onChange()\"\n      ng-disabled=\"readOnly\"\n      ng-options=\"month.value as month.label | formioTranslate:null:builder for month in months\"\n    ></select>\n  </div>\n  <div class=\"form-group col-xs-3\" ng-if=\"!component.dayFirst && !component.fields.day.hide\">\n    <label for=\"{{componentId}}-day\" ng-class=\"{'field-required': component.fields.day.required}\">{{ \"Day\" | formioTranslate:null:builder }}</label>\n    <input\n      class=\"form-control\"\n      type=\"text\"\n      id=\"{{componentId}}-day1\"\n      ng-model=\"date.day\"\n      ng-change=\"onChange()\"\n      style=\"padding-right: 10px;\"\n      ng-attr-placeholder=\"{{component.fields.day.placeholder}}\"\n      day-part\n      characters=\"2\"\n      min=\"0\"\n      max=\"31\"\n      ng-disabled=\"readOnly\"\n    />\n  </div>\n  <div class=\"form-group col-xs-5\" ng-if=\"!component.fields.year.hide\">\n    <label for=\"{{componentId}}-year\" ng-class=\"{'field-required': component.fields.year.required}\">{{ \"Year\" | formioTranslate:null:builder }}</label>\n    <input\n      class=\"form-control\"\n      type=\"text\"\n      id=\"{{componentId}}-year\"\n      ng-model=\"date.year\"\n      ng-change=\"onChange()\"\n      style=\"padding-right: 10px;\"\n      ng-attr-placeholder=\"{{component.fields.year.placeholder}}\"\n      characters=\"4\"\n      min=\"0\"\n      max=\"2100\"\n      ng-disabled=\"readOnly\"\n    />\n  </div>\n</div>\n"
      );
    }
  ]);
};

},{}],184:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('email', {
        title: 'Email',
        template: 'formio/components/textfield.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          inputType: 'email',
          label: '',
          key: 'emailField',
          placeholder: '',
          prefix: '',
          suffix: '',
          defaultValue: '',
          protected: false,
          unique: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          kickbox: {
            enabled: false
          }
        }
      });
    }
  ]);
};

},{}],185:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('fieldset', {
        title: 'Field Set',
        template: 'formio/components/fieldset.html',
        group: 'layout',
        settings: {
          key: 'fieldset',
          input: false,
          tableView: true,
          legend: '',
          components: []
        },
        viewTemplate: 'formio/componentsView/fieldset.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/fieldset.html',
        "<fieldset id=\"{{ component.key }}\">\n  <legend ng-if=\"component.legend\">{{ component.legend | formioTranslate:null:builder }}</legend>\n  <formio-component\n    ng-repeat=\"_component in component.components track by $index\"\n    component=\"_component\"\n    data=\"data\"\n    formio=\"formio\"\n    submission=\"submission\"\n    hide-components=\"hideComponents\"\n    ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n    read-only=\"isDisabled(_component, data)\"\n    formio-form=\"formioForm\"\n    grid-row=\"gridRow\"\n    grid-col=\"gridCol\"\n    builder=\"builder\"\n  ></formio-component>\n</fieldset>\n"
      );

      $templateCache.put('formio/componentsView/fieldset.html',
        "<fieldset id=\"{{ component.key }}\">\n  <legend ng-if=\"component.legend\">{{ component.legend }}</legend>\n  <formio-component-view\n    ng-repeat=\"_component in component.components track by $index\"\n    component=\"_component\"\n    data=\"data\"\n    submission=\"submission\"\n    form=\"form\"\n    ignore=\"ignore\"\n    ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n    builder=\"builder\"\n  ></formio-component-view>\n</fieldset>\n"
      );
    }
  ]);
};

},{}],186:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('file', {
        title: 'File',
        template: 'formio/components/file.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'file',
          image: false,
          imageSize: '200',
          placeholder: '',
          multiple: false,
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true
        },
        viewTemplate: 'formio/componentsView/file.html'
      });
    }
  ]);

  app.directive('formioFileList', [function() {
    return {
      restrict: 'E',
      replace: true,
      scope: {
        files: '=',
        form: '=',
        readOnly: '='
      },
      templateUrl: 'formio/components/formio-file-list.html',
      controller: [
        '$scope',
        function($scope) {
          if ($scope.builder) return;
          $scope.removeFile = function(event, index) {
            var component = $scope.$parent.component;
            if (component.storage === 'url') {
              $scope.$parent.formio.makeRequest('', component.url + '/' + $scope.files[index].name, 'delete');
            }
            event.preventDefault();
            $scope.files.splice(index, 1);
          };

          $scope.fileSize = function(a, b, c, d, e) {
            return (b = Math, c = b.log, d = 1024, e = c(a) / c(d) | 0, a / b.pow(d, e)).toFixed(2) + ' ' + (e ? 'kMGTPEZY'[--e] + 'B' : 'Bytes');
          };
        }
      ]
    };
  }]);

  app.directive('formioImageList', [function() {
    return {
      restrict: 'E',
      replace: true,
      scope: {
        files: '=',
        form: '=',
        width: '=',
        readOnly: '='
      },
      templateUrl: 'formio/components/formio-image-list.html',
      controller: [
        '$scope',
        function($scope) {
          if ($scope.builder) return;
          $scope.removeFile = function(event, index) {
            var component = $scope.$parent.component;
            if (component.storage === 'url') {
              $scope.$parent.formio.makeRequest('', component.url + '/' + $scope.files[index].name, 'delete');
            }
            event.preventDefault();
            $scope.files.splice(index, 1);
          };
        }
      ]
    };
  }]);

  app.directive('formioFile', [function() {
    return {
      restrict: 'E',
      replace: true,
      scope: {
        file: '=',
        form: '='
      },
      template: '<a href="{{ file.url }}" ng-click="getFile($event)" target="_blank">{{ file.name }}</a>',
      controller: [
        '$window',
        '$rootScope',
        '$scope',
        'Formio',
        function(
          $window,
          $rootScope,
          $scope,
          Formio
        ) {
          if ($scope.builder) return;
          $scope.getFile = function(evt) {
            evt.preventDefault();
            $scope.form = $scope.form || $rootScope.filePath;
            var formio = new Formio($scope.form);
            formio
              .downloadFile($scope.file).then(function(file) {
                if (file) {
                  $window.open(file.url, '_blank');
                }
              })
              .catch(function(response) {
                // Is alert the best way to do this?
                // User is expecting an immediate notification due to attempting to download a file.
                alert(response);
              });
          };
        }
      ]
    };
  }]);

  app.directive('formioImage', [function() {
    return {
      restrict: 'E',
      replace: true,
      scope: {
        file: '=',
        form: '=',
        width: '='
      },
      template: '<img ng-src="{{ file.imageSrc }}" alt="{{ file.name }}" ng-style="{width: width}" />',
      controller: [
        '$rootScope',
        '$scope',
        'Formio',
        function(
          $rootScope,
          $scope,
          Formio
        ) {
          if ($scope.builder) return;
          $scope.form = $scope.form || $rootScope.filePath;
          var formio = new Formio($scope.form);
          formio.downloadFile($scope.file)
            .then(function(result) {
              $scope.file.imageSrc = result.url;
              $scope.$apply();
            });
        }
      ]
    };
  }]);

  app.controller('formioFileUpload', [
    '$scope',
    'FormioUtils',
    function(
      $scope,
      FormioUtils
    ) {
      if ($scope.builder) return;
      $scope.fileUploads = {};
      $scope.removeUpload = function(index) {
        delete $scope.fileUploads[index];
      };

      // This fixes new fields having an empty space in the array.
      if ($scope.data && $scope.data[$scope.component.key] === '') {
        $scope.data[$scope.component.key] = [];
      }
      if ($scope.data && $scope.data[$scope.component.key] === undefined) {
        $scope.data[$scope.component.key] = [];
      }
      if ($scope.data && $scope.data[$scope.component.key] && $scope.data[$scope.component.key][0] === '') {
        $scope.data[$scope.component.key].splice(0, 1);
      }

      $scope.upload = function(files) {
        if ($scope.component.storage && files && files.length) {
          angular.forEach(files, function(file) {
            // Get a unique name for this file to keep file collisions from occurring.
            var fileName = FormioUtils.uniqueName(file.name);
            $scope.fileUploads[fileName] = {
              name: fileName,
              size: file.size,
              status: 'info',
              message: 'Starting upload'
            };
            var dir = $scope.component.dir || '';
            var formio = null;
            if ($scope.formio) {
              formio = $scope.formio;
            }
            else {
              $scope.fileUploads[fileName].status = 'error';
              $scope.fileUploads[fileName].message = 'File Upload URL not provided.';
            }

            if (formio) {
              formio.uploadFile($scope.component.storage, file, fileName, dir, function processNotify(evt) {
                $scope.fileUploads[fileName].status = 'progress';
                $scope.fileUploads[fileName].progress = parseInt(100.0 * evt.loaded / evt.total);
                delete $scope.fileUploads[fileName].message;
                $scope.$apply();
              }, $scope.component.url)
                .then(function(fileInfo) {
                  delete $scope.fileUploads[fileName];
                  // Ensure that the file component is an array.
                  if (
                    !$scope.data[$scope.component.key] ||
                    !($scope.data[$scope.component.key] instanceof Array)
                  ) {
                    $scope.data[$scope.component.key] = [];
                  }
                  $scope.data[$scope.component.key].push(fileInfo);
                  $scope.$apply();
                })
                .catch(function(response) {
                  $scope.fileUploads[fileName].status = 'error';
                  $scope.fileUploads[fileName].message = response.data;
                  delete $scope.fileUploads[fileName].progress;
                  $scope.$apply();
                });
            }
          });
        }
      };
    }
  ]);
  app.run([
    '$templateCache',
    function(
      $templateCache
    ) {
      $templateCache.put('formio/components/formio-image-list.html',
        "<div>\n  <span ng-repeat=\"file in files track by $index\" ng-if=\"file\">\n    <formio-image file=\"file\" form=\"form\" width=\"width\"></formio-image>\n    <span ng-if=\"!readOnly\" style=\"width:1%;white-space:nowrap;\">\n      <a href=\"#\" ng-click=\"removeFile($event, $index)\" style=\"padding: 2px 4px;\" class=\"btn btn-sm btn-default\"><span class=\"glyphicon glyphicon-remove\"></span></a>\n    </span>\n  </span>\n</div>\n"
      );

      $templateCache.put('formio/components/formio-file-list.html',
        "<table class=\"table table-striped table-bordered\">\n  <thead>\n    <tr>\n      <td ng-if=\"!readOnly\" style=\"width:1%;white-space:nowrap;\"></td>\n      <th>File Name</th>\n      <th>Size</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat=\"file in files track by $index\">\n      <td ng-if=\"!readOnly\" style=\"width:1%;white-space:nowrap;\"><a ng-if=\"!readOnly\" href=\"#\" ng-click=\"removeFile($event, $index)\" style=\"padding: 2px 4px;\" class=\"btn btn-sm btn-default\"><span class=\"glyphicon glyphicon-remove\"></span></a></td>\n      <td><formio-file file=\"file\" form=\"form\"></formio-file></td>\n      <td>{{ fileSize(file.size) }}</td>\n    </tr>\n  </tbody>\n</table>\n"
      );

      $templateCache.put('formio/components/file.html',
        "<label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\n<span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\n<div ng-controller=\"formioFileUpload\">\n  <formio-file-list files=\"data[component.key]\" form=\"formio.formUrl\" ng-if=\"!component.image\"></formio-file-list>\n  <formio-image-list files=\"data[component.key]\" form=\"formio.formUrl\" width=\"component.imageSize\" ng-if=\"component.image\"></formio-image-list>\n  <div ng-if=\"!readOnly && (component.multiple || (!component.multiple && !data[component.key].length))\">\n    <div ngf-drop=\"upload($files)\" class=\"fileSelector\" ngf-drag-over-class=\"'fileDragOver'\" ngf-multiple=\"component.multiple\" id=\"{{ componentId }}\" name=\"{{ componentId }}\"><span class=\"glyphicon glyphicon-cloud-upload\"></span>Drop files to attach, or <a style=\"cursor: pointer;\" ngf-select=\"upload($files)\" tabindex=\"{{ component.tabindex || 0 }}\" ngf-multiple=\"component.multiple\">browse</a>.</div>\n    <div ng-if=\"!component.storage\" class=\"alert alert-warning\">No storage has been set for this field. File uploads are disabled until storage is set up.</div>\n    <div ngf-no-file-drop>File Drag/Drop is not supported for this browser</div>\n  </div>\n  <div ng-repeat=\"fileUpload in fileUploads track by $index\" ng-class=\"{'has-error': fileUpload.status === 'error'}\" class=\"file\">\n    <div class=\"row\">\n      <div class=\"fileName control-label col-sm-10\">{{ fileUpload.name }} <span ng-click=\"removeUpload(fileUpload.name)\" class=\"glyphicon glyphicon-remove\"></span></div>\n      <div class=\"fileSize control-label col-sm-2 text-right\">{{ fileSize(fileUpload.size) }}</div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col-sm-12\">\n        <span ng-if=\"fileUpload.status === 'progress'\">\n          <div class=\"progress\">\n            <div class=\"progress-bar\" role=\"progressbar\" aria-valuenow=\"{{fileUpload.progress}}\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width:{{fileUpload.progress}}%\">\n              <span class=\"sr-only\">{{fileUpload.progress}}% Complete</span>\n            </div>\n          </div>\n        </span>\n        <div ng-if=\"!fileUpload.status !== 'progress'\" class=\"bg-{{ fileUpload.status }} control-label\">{{ fileUpload.message }}</div>\n      </div>\n    </div>\n  </div>\n</div>\n"
      );

      $templateCache.put('formio/componentsView/file.html',
        "<label ng-if=\"component.label && !component.hideLabel\" for=\"{{ component.key }}\" class=\"control-label\" ng-class=\"{'field-required': component.validate.required}\">{{ component.label | formioTranslate:null:builder }}</label>\n<div ng-controller=\"formioFileUpload\">\n  <formio-file-list files=\"data[component.key]\" form=\"formUrl\" read-only=\"true\" ng-if=\"!component.image\"></formio-file-list>\n  <formio-image-list files=\"data[component.key]\" form=\"formUrl\" read-only=\"true\" width=\"component.imageSize\" ng-if=\"component.image\"></formio-image-list>\n</div>\n"
      );
    }
  ]);
};

},{}],187:[function(_dereq_,module,exports){
"use strict";

var GridUtils = _dereq_('../factories/GridUtils')();

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('hidden', {
        title: 'Hidden',
        template: 'formio/components/hidden.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          key: 'hiddenField',
          label: '',
          protected: false,
          unique: false,
          persistent: true
        },
        tableView: GridUtils.generic
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/hidden.html',
        "<input type=\"hidden\" id=\"{{ componentId }}\" name=\"{{ componentId }}\" ng-model=\"data[component.key]\">\n"
      );
    }
  ]);
};

},{"../factories/GridUtils":218}],188:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.directive('formioHtmlElement', [
    '$sanitize',
    '$filter',
    function($sanitize, $filter) {
      return {
        restrict: 'E',
        scope: {
          component: '='
        },
        templateUrl: 'formio/components/htmlelement-directive.html',
        link: function($scope) {
          if ($scope.builder) return;
          var displayError = function(msg) {
            $scope.parseError = 'Invalid HTML: ' + msg.toString();
          };

          $scope.$watch('component', function createElement() {
            if (!$scope.component.tag) {
              return displayError('No tag given');
            }

            var element = angular.element('<' + $scope.component.tag + '>' + '</' + $scope.component.tag + '>');
            element.html($filter('formioTranslate')($scope.component.content));

            // Add the css classes if supplied.
            if ($scope.component.className) {
              element.attr('class', $scope.component.className);
            }

            angular.forEach($scope.component.attrs, function(attr) {
              if (!attr.attr) return;
              element.attr(attr.attr, attr.value);
            });

            try {
              $scope.html = $sanitize(element.prop('outerHTML'));
              $scope.parseError = null;

              // If the sanitized html is empty, it was invalid; Create a visible error so we still render something.
              if (!$scope.html) {
                return displayError(element.prop('outerHTML'));
              }
            }
            catch (err) {
              // Isolate the message and store it.
              $scope.parseError = err.message
                .split('\n')[0]
                .replace('[$sanitize:badparse]', '');
            }
          }, true);
        }
      };
  }]);

  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('htmlelement', {
        title: 'HTML Element',
        template: 'formio/components/htmlelement.html',
        viewTemplate: 'formio/components/htmlelement.html',
        settings: {
          key: 'html',
          input: false,
          tag: 'p',
          attrs: [],
          className: '',
          content: ''
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/htmlelement.html',
        '<formio-html-element component="component"></div>'
      );

      $templateCache.put('formio/components/htmlelement-directive.html',
        "<div id=\"{{ component.key }}\">\n  <div class=\"alert alert-warning\" ng-if=\"parseError\">{{ parseError }}</div>\n  <div ng-bind-html=\"html\"></div>\n</div>\n"
      );
    }
  ]);
};

},{}],189:[function(_dereq_,module,exports){
"use strict";
var app = angular.module('formio');

// Basic
_dereq_('./components')(app);
_dereq_('./textfield')(app);
_dereq_('./number')(app);
_dereq_('./password')(app);
_dereq_('./textarea')(app);
_dereq_('./checkbox')(app);
_dereq_('./selectboxes')(app);
_dereq_('./select')(app);
_dereq_('./radio')(app);
_dereq_('./htmlelement')(app);
_dereq_('./content')(app);
_dereq_('./button')(app);

// Special
_dereq_('./email')(app);
_dereq_('./phonenumber')(app);
_dereq_('./address')(app);
_dereq_('./datetime')(app);
_dereq_('./day')(app);
_dereq_('./currency')(app);
_dereq_('./hidden')(app);
_dereq_('./resource')(app);
_dereq_('./file')(app);
_dereq_('./signature')(app);
_dereq_('./custom')(app);
_dereq_('./container')(app);
_dereq_('./datagrid')(app);
_dereq_('./survey')(app);

// Layout
_dereq_('./columns')(app);
_dereq_('./fieldset')(app);
_dereq_('./page')(app);
_dereq_('./panel')(app);
_dereq_('./table')(app);
_dereq_('./well')(app);

},{"./address":172,"./button":173,"./checkbox":174,"./columns":175,"./components":176,"./container":177,"./content":178,"./currency":179,"./custom":180,"./datagrid":181,"./datetime":182,"./day":183,"./email":184,"./fieldset":185,"./file":186,"./hidden":187,"./htmlelement":188,"./number":190,"./page":191,"./panel":192,"./password":193,"./phonenumber":194,"./radio":195,"./resource":196,"./select":197,"./selectboxes":198,"./signature":199,"./survey":200,"./table":201,"./textarea":202,"./textfield":203,"./well":204}],190:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      var isNumeric = function isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };
      formioComponentsProvider.register('number', {
        title: 'Number',
        template: 'formio/components/number.html',
        settings: {
          input: true,
          tableView: true,
          inputType: 'number',
          label: '',
          key: 'numberField',
          placeholder: '',
          prefix: '',
          suffix: '',
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            min: '',
            max: '',
            step: 'any',
            integer: '',
            multiple: '',
            custom: ''
          }
        },
        controller: ['$scope', function($scope) {
          if ($scope.builder) return; // FOR-71 - Skip parsing input data.

          // Ensure that values are numbers.
          if (
            $scope.data &&
            $scope.data.hasOwnProperty($scope.component.key) &&
            isNumeric($scope.data[$scope.component.key])
          ) {
            $scope.data[$scope.component.key] = parseFloat($scope.data[$scope.component.key]);
          }
        }]
      });
    }
  ]);

  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/number.html', FormioUtils.fieldWrap(
        "<input\n  type=\"{{ component.inputType }}\"\n  class=\"form-control\"\n  id=\"{{ componentId }}\"\n  name=\"{{ componentId }}\"\n  tabindex=\"{{ component.tabindex || 0 }}\"\n  ng-model=\"data[component.key]\"\n  ng-required=\"isRequired(component)\"\n  ng-disabled=\"readOnly\"\n  safe-multiple-to-single\n  min=\"{{ component.validate.min }}\"\n  max=\"{{ component.validate.max }}\"\n  step=\"{{ component.validate.step }}\"\n  ng-attr-placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\"\n  custom-validator=\"component.validate.custom\"\n  ui-mask=\"{{ component.inputMask }}\"\n  ui-mask-placeholder=\"\"\n  ui-options=\"uiMaskOptions\"\n>\n"
      ));
    }
  ]);
};

},{}],191:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('page', {
        template: 'formio/components/page.html',
        settings: {
          key: 'page',
          input: false,
          components: []
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/page.html',
        "<formio-component\n  ng-repeat=\"_component in component.components track by $index\"\n  component=\"_component\"\n  data=\"data\"\n  formio=\"formio\"\n  submission=\"submission\"\n  hide-components=\"hideComponents\"\n  ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n  read-only=\"isDisabled(_component, data)\"\n  formio-form=\"formioForm\"\n  grid-row=\"gridRow\"\n  grid-col=\"gridCol\"\n  builder=\"builder\"\n></formio-component>\n"
      );
    }
  ]);
};

},{}],192:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('panel', {
        title: 'Panel',
        template: 'formio/components/panel.html',
        group: 'layout',
        settings: {
          key: 'panel',
          input: false,
          title: '',
          theme: 'default',
          components: []
        },
        viewTemplate: 'formio/componentsView/panel.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/panel.html',
        "<div class=\"panel panel-{{ component.theme }}\" id=\"{{ component.key }}\">\n  <div ng-if=\"component.title\" class=\"panel-heading\">\n    <h3 class=\"panel-title\">{{ component.title | formioTranslate:null:builder }}</h3>\n  </div>\n  <div class=\"panel-body\">\n    <formio-component\n      ng-repeat=\"_component in component.components track by $index\"\n      component=\"_component\"\n      data=\"data\"\n      formio=\"formio\"\n      submission=\"submission\"\n      hide-components=\"hideComponents\"\n      ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n      read-only=\"isDisabled(_component, data)\"\n      formio-form=\"formioForm\"\n      grid-row=\"gridRow\"\n      grid-col=\"gridCol\"\n      builder=\"builder\"\n    ></formio-component>\n  </div>\n</div>\n"
      );

      $templateCache.put('formio/componentsView/panel.html',
        "<div class=\"panel panel-{{ component.theme }}\" id=\"{{ component.key }}\">\n  <div ng-if=\"component.title\" class=\"panel-heading\">\n    <h3 class=\"panel-title\">{{ component.title }}</h3>\n  </div>\n  <div class=\"panel-body\">\n    <formio-component-view\n      ng-repeat=\"_component in component.components track by $index\"\n      component=\"_component\"\n      data=\"data\"\n      submission=\"submission\"\n      form=\"form\"\n      ignore=\"ignore\"\n      ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n      builder=\"builder\"\n    ></formio-component-view>\n  </div>\n</div>\n"
      );
    }
  ]);
};

},{}],193:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('password', {
        title: 'Password',
        template: 'formio/components/textfield.html',
        tableView: function() {
          return '--- PROTECTED ---';
        },
        settings: {
          input: true,
          tableView: false,
          inputType: 'password',
          label: '',
          key: 'passwordField',
          placeholder: '',
          prefix: '',
          suffix: '',
          protected: true,
          persistent: true,
          hidden: false,
          clearOnHide: true
        }
      });
    }
  ]);
};

},{}],194:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('phoneNumber', {
        title: 'Phone Number',
        template: 'formio/components/textfield.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          inputMask: '(999) 999-9999',
          label: '',
          key: 'phonenumberField',
          placeholder: '',
          prefix: '',
          suffix: '',
          multiple: false,
          protected: false,
          unique: false,
          persistent: true,
          hidden: false,
          defaultValue: '',
          clearOnHide: true,
          validate: {
            required: false
          }
        }
      });
    }
  ]);
};

},{}],195:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('radio', {
        title: 'Radio',
        template: 'formio/components/radio.html',
        tableView: function(data, component) {
          for (var i in component.values) {
            if (component.values[i].value === data) {
              return component.values[i].label;
            }
          }
          return data;
        },
        settings: {
          input: true,
          tableView: true,
          inputType: 'radio',
          label: '',
          key: 'radioField',
          values: [],
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            custom: '',
            customPrivate: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/radio.html', FormioUtils.fieldWrap(
        "<ng-form name=\"{{ componentId }}\" ng-model=\"data[component.key]\" custom-validator=\"component.validate.custom\">\n  <div ng-class=\"component.inline ? 'radio-inline' : 'radio'\" ng-repeat=\"v in component.values track by $index\">\n    <label class=\"control-label\" for=\"{{ componentId }}-{{ v.value }}\">\n      <input\n        type=\"{{ component.inputType }}\"\n        id=\"{{ componentId }}-{{ v.value }}\"\n        value=\"{{ v.value }}\"\n        tabindex=\"{{ component.tabindex || 0 }}\"\n        ng-model=\"data[component.key]\"\n        ng-required=\"isRequired(component)\"\n        custom-validator=\"component.validate.custom\"\n        ng-disabled=\"readOnly\"\n      >\n      {{ v.label | formioTranslate:null:builder }}\n    </label>\n  </div>\n</ng-form>\n"
      ));
    }
  ]);
};

},{}],196:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('resource', {
        title: 'Resource',
        tableView: function(data, component, $interpolate) {
          if ($interpolate) {
            return $interpolate(component.template)({item: data});
          }

          return data ? data._id : '';
        },
        template: function($scope) {
          return $scope.component.multiple ? 'formio/components/resource-multiple.html' : 'formio/components/resource.html';
        },
        controller: ['$scope', 'Formio', 'ngDialog', function($scope, Formio, ngDialog) {
          if ($scope.builder) return;
          var settings = $scope.component;
          var params = settings.params || {};
          $scope.selectItems = [];
          $scope.hasNextPage = false;
          $scope.resourceLoading = false;
          params.limit = 100;
          params.skip = 0;
          if (settings.multiple) {
            settings.defaultValue = [];
          }
          if (settings.resource) {
            var url = '';
            if (settings.project) {
              url += '/project/' + settings.project;
            }
            else if ($scope.formio && $scope.formio.projectUrl) {
              url += $scope.formio.projectUrl;
            }
            url += '/form/' + settings.resource;
            var formio = new Formio(url);

            // Refresh the items.
            $scope.refreshSubmissions = function(input, append) {
              if ($scope.resourceLoading) {
                return;
              }
              $scope.resourceLoading = true;
              // If they wish to return only some fields.
              if (settings.selectFields) {
                params.select = settings.selectFields;
              }
              if (settings.searchFields && input) {
                angular.forEach(settings.searchFields, function(field) {
                  params[field] = input;
                });
              }

              // Load the submissions.
              formio.loadSubmissions({
                params: params
              }).then(function(submissions) {
                submissions = submissions || [];
                if (append) {
                  $scope.selectItems = $scope.selectItems.concat(submissions);
                }
                else {
                  $scope.selectItems = submissions;
                }
                $scope.hasNextPage = (submissions.length >= params.limit) && ($scope.selectItems.length < submissions.serverCount);
              })['finally'](function() {
                $scope.resourceLoading = false;
              });
            };

            // Load more items.
            $scope.loadMoreItems = function($select, $event) {
              $event.stopPropagation();
              $event.preventDefault();
              params.skip += params.limit;
              $scope.refreshSubmissions(null, true);
            };

            $scope.refreshSubmissions();

            // Add a new resource.
            $scope.newResource = function() {
              var template  = '<br>' +
                              '<div class="row">' +
                                '<div class="col-sm-12">' +
                                  '<div class="panel panel-default">' +
                                    '<div class="panel-heading">' +
                                      '<h3 class="panel-title">{{ component.addResourceLabel || "Add Resource" | formioTranslate}}</h3>' +
                                    '</div>' +
                                    '<div class="panel-body">' +
                                      '<formio src="formUrl"></formio>' +
                                    '</div>' +
                                  '</div>' +
                                '</div>' +
                              '</div>';

              ngDialog.open({
                template: template,
                plain: true,
                scope: $scope,
                controller: ['$scope', function($scope) {
                  $scope.formUrl = $scope.formio.formsUrl + '/' + $scope.component.resource;

                  // Bind when the form is loaded.
                  $scope.$on('formLoad', function(event) {
                    event.stopPropagation(); // Don't confuse app
                  });

                  // Bind when the form is submitted.
                  $scope.$on('formSubmission', function(event, submission) {
                    var component = $scope.component;
                    var data      = $scope.data;

                    if (component.multiple) {
                      data[component.key].push(submission);
                    }
                    else {
                      data[component.key] = submission;
                    }

                    $scope.refreshSubmissions();
                    $scope.closeThisDialog(submission);
                  });
                }]
              }).closePromise.then(function(/*e*/) {
              //var cancelled = e.value === false || e.value === '$closeButton' || e.value === '$document';
              });
            };

            // Close all open dialogs on state change (using UI-Router).
            $scope.$on('$stateChangeStart', function() {
              ngDialog.closeAll(false);
            });

            // Close all open dialogs on route change (using ngRoute).
            $scope.$on('$routeChangeStart', function() {
              ngDialog.closeAll(false);
            });
          }
        }],
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'resourceField',
          placeholder: '',
          resource: '',
          project: '',
          defaultValue: '',
          template: '<span>{{ item.data }}</span>',
          selectFields: '',
          searchFields: '',
          multiple: false,
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false
          },
          defaultPermission: ''
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/resource.html',
        "<div ng-if=\"!component.addResource\">\n  <label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\n  <span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\n  <ui-select ui-select-required safe-multiple-to-single ui-select-open-on-focus ng-model=\"data[component.key]\" ng-disabled=\"readOnly\" ng-required=\"isRequired(component)\" id=\"{{ componentId }}\" name=\"{{ componentId }}\" theme=\"bootstrap\" tabindex=\"{{ component.tabindex || 0 }}\">\n    <ui-select-match class=\"ui-select-match\" placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\">\n      <formio-select-item template=\"component.template\" item=\"$item || $select.selected\" select=\"$select\"></formio-select-item>\n    </ui-select-match>\n    <ui-select-choices class=\"ui-select-choices\" repeat=\"item in selectItems | filter: $select.search\" refresh=\"refreshSubmissions($select.search)\" refresh-delay=\"250\">\n      <formio-select-item template=\"component.template\" item=\"item\" select=\"$select\"></formio-select-item>\n      <button ng-if=\"hasNextPage && ($index == $select.items.length-1)\" class=\"btn btn-success btn-block\" ng-click=\"loadMoreItems($select, $event)\" ng-disabled=\"resourceLoading\">Load more...</button>\n    </ui-select-choices>\n  </ui-select>\n  <formio-errors ng-if=\"::!builder\"></formio-errors>\n</div>\n<div ng-if=\"component.addResource\">\n  <table class=\"table table-bordered\">\n    <label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\n    <span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\n    <tr>\n      <td>\n        <ui-select ui-select-required safe-multiple-to-single ui-select-open-on-focus ng-model=\"data[component.key]\" ng-disabled=\"readOnly\" ng-required=\"isRequired(component)\" id=\"{{ componentId }}\" name=\"{{ componentId }}\" theme=\"bootstrap\" tabindex=\"{{ component.tabindex || 0 }}\">\n          <ui-select-match class=\"ui-select-match\" placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\">\n            <formio-select-item template=\"component.template\" item=\"$item || $select.selected\" select=\"$select\"></formio-select-item>\n          </ui-select-match>\n          <ui-select-choices class=\"ui-select-choices\" repeat=\"item in selectItems | filter: $select.search\" refresh=\"refreshSubmissions($select.search)\" refresh-delay=\"250\">\n            <formio-select-item template=\"component.template\" item=\"item\" select=\"$select\"></formio-select-item>\n            <button ng-if=\"hasNextPage && ($index == $select.items.length-1)\" class=\"btn btn-success btn-block\" ng-click=\"loadMoreItems($select, $event)\" ng-disabled=\"resourceLoading\">Load more...</button>\n          </ui-select-choices>\n        </ui-select>\n        <formio-errors ng-if=\"::!builder\"></formio-errors>\n      </td>\n    </tr>\n    <tr>\n      <td>\n        <a ng-click=\"newResource()\" class=\"btn btn-primary\">\n          <span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"></span> {{ component.addResourceLabel || \"Add Resource\" | formioTranslate:null:builder}}\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>\n"
      );

      // Change the ui-select to ui-select multiple.
      $templateCache.put('formio/components/resource-multiple.html',
        $templateCache.get('formio/components/resource.html').replace(/<ui-select\s/g, '<ui-select multiple ')
      );
    }
  ]);
};

},{}],197:[function(_dereq_,module,exports){
"use strict";
/*eslint max-depth: ["error", 6]*/

var _get = _dereq_('lodash/get');
var _isEqual = _dereq_('lodash/isEqual');
var _set = _dereq_('lodash/set');
var _cloneDeep = _dereq_('lodash/cloneDeep');
module.exports = function(app) {
  app.directive('formioSelectItem', [
    '$compile',
    function($compile) {
      return {
        restrict: 'E',
        scope: {
          template: '=',
          item: '=',
          select: '='
        },
        link: function(scope, element) {
          if (scope.builder) return;
          if (scope.template) {
            element.append($compile(angular.element(scope.template))(scope));
          }
        }
      };
    }
  ]);

  app.directive('uiSelectRequired', function() {
    return {
      require: 'ngModel',
      link: function(scope, element, attrs, ngModel) {
        if (scope.builder) return;
        var oldIsEmpty = ngModel.$isEmpty;
        ngModel.$isEmpty = function(value) {
          return (Array.isArray(value) && value.length === 0) || oldIsEmpty(value);
        };
      }
    };
  });

  // A directive to have ui-select open on focus
  app.directive('uiSelectOpenOnFocus', [function() {
    return {
      require: 'uiSelect',
      restrict: 'A',
      link: function($scope, el, attrs, uiSelect) {
        if ($scope.builder) return;
        var focuscount = -1;

        angular.element(uiSelect.focusser).on('focus', function() {
          if (focuscount-- < 0) {
            uiSelect.activate();
          }
        });

        // Disable the auto open when this select element has been activated.
        $scope.$on('uis:activate', function() {
          focuscount = 1;
        });

        // Re-enable the auto open after the select element has been closed
        $scope.$on('uis:close', function() {
          focuscount = 1;
        });
      }
    };
  }]);

  // Configure the Select component.
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('select', {
        title: 'Select',
        template: function($scope) {
          return $scope.component.multiple ? 'formio/components/select-multiple.html' : 'formio/components/select.html';
        },
        tableView: function(data, component, $interpolate) {
          var getItem = function(data) {
            switch (component.dataSrc) {
              case 'values':
                component.data.values.forEach(function(item) {
                  if (item.value === data) {
                    data = item;
                  }
                });
                return data;
              case 'json':
                if (component.valueProperty) {
                  var selectItems;
                  try {
                    selectItems = angular.fromJson(component.data.json);
                  }
                  catch (error) {
                    selectItems = [];
                  }
                  selectItems.forEach(function(item) {
                    if (item[component.valueProperty] === data) {
                      data = item;
                    }
                  });
                }
                return data;
              // TODO: implement url and resource view.
              case 'url':
              case 'resource':
              default:
                return data;
            }
          };
          if (component.multiple && Array.isArray(data)) {
            return data.map(getItem).reduce(function(prev, item) {
              var value;
              if (typeof item === 'object') {
                value = $interpolate(component.template)({item: item});
              }
              else {
                value = item;
              }
              return (prev === '' ? '' : ', ') + value;
            }, '');
          }
          else {
            var item = getItem(data);
            var value;
            if (typeof item === 'object') {
              value = $interpolate(component.template)({item: item});
            }
            else {
              value = item;
            }
            return value;
          }
        },
        controller: [
          '$rootScope',
          '$scope',
          '$http',
          'Formio',
          '$interpolate',
          '$q',
          '$timeout',
          function(
            $rootScope,
            $scope,
            $http,
            Formio,
            $interpolate,
            $q,
            $timeout
          ) {
            // FOR-71 - Skip functionality in the builder view.
            if ($scope.builder) return;
            var settings = $scope.component;
            var options = {};
            $scope.nowrap = true;
            $scope.hasNextPage = false;
            $scope.selectItems = [];

            var initialized = $q.defer();
            initialized.promise.then(function() {
              $scope.$emit('selectLoaded', $scope.component);
            });

            var selectValues = $scope.component.selectValues;
            var valueProp = $scope.component.valueProperty;
            $scope.getSelectItem = function(item) {
              if (!item) {
                return '';
              }
              if (settings.dataSrc === 'values') {
                return item.value;
              }

              // Get the item value.
              var itemValue = valueProp ? _get(item, valueProp) : item;
              if (itemValue === undefined) {
                /* eslint-disable no-console */
                console.warn('Cannot find value property within select: ' + valueProp);
                /* eslint-enable no-console */
              }
              return itemValue;
            };

            $scope.refreshItems = function() {
              return $q.resolve([]);
            };
            $scope.$on('refreshList', function(event, url, input) {
              $scope.refreshItems(input, url);
            });

            var refreshing = false;
            var refreshValue = function() {
              if (refreshing) {
                return;
              }
              refreshing = true;
              var tempData = $scope.data[settings.key];
              $scope.data[settings.key] = settings.multiple ? [] : '';
              if (!settings.clearOnRefresh) {
                $timeout(function() {
                  $scope.data[settings.key] = tempData;
                  refreshing = false;
                  $scope.$emit('selectLoaded', $scope.component);
                });
              }
              else {
                refreshing = false;
                $scope.$emit('selectLoaded', $scope.component);
              }
            };

            // Ensures that the value is within the select items.
            var ensureValue = function() {
              var value = $scope.data[settings.key];
              if (!value) {
                return;
              }
              // Iterate through the list of items and see if our value exists...
              var found = false;
              for (var i=0; i < $scope.selectItems.length; i++) {
                var item = $scope.selectItems[i];
                var selectItem = $scope.getSelectItem(item);
                if (_isEqual(selectItem, value)) {
                  found = true;
                  break;
                }
              }

              // If the item is not found in the select items array, then add it manually.
              if (!found) {
                var itemValue = value;
                if (valueProp) {
                  itemValue = {};
                  _set(itemValue, valueProp, value);
                }
                $scope.selectItems.push(itemValue);
              }
            };

            // Refresh the items when ready.
            var refreshItemsWhenReady = function() {
              initialized.promise.then(function() {
                var refreshPromise = $scope.refreshItems(true);
                if (refreshPromise) {
                  refreshPromise.then(refreshValue);
                }
                else {
                  refreshValue();
                }
              });
            };

            // Add a watch if they wish to refresh on selection of another field.
            if (settings.refreshOn) {
              if (settings.refreshOn === 'data') {
                $scope.$watch('data', refreshItemsWhenReady, true);
                return;
              }

              $scope.$watch('data.' + settings.refreshOn, refreshItemsWhenReady);
              $scope.$watch('submission.data.' + settings.refreshOn, refreshItemsWhenReady);
            }
            else {
              // Watch for the data to be set, and ensure the value is set properly.
              var dataWatch = $scope.$watch('data.' + settings.key, function(value) {
                if (value) {
                  initialized.promise.then(function() {
                    dataWatch();
                    ensureValue();
                    refreshValue();
                  });
                }
              });
            }

            switch (settings.dataSrc) {
              case 'values':
                $scope.selectItems = settings.data.values;
                initialized.resolve();
                break;
              case 'json':
                var items;

                // Set the new result.
                var setResult = function(data, append) {
                  // coerce the data into an array.
                  if (!(data instanceof Array)) {
                    data = [data];
                  }

                  if (data.length < options.params.limit) {
                    $scope.hasNextPage = false;
                  }
                  if (append) {
                    $scope.selectItems = $scope.selectItems.concat(data);
                  }
                  else {
                    $scope.selectItems = data;
                  }
                };

                try {
                  if (typeof $scope.component.data.json === 'string') {
                    items = angular.fromJson($scope.component.data.json);
                  }
                  else if (typeof $scope.component.data.json === 'object') {
                    items = $scope.component.data.json;
                  }
                  else {
                    items = [];
                  }

                  if (selectValues) {
                    // Allow dot notation in the selectValue property.
                    if (selectValues.indexOf('.') !== -1) {
                      var parts = selectValues.split('.');
                      var select = items;
                      for (var i in parts) {
                        select = select[parts[i]];
                      }
                      items = select;
                    }
                    else {
                      items = items[selectValues];
                    }
                  }
                }
                catch (error) {
                  /* eslint-disable no-console */
                  console.warn('Error parsing JSON in ' + $scope.component.key, error);
                  /* eslint-enable no-console */
                  items = [];
                }
                options.params = {
                  limit: $scope.component.limit || 20,
                  skip: 0
                };

                var lastInput;
                $scope.refreshItems = function(input, url, append) {
                  // If they typed in a search, reset skip.
                  if (lastInput !== input) {
                    lastInput = input;
                    options.params.skip = 0;
                  }
                  var selectItems = items;
                  if (input) {
                    selectItems = selectItems.filter(function(item) {
                      // Get the visible string from the interpolated item.
                      var value = $interpolate($scope.component.template)({item: item}).replace(/<(?:.|\n)*?>/gm, '');
                      switch ($scope.component.filter) {
                        case 'startsWith':
                          return value.toLowerCase().indexOf(input.toLowerCase()) !== -1;
                        case 'contains':
                        default:
                          return value.toLowerCase().lastIndexOf(input.toLowerCase(), 0) === 0;
                      }
                    });
                  }
                  options.params.skip = parseInt(options.params.skip, 10);
                  options.params.limit = parseInt(options.params.limit, 10);
                  selectItems = selectItems.slice(options.params.skip, options.params.skip + options.params.limit);
                  setResult(selectItems, append);
                  return initialized.resolve($scope.selectItems);
                };
                $scope.refreshItems();
                break;
              case 'custom':
                $scope.refreshItems = function() {
                  try {
                    /* eslint-disable no-unused-vars */
                    var data = _cloneDeep($scope.submission.data);
                    var row = _cloneDeep($scope.data);
                    /* eslint-enable no-unused-vars */
                    $scope.selectItems = eval('(function(data, row) { var values = [];' + settings.data.custom.toString() + '; return values; })(data, row)');
                  }
                  catch (error) {
                    $scope.selectItems = [];
                  }
                  return initialized.resolve($scope.selectItems);
                };
                $scope.refreshItems();
                break;
              case 'url':
              case 'resource':
                var url = '';
                if (settings.dataSrc === 'url') {
                  url = settings.data.url;
                  if (url.substr(0, 1) === '/') {
                    url = Formio.getBaseUrl() + settings.data.url;
                  }

                  // Disable auth for outgoing requests.
                  if (!settings.authenticate && url.indexOf(Formio.getBaseUrl()) === -1) {
                    options.disableJWT = true;
                    options.headers = options.headers || {};
                    options.headers.Authorization = undefined;
                    options.headers.Pragma = undefined;
                    options.headers['Cache-Control'] = undefined;
                  }
                }
                else {
                  url = Formio.getBaseUrl();
                  if (settings.data.project) {
                    url += '/project/' + settings.data.project;
                  }
                  url += '/form/' + settings.data.resource + '/submission';
                }

                options.params = {
                  limit: $scope.component.limit || 100,
                  skip: 0
                };

                $scope.loadMoreItems = function($select, $event) {
                  $event.stopPropagation();
                  $event.preventDefault();
                  options.params.skip = parseInt(options.params.skip, 10);
                  options.params.skip += parseInt(options.params.limit, 10);
                  $scope.refreshItems(true, null, true);
                };

                if (url) {
                  $scope.hasNextPage = true;
                  $scope.refreshItems = function(input, newUrl, append) {
                    if (!input) {
                      return;
                    }

                    newUrl = newUrl || url;
                    newUrl = $interpolate(newUrl)({
                      data: $scope.data,
                      formioBase: $rootScope.apiBase || 'https://api.form.io'
                    });
                    if (!newUrl) {
                      return;
                    }

                    // If this is a search, then add that to the filter.
                    if (
                      settings.searchField &&
                      (typeof input === 'string') &&
                      input
                    ) {
                      newUrl += ((newUrl.indexOf('?') === -1) ? '?' : '&') +
                        encodeURIComponent(settings.searchField) +
                        '=' +
                        encodeURIComponent(input);
                    }

                    // Add the other filter.
                    if (settings.filter) {
                      var filter = $interpolate(settings.filter)({data: $scope.data});
                      newUrl += ((newUrl.indexOf('?') === -1) ? '?' : '&') + filter;
                    }

                    // If they wish to return only some fields.
                    if (settings.selectFields) {
                      options.params.select = settings.selectFields;
                    }

                    // Set the new result.
                    var setResult = function(data) {
                      // coerce the data into an array.
                      if (!(data instanceof Array)) {
                        data = [data];
                      }

                      if (data.length < options.params.limit) {
                        $scope.hasNextPage = false;
                      }
                      if (append) {
                        $scope.selectItems = $scope.selectItems.concat(data);
                      }
                      else {
                        $scope.selectItems = data;
                      }

                      // Ensure the value is set to what it should be set to.
                      ensureValue();
                    };

                    return $http.get(newUrl, options).then(function(result) {
                      var data = result.data;
                      if (data) {
                        // If the selectValue prop is defined, use it.
                        if (selectValues) {
                          setResult(_get(data, selectValues, []));
                        }
                        // Attempt to default to the formio settings for a resource.
                        else if (data.hasOwnProperty('data')) {
                          setResult(data.data);
                        }
                        else if (data.hasOwnProperty('items')) {
                          setResult(data.items);
                        }
                        // Use the data itself.
                        else {
                          setResult(data);
                        }
                      }
                      return $scope.selectItems;
                    }).finally(function() {
                      initialized.resolve($scope.selectItems);
                    });
                  };
                  $scope.refreshItems(true);
                }
                ensureValue();
                break;
              default:
                $scope.selectItems = [];
                initialized.resolve($scope.selectItems);
            }
          }
        ],
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'selectField',
          placeholder: '',
          data: {
            values: [],
            json: '',
            url: '',
            resource: '',
            custom: ''
          },
          dataSrc: 'values',
          valueProperty: '',
          defaultValue: '',
          refreshOn: '',
          filter: '',
          authenticate: false,
          template: '<span>{{ item.label }}</span>',
          multiple: false,
          protected: false,
          unique: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/select.html',
        "<label ng-if=\"component.label && !component.hideLabel\"  for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\n<span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\n<ui-select\n  ui-select-required\n  ui-select-open-on-focus\n  ng-model=\"data[component.key]\"\n  safe-multiple-to-single\n  name=\"{{ componentId }}\"\n  ng-disabled=\"readOnly\"\n  ng-required=\"isRequired(component)\"\n  id=\"{{ componentId }}\"\n  theme=\"bootstrap\"\n  custom-validator=\"component.validate.custom\"\n  tabindex=\"{{ component.tabindex || 0 }}\"\n>\n  <ui-select-match class=\"ui-select-match\" placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\">\n    <formio-select-item template=\"component.template\" item=\"$item || $select.selected\" select=\"$select\"></formio-select-item>\n  </ui-select-match>\n  <ui-select-choices class=\"ui-select-choices\" repeat=\"getSelectItem(item) as item in selectItems | filter: $select.search\" refresh=\"refreshItems($select.search)\" refresh-delay=\"250\">\n    <formio-select-item template=\"component.template\" item=\"item\" select=\"$select\"></formio-select-item>\n    <button ng-if=\"hasNextPage && ($index == $select.items.length-1)\" class=\"btn btn-success btn-block\" ng-click=\"loadMoreItems($select, $event)\" ng-disabled=\"selectLoading\">Load more...</button>\n  </ui-select-choices>\n</ui-select>\n<div ng-if=\"!!component.description\" class=\"help-block\">\n  <span>{{ component.description }}</span>\n</div>\n<formio-errors ng-if=\"::!builder\"></formio-errors>\n"
      );

      // Change the ui-select to ui-select multiple.
      $templateCache.put('formio/components/select-multiple.html',
        $templateCache.get('formio/components/select.html').replace('<ui-select', '<ui-select multiple')
      );
    }
  ]);
};

},{"lodash/cloneDeep":143,"lodash/get":146,"lodash/isEqual":153,"lodash/set":164}],198:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.directive('formioSelectBoxes', [function() {
    return {
      restrict: 'E',
      replace: true,
      require: 'ngModel',
      scope: {
        component: '=',
        componentId: '=',
        readOnly: '=',
        model: '=ngModel',
        gridRow: '=',
        gridCol: '=',
        builder: '=?'
      },
      templateUrl: 'formio/components/selectboxes-directive.html',
      link: function($scope, el, attrs, ngModel) {
        if ($scope.builder) return;
        // Initialize model
        var model = {};
        angular.forEach($scope.component.values, function(v) {
          model[v.value] = ngModel.$viewValue.hasOwnProperty(v.value)
            ? !!ngModel.$viewValue[v.value]
            : false;
        });
        // FA-835 - Update the view model with our defaults.
        // FA-921 - Attempt to load a current model, if present before the defaults.
        ngModel.$setViewValue($scope.model || model);

        ngModel.$setPristine(true);
        ngModel.$isEmpty = function(value) {
          if (typeof value === 'undefined') {
            return true;
          }

          return Object.keys(value).every(function(key) {
            return !value[key];
          });
        };

        $scope.toggleCheckbox = function(value) {
          var _model = angular.copy(ngModel.$viewValue || {});
          _model[value] = !_model[value];
          ngModel.$setViewValue(_model);
        };
      }
    };
  }]);

  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('selectboxes', {
        title: 'Select Boxes',
        template: 'formio/components/selectboxes.html',
        tableView: function(data, component) {
          if (!data) return '';

          return Object.keys(data)
          .filter(function(key) {
            return data[key];
          })
          .map(function(data) {
            component.values.forEach(function(item) {
              if (item.value === data) {
                data = item.label;
              }
            });
            return data;
          })
          .join(', ');
        },
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'selectboxesField',
          values: [],
          inline: false,
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false
          }
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/selectboxes-directive.html',
        "<div class=\"select-boxes\">\n  <div ng-class=\"component.inline ? 'checkbox-inline' : 'checkbox'\" ng-repeat=\"v in component.values track by $index\">\n    <label class=\"control-label\" for=\"{{ componentId }}-{{ v.value }}\">\n      <input type=\"checkbox\"\n        id=\"{{ componentId }}-{{ v.value }}\"\n        name=\"{{ componentId }}-{{ v.value }}\"\n        value=\"{{ v.value }}\"\n        tabindex=\"{{ component.tabindex || 0 }}\"\n        ng-disabled=\"readOnly\"\n        ng-click=\"toggleCheckbox(v.value)\"\n        ng-checked=\"model[v.value]\"\n        grid-row=\"gridRow\"\n        grid-col=\"gridCol\"\n      >\n      {{ v.label | formioTranslate:null:builder }}\n    </label>\n  </div>\n</div>\n"
      );
      $templateCache.put('formio/components/selectboxes.html',
        "<div class=\"select-boxes\">\n  <label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">\n    {{ component.label }}\n  </label>\n  <formio-select-boxes\n    name=\"{{componentId}}\"\n    ng-model=\"data[component.key]\"\n    ng-model-options=\"{allowInvalid: true}\"\n    component=\"component\"\n    component-id=\"componentId\"\n    read-only=\"readOnly\"\n    ng-required=\"isRequired(component)\"\n    custom-validator=\"component.validate.custom\"\n    grid-row=\"gridRow\"\n    grid-col=\"gridCol\"\n    builder=\"builder\"\n  ></formio-select-boxes>\n  <div ng-if=\"!!component.description\" class=\"help-block\">\n    <span>{{ component.description }}</span>\n  </div>\n  <formio-errors ng-if=\"::!builder\"></formio-errors>\n</div>\n"
      );
    }
  ]);
};

},{}],199:[function(_dereq_,module,exports){
"use strict";

var SignaturePad = _dereq_('signature_pad');
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('signature', {
        title: 'Signature',
        template: 'formio/components/signature.html',
        tableView: function(data) {
          return data ? 'Yes' : 'No';
        },
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'signature',
          placeholder: '',
          footer: 'Sign above',
          width: '100%',
          height: '150',
          penColor: 'black',
          backgroundColor: 'rgb(245,245,235)',
          minWidth: '0.5',
          maxWidth: '2.5',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false
          }
        },
        viewTemplate: 'formio/componentsView/signature.html'
      });
    }
  ]);
  app.directive('signature', function() {
    return {
      restrict: 'A',
      scope: {
        component: '='
      },
      require: '?ngModel',
      link: function(scope, element, attrs, ngModel) {
        if (scope.builder) return;
        if (!ngModel) {
          return;
        }

        // Sets the label of component for error display.
        scope.component.label = 'Signature';
        scope.component.hideLabel = true;

        // Sets the dimension of a width or height.
        var setDimension = function(dim) {
          var param = (dim === 'width') ? 'clientWidth' : 'clientHeight';
          if (scope.component[dim].slice(-1) === '%') {
            var percent = parseFloat(scope.component[dim].slice(0, -1)) / 100;
            element[0][dim] = element.parent().eq(0)[0][param] * percent;
          }
          else {
            element[0][dim] = parseInt(scope.component[dim], 10);
            scope.component[dim] = element[0][dim] + 'px';
          }
        };

        // Set the width and height of the canvas.
        // Reset size if element changes visibility.
        scope.$watch('component.display', function() {
          setDimension('width');
          setDimension('height');
        });

        // Create the signature pad.
        var signaturePad = new SignaturePad(element[0], {
          minWidth: scope.component.minWidth,
          maxWidth: scope.component.maxWidth,
          penColor: scope.component.penColor,
          backgroundColor: scope.component.backgroundColor
        });

        scope.$watch('component.penColor', function(newValue) {
          signaturePad.penColor = newValue;
        });

        scope.$watch('component.backgroundColor', function(newValue) {
          signaturePad.backgroundColor = newValue;
          signaturePad.clear();
        });

        // Clear the signature.
        scope.component.clearSignature = function() {
          signaturePad.clear();
          readSignature();
        };

        // Set some CSS properties.
        element.css({
          'border-radius': '4px',
          'box-shadow': '0 0 5px rgba(0, 0, 0, 0.02) inset',
          'border': '1px solid #f4f4f4'
        });

        function readSignature() {
          if (scope.$parent.isRequired(scope.component) && signaturePad.isEmpty()) {
            ngModel.$setViewValue('');
          }
          else {
            ngModel.$setViewValue(signaturePad.toDataURL());
          }
        }

        ngModel.$render = function() {
          signaturePad.fromDataURL(ngModel.$viewValue);
        };
        signaturePad.onEnd = function() {
          scope.$evalAsync(readSignature);
        };
      }
    };
  });
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache,
              FormioUtils) {
      $templateCache.put('formio/components/signature.html', FormioUtils.fieldWrap(
        "<div ng-if=\"readOnly\">\n  <div ng-if=\"data[component.key] === 'YES'\">\n    [ Signature is hidden ]\n  </div>\n  <div ng-if=\"data[component.key] !== 'YES'\">\n    <img class=\"signature\" ng-attr-src=\"{{data[component.key]}}\" src=\"\" />\n  </div>\n</div>\n<div ng-if=\"!readOnly\" style=\"width: {{ component.width }}; height: {{ component.height }};\">\n  <a class=\"btn btn-xs btn-default\" style=\"position:absolute; left: 0; top: 0; z-index: 1000\" ng-click=\"component.clearSignature()\">\n    <span class=\"glyphicon glyphicon-refresh\"></span>\n  </a>\n  <canvas signature component=\"component\" name=\"{{ componentId }}\" ng-model=\"data[component.key]\" ng-required=\"isRequired(component)\"></canvas>\n  <div class=\"formio-signature-footer\" style=\"text-align: center;color:#C3C3C3;\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.footer | formioTranslate:null:builder }}</div>\n</div>\n"
      ));

      $templateCache.put('formio/componentsView/signature.html', FormioUtils.fieldWrap(
        "<div ng-if=\"data[component.key] === 'YES'\">\n  [ Signature is hidden ]\n</div>\n<div ng-if=\"data[component.key] && (data[component.key] !== 'YES')\">\n  <img class=\"signature\" ng-attr-src=\"{{ data[component.key] }}\" src=\"\" />\n</div>\n<div class=\"well text-center\" ng-if=\"!data[component.key] || (data[component.key] === 'NO')\">\n  <strong>No signature provided</strong>\n</div>\n"
      ));
    }
  ]);
};

},{"signature_pad":170}],200:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('survey', {
        title: 'Survey',
        template: 'formio/components/survey.html',
        group: 'advanced',
        tableView: function(data, component) {
          var view = '<table class="table table-striped table-bordered"><thead>';
          var values = {};
          angular.forEach(component.values, function(v) {
            values[v.value] = v.label;
          });
          angular.forEach(component.questions, function(question) {
            view += '<tr>';
            view += '<th>' + question.label + '</th>';
            view += '<td>' + values[data[question.value]] + '</td>';
            view += '</tr>';
          });
          view += '</tbody></table>';
          return view;
        },
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'survey',
          questions: [],
          values: [],
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            custom: '',
            customPrivate: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/survey.html', FormioUtils.fieldWrap(
        "<table class=\"table table-striped table-bordered\">\n  <thead>\n    <tr>\n      <td></td>\n      <th ng-repeat=\"v in component.values track by $index\" style=\"text-align: center;\">{{ v.label }}</th>\n    </tr>\n  </thead>\n  <tr ng-repeat=\"question in component.questions\">\n    <td>{{ question.label }}</td>\n    <td ng-repeat=\"v in component.values track by $index\" style=\"text-align: center;\">\n      <input\n        type=\"radio\"\n        id=\"{{ componentId }}-{{ question.value }}-{{ v.value }}\" name=\"{{ componentId }}-{{ question.value }}\"\n        tabindex=\"{{ component.tabindex || 0 }}\"\n        ng-value=\"v.value\"\n        ng-model=\"data[component.key][question.value]\"\n        ng-required=\"isRequired(component)\"\n        ng-disabled=\"readOnly\"\n        custom-validator=\"component.validate.custom\"\n      >\n    </td>\n  </tr>\n</table>\n"
      ));
    }
  ]);
};

},{}],201:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('table', {
        title: 'Table',
        template: 'formio/components/table.html',
        group: 'layout',
        settings: {
          input: false,
          key: 'table',
          numRows: 3,
          numCols: 3,
          rows: [[{components: []}, {components: []}, {components: []}], [{components: []}, {components: []}, {components: []}], [{components: []}, {components: []}, {components: []}]],
          header: [],
          caption: '',
          striped: false,
          bordered: false,
          hover: false,
          condensed: false
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      var tableClasses = "{'table-striped': component.striped, ";
      tableClasses += "'table-bordered': component.bordered, ";
      tableClasses += "'table-hover': component.hover, ";
      tableClasses += "'table-condensed': component.condensed}";
      $templateCache.put('formio/components/table.html',
        "<div class=\"table-responsive\" id=\"{{ component.key }}\">\n  <table ng-class=\"{'table-striped': component.striped, 'table-bordered': component.bordered, 'table-hover': component.hover, 'table-condensed': component.condensed}\" class=\"table\">\n    <thead ng-if=\"component.header.length\">\n      <th ng-repeat=\"header in component.header track by $index\">{{ header | formioTranslate:null:builder }}</th>\n    </thead>\n    <tbody>\n      <tr ng-repeat=\"row in component.rows track by $index\">\n        <td ng-repeat=\"column in row track by $index\">\n          <formio-component\n            ng-repeat=\"_component in column.components track by $index\"\n            component=\"_component\"\n            data=\"data\"\n            formio=\"formio\"\n            submission=\"submission\"\n            hide-components=\"hideComponents\"\n            ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n            formio-form=\"formioForm\"\n            read-only=\"isDisabled(_component, data)\"\n            grid-row=\"gridRow\"\n            grid-col=\"gridCol\"\n            builder=\"builder\"\n          ></formio-component>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n"
      );

      $templateCache.put('formio/componentsView/table.html',
        "<div class=\"table-responsive\" id=\"{{ component.key }}\">\n  <table ng-class=\"{'table-striped': component.striped, 'table-bordered': component.bordered, 'table-hover': component.hover, 'table-condensed': component.condensed}\" class=\"table\">\n    <thead ng-if=\"component.header.length\">\n      <th ng-repeat=\"header in component.header track by $index\">{{ header }}</th>\n    </thead>\n    <tbody>\n      <tr ng-repeat=\"row in component.rows track by $index\">\n        <td ng-repeat=\"column in row track by $index\">\n          <formio-component-view\n            ng-repeat=\"_component in column.components track by $index\"\n            component=\"_component\"\n            data=\"data\"\n            form=\"form\"\n            submission=\"submission\"\n            ignore=\"ignore\"\n            ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n            builder=\"builder\"\n          ></formio-component-view>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n"
      );
    }
  ]);
};

},{}],202:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('textarea', {
        title: 'Text Area',
        template: function($scope) {
          if (!$scope.readOnly && $scope.component.wysiwyg) {
            var defaults = {
              toolbarGroups:  [
                {name: 'basicstyles', groups: ['basicstyles', 'cleanup']},
                {name: 'paragraph', groups: ['list', 'indent', 'blocks', 'align', 'bidi', 'paragraph', '-', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock']},
                {name: 'links', groups: ['links']},
                {name: 'insert', groups: ['insert']},
                '/',
                {name: 'styles', groups: ['Styles', 'Format', 'Font', 'FontSize']},
                {name: 'colors', groups: ['colors']},
                {name: 'clipboard', groups: ['clipboard', 'undo']},
                {name: 'editing', groups: ['find', 'selection', 'spellchecker', 'editing']},
                {name: 'document', groups: ['mode', 'document', 'doctools']},
                {name: 'others', groups: ['others']},
                {name: 'tools', groups: ['tools']}
              ],
              extraPlugins: 'justify,font',
              removeButtons: 'Cut,Copy,Paste,Underline,Subscript,Superscript,Scayt,About',
              uiColor: '#eeeeee',
              height: '400px',
              width: '100%'
            };
            if ($scope.component.wysiwyg === true) {
              $scope.component.wysiwyg = defaults;
            }
            else {
              $scope.component.wysiwyg = angular.extend(defaults, $scope.component.wysiwyg);
            }
            return 'formio/components/texteditor.html';
          }
          return 'formio/components/textarea.html';
        },
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'textareaField',
          placeholder: '',
          prefix: '',
          suffix: '',
          rows: 3,
          multiple: false,
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          wysiwyg: false,
          clearOnHide: true,
          validate: {
            required: false,
            minLength: '',
            maxLength: '',
            pattern: '',
            custom: ''
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache,
              FormioUtils) {
      $templateCache.put('formio/components/textarea.html', FormioUtils.fieldWrap(
        "<textarea\n  class=\"form-control\"\n  ng-model=\"data[component.key]\"\n  ng-disabled=\"readOnly\"\n  ng-required=\"isRequired(component)\"\n  safe-multiple-to-single\n  id=\"{{ componentId }}\"\n  name=\"{{ componentId }}\"\n  tabindex=\"{{ component.tabindex || 0 }}\"\n  ng-attr-placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\"\n  custom-validator=\"component.validate.custom\"\n  rows=\"{{ component.rows }}\"\n></textarea>\n"
      ));
      $templateCache.put('formio/components/texteditor.html', FormioUtils.fieldWrap(
        "<textarea\n  class=\"form-control\"\n  ng-model=\"data[component.key]\"\n  ng-disabled=\"readOnly\"\n  ng-required=\"isRequired(component)\"\n  ckeditor=\"component.wysiwyg\"\n  safe-multiple-to-single\n  id=\"{{ componentId }}\"\n  name=\"{{ componentId }}\"\n  tabindex=\"{{ component.tabindex || 0 }}\"\n  ng-attr-placeholder=\"{{ component.placeholder }}\"\n  custom-validator=\"component.validate.custom\"\n  rows=\"{{ component.rows }}\"\n></textarea>\n"
      ));
    }
  ]);
};

},{}],203:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('textfield', {
        title: 'Text Field',
        template: 'formio/components/textfield.html',
        icon: 'fa fa-terminal',
        settings: {
          input: true,
          tableView: true,
          inputType: 'text',
          inputMask: '',
          label: '',
          key: 'textField',
          placeholder: '',
          prefix: '',
          suffix: '',
          multiple: false,
          defaultValue: '',
          protected: false,
          unique: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            minLength: '',
            maxLength: '',
            pattern: '',
            custom: '',
            customPrivate: false
          },
          conditional: {
            show: null,
            when: null,
            eq: ''
          }
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    'FormioUtils',
    function(
      $templateCache,
      FormioUtils
    ) {
      $templateCache.put('formio/components/textfield.html', FormioUtils.fieldWrap(
        "<input\n  type=\"{{ component.inputType }}\"\n  class=\"form-control\"\n  id=\"{{ componentId }}\"\n  name=\"{{ componentId }}\"\n  tabindex=\"{{ component.tabindex || 0 }}\"\n  ng-disabled=\"readOnly\"\n  ng-model=\"data[component.key]\"\n  ng-model-options=\"{ debounce: 500 }\"\n  safe-multiple-to-single\n  ng-required=\"isRequired(component)\"\n  ng-minlength=\"component.validate.minLength\"\n  ng-maxlength=\"component.validate.maxLength\"\n  ng-pattern=\"component.validate.pattern\"\n  custom-validator=\"component.validate.custom\"\n  ng-attr-placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\"\n  ui-mask=\"{{ component.inputMask }}\"\n  ui-mask-placeholder=\"\"\n  ui-options=\"uiMaskOptions\"\n>\n"
      ));
    }
  ]);
};

},{}],204:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('well', {
        title: 'Well',
        template: 'formio/components/well.html',
        group: 'layout',
        settings: {
          key: 'well',
          input: false,
          components: []
        },
        viewTemplate: 'formio/componentsView/well.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/well.html',
        "<div class=\"well\" id=\"{{ component.key }}\">\n  <formio-component\n    ng-repeat=\"_component in component.components track by $index\"\n    component=\"_component\"\n    data=\"data\"\n    formio=\"formio\"\n    submission=\"submission\"\n    hide-components=\"hideComponents\"\n    ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n    read-only=\"isDisabled(_component, data)\"\n    formio-form=\"formioForm\"\n    grid-row=\"gridRow\"\n    grid-col=\"gridCol\"\n    builder=\"builder\"\n  ></formio-component>\n</div>\n"
      );
      $templateCache.put('formio/componentsView/well.html',
        "<div class=\"well\" id=\"{{ component.key }}\">\n  <formio-component-view\n    ng-repeat=\"_component in component.components track by $index\"\n    component=\"_component\"\n    data=\"data\"\n    form=\"form\"\n    submission=\"submission\"\n    ignore=\"ignore\"\n    ng-if=\"builder ? '::true' : isVisible(_component, data)\"\n    builder=\"builder\"\n  ></formio-component-view>\n</div>\n"
      );
    }
  ]);
};

},{}],205:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function(scope, ele, attrs, ctrl) {
      if (scope.builder) return;
      if (
        !scope.component.validate ||
        !scope.component.validate.custom
      ) {
        return;
      }

      var _get = function(item, path, def) {
        if (!item) {
          return def || undefined;
        }
        if (!path) {
          return item;
        }

        // If the path is a string, turn it into an array.
        if (typeof path === 'string') {
          path = path.split('.');
        }
        // If the path is an array, take the first element, and recurse its path
        if (path instanceof Array) {
          var current = path.shift();
          if (item.hasOwnProperty(current)) {
            // If there are no more path items, stop here.
            if (path.length === 0) {
              return item[current];
            }

            return _get(item[current], path);
          }

          return undefined;
        }

        return undefined;
      };

      ctrl.$validators.custom = function(modelValue, viewValue) {
        var valid = true;
        /*eslint-disable no-unused-vars */
        var input = modelValue || viewValue;

        // FOR-255 - Enable row data and form data to be visible in the validator.
        var data = scope.submission.data;
        var row = scope.data;
        /*eslint-enable no-unused-vars */

        var custom = scope.component.validate.custom;
        custom = custom.replace(/({{\s{0,}(.*[^\s]){1}\s{0,}}})/g, function(match, $1, $2) {
          return _get(scope.submission.data, $2);
        });

        try {
          /* jshint evil: true */
          eval(custom);
        }
        catch (err) {
          valid = err.message;
        }

        if (valid !== true) {
          scope.component.customError = valid;
          return false;
        }
        return true;
      };
    }
  };
};

},{}],206:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      src: '=?',
      url: '=?',
      formAction: '=?',
      form: '=?',
      submission: '=?',
      readOnly: '=?',
      hideComponents: '=?',
      requireComponents: '=?',
      disableComponents: '=?',
      formioOptions: '=?',
      options: '=?'
    },
    controller: [
      '$scope',
      '$http',
      '$element',
      'FormioScope',
      'Formio',
      'FormioUtils',
      '$q',
      function(
        $scope,
        $http,
        $element,
        FormioScope,
        Formio,
        FormioUtils,
        $q
      ) {
        var iframeReady = $q.defer();
        $scope._src = $scope.src || '';
        $scope.formioAlerts = [];
        $scope.iframeReady = false;
        // Shows the given alerts (single or array), and dismisses old alerts
        this.showAlerts = $scope.showAlerts = function(alerts) {
          $scope.formioAlerts = [].concat(alerts);
        };

        $scope.getIframeSrc = function(pdf) {
          var iframeSrc = pdf.src + '.html';
          var params = [];
          if ($scope.form.builder) {
            params.push('builder=1');
          }
          if ($scope.readOnly) {
            params.push('readonly=1');
          }
          if (params.length) {
            iframeSrc += '?' + params.join('&');
          }
          return iframeSrc;
        };

        $scope.downloadUrl = '';

        $scope.getPDFDownload = function(pdf) {
          if (!$scope.formio) {
            return;
          }
          var download = '';
          if ($scope.formio && $scope.formio.submissionUrl) {
            download = $scope.formio.submissionUrl;
          }
          else if ($scope.submission._id) {
            download = Formio.baseUrl + '/project/' + $scope.form.project + '/';
            download += '/form/' + $scope.form._id;
            download += '/submission/' + $scope.submission._id;
          }
          if (!download) {
            return;
          }

          download += '/download/' + pdf.id;
          var allowedPath = download.replace(Formio.baseUrl, '');
          allowedPath = allowedPath.replace(Formio.getProjectUrl(), '');
          return $scope.formio.getTempToken(3600, 'GET:' + allowedPath).then(function(tempToken) {
            download += '?token=' + tempToken.key;
            $scope.downloadUrl = download;
            return download;
          });
        };

        // Add the live form parameter to the url.
        if ($scope._src && ($scope._src.indexOf('live=') === -1)) {
          $scope._src += ($scope._src.indexOf('?') === -1) ? '?' : '&';
          $scope._src += 'live=1';
        }

        var sendIframeMessage = function(message) {
          iframeReady.promise.then(function(iframe) {
            iframe.contentWindow.postMessage(JSON.stringify(message), '*');
          });
        };

        $scope.$on('iframe-ready', function() {
          $scope.iframeReady = true;
          var iframe = $element.find('.formio-iframe')[0];
          if (iframe) {
            iframeReady.resolve(iframe);
            if ($scope.form) {
              sendIframeMessage({name: 'form', data: $scope.form});
            }
            if ($scope.submission) {
              sendIframeMessage({name: 'submission', data: $scope.submission});
            }
          }
        });

        $scope.$on('iframeMessage', function(event, message) {
          sendIframeMessage(message);
        });

        var cancelFormLoadEvent = $scope.$on('formLoad', function(event, form) {
          cancelFormLoadEvent();
          iframeReady.promise.then(function() {
            $scope.getPDFDownload(form.settings.pdf);
          });
          sendIframeMessage({name: 'form', data: form});
        });

        $scope.$on('submissionLoad', function(event, submission) {
          submission.editable = !$scope.readOnly;
          sendIframeMessage({name: 'submission', data: submission});
        });

        // Submit the form from the iframe.
        $scope.$on('iframe-submission', function(event, submission) {
          $scope.submitForm(submission);
        });

        // Called from the submit on iframe.
        $scope.submitIFrameForm = function() {
          sendIframeMessage({name: 'getSubmission'});
        };

        $scope.zoomIn = function() {
          sendIframeMessage({name: 'zoomIn'});
        };

        $scope.zoomOut = function() {
          sendIframeMessage({name: 'zoomOut'});
        };

        // FOR-71
        if (!$scope._src && !$scope.builder) {
          $scope.$watch('src', function(src) {
            if (!src) {
              return;
            }
            $scope._src = src;
            $scope.formio = FormioScope.register($scope, $element, {
              form: true,
              submission: true
            });
          });
        }

        // Create the formio object.
        $scope.formio = FormioScope.register($scope, $element, {
          form: true,
          submission: true
        });

        $scope.checkErrors = function(form) {
          if (form.submitting) {
            return true;
          }
          form.$pristine = false;
          for (var key in form) {
            if (form[key] && form[key].hasOwnProperty('$pristine')) {
              form[key].$pristine = false;
            }
          }
          return !form.$valid;
        };

        $scope.isVisible = function(component, row) {
          return FormioUtils.isVisible(
            component,
            row,
            $scope.submission ? $scope.submission.data : null,
            $scope.hideComponents
          );
        };

        // Show the submit message and say the form is no longer submitting.
        var onSubmit = function(submission, message, form) {
          if (message) {
            $scope.showAlerts({
              type: 'success',
              message: message
            });
          }
          if (form) {
            form.submitting = false;
          }
        };

        // Called when a submission has been made.
        var onSubmitDone = function(method, submission, form) {
          var message = '';
          if ($scope.options && $scope.options.submitMessage) {
            message = $scope.options.submitMessage;
          }
          else {
            message = 'Submission was ' + ((method === 'put') ? 'updated' : 'created') + '.';
          }
          onSubmit(submission, message, form);
          // Trigger the form submission.
          $scope.$emit('formSubmission', submission);
        };

        $scope.submitForm = function(submissionData, form) {
          // Allow custom action urls.
          if ($scope.action) {
            var method = submissionData._id ? 'put' : 'post';
            var action = $scope.action;
            // Add the action Id if it is not already part of the url.
            if (method === 'put' && (action.indexOf(submissionData._id) === -1)) {
              action += '/' + submissionData._id;
            }
            $http[method](action, submissionData).then(function(submission) {
              Formio.clearCache();
              onSubmitDone(method, submission, form);
            }, FormioScope.onError($scope, $element))
              .finally(function() {
                if (form) {
                  form.submitting = false;
                }
              });
          }

          // If they wish to submit to the default location.
          else if ($scope.formio && !$scope.formio.noSubmit) {
            // copy to remove angular $$hashKey
            $scope.formio.saveSubmission(submissionData, $scope.formioOptions).then(function(submission) {
              onSubmitDone(submission.method, submission, form);
            }, FormioScope.onError($scope, $element)).finally(function() {
              if (form) {
                form.submitting = false;
              }
            });
          }
          else {
            $scope.$emit('formSubmission', submissionData);
          }
        };

        $scope.isDisabled = function(component) {
          return $scope.readOnly || component.disabled || (Array.isArray($scope.disableComponents) && $scope.disableComponents.indexOf(component.key) !== -1);
        };

        $scope.isRequired = function(component) {
          return FormioUtils.isRequired(component, $scope.requireComponents);
        };

        // Called when the form is submitted.
        $scope.onSubmit = function(form) {
          $scope.formioAlerts = [];
          if ($scope.checkErrors(form)) {
            $scope.formioAlerts.push({
              type: 'danger',
              message: 'Please fix the following errors before submitting.'
            });
            return;
          }

          form.submitting = true;

          // Create a sanitized submission object.
          var submissionData = {data: {}};
          if ($scope.submission._id) {
            submissionData._id = $scope.submission._id;
          }
          if ($scope.submission.data._id) {
            submissionData._id = $scope.submission.data._id;
          }

          var grabIds = function(input) {
            if (!input) {
              return [];
            }

            if (!(input instanceof Array)) {
              input = [input];
            }

            var final = [];
            input.forEach(function(element) {
              if (element && element._id) {
                final.push(element._id);
              }
            });

            return final;
          };

          var defaultPermissions = {};
          FormioUtils.eachComponent($scope.form.components, function(component) {
            if (component.type === 'resource' && component.key && component.defaultPermission) {
              defaultPermissions[component.key] = component.defaultPermission;
            }
            if ($scope.submission.data.hasOwnProperty(component.key)) {
              var value = $scope.submission.data[component.key];
              if (component.type === 'number' && (value !== null)) {
                submissionData.data[component.key] = value ? parseFloat(value) : 0;
              }
              else {
                submissionData.data[component.key] = value;
              }
            }
          }, true);

          angular.forEach($scope.submission.data, function(value, key) {
            if (value && !value.hasOwnProperty('_id')) {
              submissionData.data[key] = value;
            }

            // Setup the submission access.
            var perm = defaultPermissions[key];
            if (perm) {
              submissionData.access = submissionData.access || [];

              // Coerce value into an array for plucking.
              if (!(value instanceof Array)) {
                value = [value];
              }

              // Try to find and update an existing permission.
              var found = false;
              submissionData.access.forEach(function(permission) {
                if (permission.type === perm) {
                  found = true;
                  permission.resources = permission.resources || [];
                  permission.resources.concat(grabIds(value));
                }
              });

              // Add a permission, because one was not found.
              if (!found) {
                submissionData.access.push({
                  type: perm,
                  resources: grabIds(value)
                });
              }
            }
          });

          // Allow the form to be completed externally.
          $scope.$on('submitDone', function(event, submission, message) {
            onSubmit(submission, message, form);
          });

          // Allow an error to be thrown externally.
          $scope.$on('submitError', function(event, error) {
            FormioScope.onError($scope, $element)(error);
          });

          var submitEvent = $scope.$emit('formSubmit', submissionData);
          if (submitEvent.defaultPrevented) {
            // Listener wants to cancel the form submission
            form.submitting = false;
            return;
          }

          // Make sure to make a copy of the submission data to remove bad characters.
          submissionData = angular.copy(submissionData);
          $scope.submitForm(submissionData, form);
        };
      }
    ],
    templateUrl: 'formio.html'
  };
};

},{}],207:[function(_dereq_,module,exports){
"use strict";
module.exports = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
  return {
    restrict: 'A',
    compile: function formioBindHtmlCompile(tElement, tAttrs) {
      var formioBindHtmlGetter = $parse(tAttrs.formioBindHtml);
      $compile.$$addBindingClass(tElement);
      return function formioBindHtmlLink(scope, element, attr) {
        $compile.$$addBindingInfo(element, attr.formioBindHtml);
        var value = formioBindHtmlGetter(scope);
        element.html($sce.getTrustedHtml(value) || '');
      };
    }
  };
}];

},{}],208:[function(_dereq_,module,exports){
"use strict";
var _cloneDeep = _dereq_('lodash/cloneDeep');
var _filter = _dereq_('lodash/filter');
var _get = _dereq_('lodash/get');

// FOR-524 - Attempt to load json logic.
var jsonLogic;
try {
  jsonLogic = _dereq_('json-logic-js') || undefined;
}
catch (e) {
  // Ignore optional module.
}

module.exports = [
  'Formio',
  'formioComponents',
  function(
    Formio,
    formioComponents
  ) {
    return {
      replace: true,
      restrict: 'E',
      require: '?^formio',
      scope: {
        component: '=',
        data: '=',
        submission: '=',
        hideComponents: '=',
        formio: '=',
        formioForm: '=',
        readOnly: '=',
        gridRow: '=',
        gridCol: '=',
        builder: '=?'
      },
      templateUrl: 'formio/component.html',
      link: function(scope, el, attrs, formioCtrl) {
        if (formioCtrl) {
          scope.showAlerts = formioCtrl.showAlerts.bind(formioCtrl);
        }
        else {
          scope.showAlerts = function() {
            throw new Error('Cannot call $scope.showAlerts unless this component is inside a formio directive.');
          };
        }
      },
      controller: [
        '$scope',
        '$http',
        '$controller',
        'FormioUtils',
        '$timeout',
        function(
          $scope,
          $http,
          $controller,
          FormioUtils,
          $timeout
        ) {
          $scope.builder = $scope.builder || false;
          // Options to match jquery.maskedinput masks
          $scope.uiMaskOptions = {
            maskDefinitions: {
              '9': /\d/,
              'a': /[a-zA-Z]/,
              '*': /[a-zA-Z0-9]/
            },
            clearOnBlur: false,
            eventsToHandle: ['input', 'keyup', 'click', 'focus'],
            silentEvents: ['click', 'focus']
          };

          // See if this component is visible or not.
          $scope.isVisible = function(component, row) {
            if ($scope.builder) return true;
            return FormioUtils.isVisible(
              component,
              row,
              $scope.submission ? $scope.submission.data : null,
              $scope.hideComponents
            );
          };

          // FOR-245 - Fix reset buttons.
          $scope.resetForm = function() {
            // Manually remove each key so we don't lose a reference to original
            // data in child scopes.
            for (var key in $scope.data) {
              delete $scope.data[key];
            }
          };

          $scope.isDisabled = function(component) {
            return $scope.readOnly || (typeof $scope.$parent.isDisabled === 'function' && $scope.$parent.isDisabled(component));
          };

          $scope.isRequired = function(component) {
            return FormioUtils.isRequired(component);
          };

          // Pass through checkConditional since this is an isolate scope.
          $scope.checkConditional = $scope.$parent.checkConditional;

          // FOR-71 - Dont watch in the builder view.
          // Calculate value when data changes.
          if (!$scope.builder && ($scope.component.calculateValue || (jsonLogic && _get($scope.component, 'validate.json')))) {
            $scope.$watch('data', function() {
              // Process calculated value stuff if present.
              if ($scope.component.calculateValue) {
                try {
                  $scope.data[$scope.component.key] = eval('(function(data) { var value = [];' + $scope.component.calculateValue.toString() + '; return value; })($scope.data)');
                }
                catch (e) {
                  /* eslint-disable no-console */
                  console.warn('An error occurred calculating a value for ' + $scope.component.key, e);
                  /* eslint-enable no-console */
                }
              }

              // Process jsonLogic stuff if present.
              if (jsonLogic && _get($scope.component, 'validate.json')) {
                var input;

                // Only json parse once.
                if (typeof $scope.component.validate.json === 'string') {
                  try {
                    input = JSON.parse($scope.component.validate.json);
                    $scope.component.validate.json = input;
                  }
                  catch (e) {
                    /* eslint-disable no-console */
                    console.warn('Invalid JSON validator given for ' + $scope.component.key);
                    console.warn($scope.component.validate.json);
                    /* eslint-enable no-console */
                    delete $scope.component.validate.json;
                    return;
                  }
                }
                else {
                  input = $scope.component.validate.json;
                }

                var valid;
                try {
                  valid = jsonLogic.apply(input, {
                    data: $scope.submission.data,
                    row: $scope.data
                  });
                }
                catch (err) {
                  valid = err.message;
                }

                $timeout(function() {
                  try {
                    if (valid !== true) {
                      $scope.component.customError = valid;
                      $scope.formioForm[$scope.component.key].$setValidity('custom', false);
                      return;
                    }

                    $scope.formioForm[$scope.component.key].$setValidity('custom', true);
                  }
                  catch (e) {
                    // Ignore any issues while editing the components.
                  }
                });
              }
            }, true);
          }

          // Get the settings.
          var component = formioComponents.components[$scope.component.type] || formioComponents.components['custom'];

          // Set the component with the defaults from the component settings.
          // Dont add the default key, so that components without keys will remain visible by default.
          angular.forEach(component.settings, function(value, key) {
            if (!$scope.component.hasOwnProperty(key) && key !== 'key') {
              $scope.component[key] = angular.copy(value);
            }
          });

          // Add a new field value.
          $scope.addFieldValue = function() {
            var value = '';
            if ($scope.component.hasOwnProperty('customDefaultValue')) {
              try {
                /* eslint-disable no-unused-vars */
                var data = _cloneDeep($scope.data);
                /* eslint-enable no-unused-vars */
                value = eval('(function(data) { var value = "";' + $scope.component.customDefaultValue.toString() + '; return value; })(data)');
              }
              catch (e) {
                /* eslint-disable no-console */
                console.warn('An error occurrend in a custom default value in ' + $scope.component.key, e);
                /* eslint-enable no-console */
                value = '';
              }
            }
            else if ($scope.component.hasOwnProperty('defaultValue')) {
              // Fix for select components
              if ($scope.component.type === 'select') {
                try {
                  // Allow a key:value search
                  var parts = $scope.component.defaultValue.split(':');
                  var results;
                  // If only one part was specified, search by value
                  /* eslint-disable max-depth */
                  if (parts.length === 1) {
                    results = _filter($scope.selectItems, {value: parts[0]});

                    // Trim results based on multiple
                    if (!$scope.component.multiple) {
                      value = results.shift();
                    }
                    else {
                      value = results;
                    }
                  }
                  // If two parts were specified, allow for key and value customization.
                  else if (parts.length === 2) {
                    var search = {};
                    search[parts[0]] = parts[1];

                    results = _filter($scope.selectItems, search);

                    // Trim results based on multiple
                    if (!$scope.component.multiple) {
                      value = results.shift();
                    }
                    else {
                      value = results;
                    }
                  }
                }
                catch (e) {
                  /* eslint-disable no-console */
                  console.log('An issue occurred with the select defaultValue for: ' + $scope.component.key);
                  console.log('Could not find defaultValue (' + $scope.defaultValue + ') in the selectItems');
                  console.log($scope.selectItems);
                  /* eslint-enable no-console */
                }
              }
              else {
                value = $scope.component.defaultValue;
              }
            }
            $scope.data[$scope.component.key] = $scope.data[$scope.component.key] || [];
            $scope.data[$scope.component.key].push(value);
          };

          // Remove a field value.
          $scope.removeFieldValue = function(index) {
            if (!Array.isArray($scope.data[$scope.component.key])) {
              $scope.data[$scope.component.key] = [];
            }
            $scope.data[$scope.component.key].splice(index, 1);
          };

          // Set the template for the component.
          if (typeof component.template === 'function') {
            $scope.template = component.template($scope);
          }
          else {
            $scope.template = component.template;
          }

          // Allow component keys to look like "settings[username]"
          if ($scope.component.key && $scope.component.key.indexOf('[') !== -1) {
            var matches = $scope.component.key.match(/([^\[]+)\[([^]+)\]/);
            if ((matches.length === 3) && $scope.data.hasOwnProperty(matches[1])) {
              $scope.data = $scope.data[matches[1]];
              $scope.component.key = matches[2];
            }
          }

          // If the component has a controller.
          if (component.controller) {
            // Maintain reverse compatibility by executing the old method style.
            if (typeof component.controller === 'function') {
              component.controller($scope.component, $scope, $http, Formio);
            }
            else {
              $controller(component.controller, {$scope: $scope, $timeout: $timeout});
            }
          }

          // FOR-71 - Dont watch in the builder view.
          if (!$scope.builder) {
            /**
             * Using the list of default options, split them with the identifier, and use filter to get each item.
             *
             * @param defaultItems
             * @param searchItems
             * @returns {Array}
             */
            var pluckItems = function(defaultItems, searchItems) {
              var temp = [];
              if (!defaultItems || !defaultItems.length) {
                return temp;
              }
              if (typeof defaultItems === 'string') {
                defaultItems = [defaultItems];
              }

              defaultItems.forEach(function(item) {
                var parts = item.split(':');
                if (parts.length === 2) {
                  var result = _filter(searchItems, function(potential) {
                    if (_get(potential, parts[0]) === parts[1]) {
                      return true;
                    }
                  });

                  if (result) {
                    temp = temp.concat(result);
                  }
                }
              });

              return temp;
            };

            $scope.$watch('component.multiple', function(mult) {
              // Establish a default for data.
              $scope.data = $scope.data || {};
              var value = null;

              // Use the current data or default.
              if ($scope.data.hasOwnProperty($scope.component.key)) {
                if (!mult) {
                  $scope.data[$scope.component.key] = $scope.data[$scope.component.key];
                  return;
                }

                // If a value is present, and its an array, assign it to the value.
                if ($scope.data[$scope.component.key] instanceof Array) {
                  value = $scope.data[$scope.component.key];
                }
                // If a value is present and it is not an array, wrap the value.
                else {
                  value = $scope.data[$scope.component.key].split(',');
                }

                $scope.data[$scope.component.key] = value;
                return;
              }
              else if ($scope.component.hasOwnProperty('customDefaultValue')) {
                if (!mult) {
                  try {
                    value = eval('(function(data) { var value = "";' + $scope.component.customDefaultValue.toString() + '; return value; })($scope.data)');
                  }
                  catch (e) {
                    /* eslint-disable no-console */
                    console.warn('An error occurrend in a custom default value in ' + $scope.component.key, e);
                    /* eslint-enable no-console */
                    value = '';
                  }
                  $scope.data[$scope.component.key] = value;
                  return;
                }

                try {
                  value = eval('(function(data) { var value = "";' + $scope.component.customDefaultValue.toString() + '; return value; })($scope.data)');
                }
                catch (e) {
                  /* eslint-disable no-console */
                  console.warn('An error occurrend in a custom default value in ' + $scope.component.key, e);
                  /* eslint-enable no-console */
                  value = '';
                }
                $scope.data[$scope.component.key] = value;
                return;
              }
              else if ($scope.component.hasOwnProperty('defaultValue')) {
                // FA-835 - The default values for select boxes are set in the component.
                if ($scope.component.type === 'selectboxes') {
                  return;
                }

                // If there is a default value and it is not an array, wrap the value.
                if (mult && typeof $scope.component.defaultValue === 'string') {
                  value = $scope.component.defaultValue.split(',');
                }
                else {
                  value = $scope.component.defaultValue;
                }

                // If no default is provided, then skip...
                if (!value || !value.length) {
                  return;
                }

                // FOR-193 - Fix default value for the number component.
                // FOR-262 - Fix multiple default value for the number component.
                if ($scope.component.type === 'number') {
                  if (!mult) {
                    // FOR-290 - Fix default values for number components, to allow decimal numbers.
                    if ($scope.component.defaultValue.indexOf('.') !== -1) {
                      $scope.data[$scope.component.key] = parseFloat($scope.component.defaultValue);
                      return;
                    }

                    $scope.data[$scope.component.key] = parseInt($scope.component.defaultValue);
                    return;
                  }

                  $scope.data[$scope.component.key] = value.map(function(item) {
                    try {
                      // FOR-290 - Fix default values for number components, to allow decimal numbers.
                      if (item.indexOf('.') !== -1) {
                        return parseFloat(item);
                      }

                      return parseInt(item);
                    }
                    catch (e) {
                      return 0;
                    }
                  });
                  return;
                }
                // FOR-135 - Add default values for select components.
                else if ($scope.component.type === 'select') {
                  // FOR-337 - Fix default values for select components without multi enabled.
                  if (!mult) {
                    $scope.data[$scope.component.key] = $scope.component.defaultValue;
                    return;
                  }

                  // If using the values input, split the default values, and search the options for each value in the list.
                  if ($scope.component.dataSrc === 'values') {
                    var temp = [];

                    $scope.component.data.values.forEach(function(item) {
                      if (value.indexOf(item.value) !== -1) {
                        temp.push(item);
                      }
                    });

                    $scope.data[$scope.component.key] = temp;
                    return;
                  }
                  // If using json input, split the values and search each key path for the item
                  else if ($scope.component.dataSrc === 'json') {
                    if (typeof $scope.component.data.json === 'string') {
                      try {
                        $scope.component.data.json = JSON.parse($scope.component.data.json);
                      }
                      catch (e) {
                        /* eslint-disable no-console */
                        console.log(e);
                        console.log('Could not parse the given JSON for the select component: ' + $scope.component.key);
                        console.log($scope.component.data.json);
                        /* eslint-enable no-console */
                        $scope.component.data.json = [];
                      }
                    }

                    $scope.data[$scope.component.key] = pluckItems(value, $scope.component.data.json);
                    return;
                  }
                  else if ($scope.component.dataSrc === 'url' || $scope.component.dataSrc === 'resource') {
                    // Wait until loading is done.
                    $scope.$on('selectLoaded', function() {
                      $scope.data[$scope.component.key] = pluckItems(value, $scope.selectItems);
                    });
                  }
                }
                // FOR-504 - Fix default values for survey components.
                else if ($scope.component.type === 'survey') {
                  if (!$scope.component.hasOwnProperty('defaultValue')) {
                    return;
                  }

                  $scope.data[$scope.component.key] = $scope.data[$scope.component.key] || {};
                  $scope.component.questions.forEach(function(question) {
                    $timeout(function() {
                      $scope.data[$scope.component.key][question.value] = $scope.data[$scope.component.key][question.value] || $scope.component.defaultValue;
                    });
                  });
                }
                else {
                  if (!mult) {
                    $scope.data[$scope.component.key] = $scope.component.defaultValue;
                    return;
                  }

                  // If there is a default value and it is an array, assign it to the value.
                  if ($scope.component.defaultValue instanceof Array) {
                    $scope.data[$scope.component.key] = $scope.component.defaultValue;
                    return;
                  }

                  // Make the defaultValue a single element array because were multi.
                  $scope.data[$scope.component.key] = [$scope.component.defaultValue];
                  return;
                }
              }

              // Couldn't safely default, don't add a garbage value.
              return;
            });
          }

          // Set the component name.
          $scope.componentId = $scope.component.key;
          if ($scope.gridRow !== undefined) {
            $scope.componentId += ('-' + $scope.gridRow);
          }
          if ($scope.gridCol !== undefined) {
            $scope.componentId += ('-' + $scope.gridCol);
          }
        }
      ]
    };
  }
];

},{"json-logic-js":10,"lodash/cloneDeep":143,"lodash/filter":145,"lodash/get":146}],209:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'formioComponents',
  function(
    formioComponents
  ) {
    return {
      replace: true,
      restrict: 'E',
      scope: {
        component: '=',
        data: '=',
        form: '=',
        submission: '=',
        ignore: '=?',
        builder: '=?'
      },
      templateUrl: 'formio/component-view.html',
      controller: [
        '$scope',
        'Formio',
        'FormioUtils',
        function(
          $scope,
          Formio,
          FormioUtils
        ) {
          // Set the form url.
          $scope.formUrl = $scope.form ? Formio.getAppUrl() + '/form/' + $scope.form._id.toString() : '';
          $scope.isVisible = function(component, row) {
            return FormioUtils.isVisible(
              component,
              row,
              $scope.submission ? $scope.submission.data : null,
              $scope.hideComponents
            );
          };

          // Get the settings.
          var component = formioComponents.components[$scope.component.type] || formioComponents.components['custom'];

          // Set the template for the component.
          if (!component.viewTemplate) {
            $scope.template = 'formio/element-view.html';
          }
          else if (typeof component.viewTemplate === 'function') {
            $scope.template = component.viewTemplate($scope);
          }
          else {
            $scope.template = component.viewTemplate;
          }

          // Set the component name.
          $scope.componentId = $scope.component.key;
          if ($scope.gridRow !== undefined) {
            $scope.componentId += ('-' + $scope.gridRow);
          }
          if ($scope.gridCol !== undefined) {
            $scope.componentId += ('-' + $scope.gridCol);
          }
        }
      ]
    };
  }
];

},{}],210:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      form: '=?',
      submission: '=?',
      src: '=?',
      formAction: '=?',
      resourceName: '=?',
      message: '=?'
    },
    templateUrl: 'formio-delete.html',
    controller: [
      '$scope',
      '$element',
      'FormioScope',
      'Formio',
      '$http',
      function(
        $scope,
        $element,
        FormioScope,
        Formio,
        $http
      ) {
        $scope._src = $scope.src || '';
        $scope.formioAlerts = [];
        // Shows the given alerts (single or array), and dismisses old alerts
        $scope.showAlerts = function(alerts) {
          $scope.formioAlerts = [].concat(alerts);
        };
        var resourceName = 'resource';
        var methodName = '';
        var loader = FormioScope.register($scope, $element, {
          form: true,
          submission: true
        });

        if (loader) {
          resourceName = loader.submissionId ? 'submission' : 'form';
          var resourceTitle = resourceName.charAt(0).toUpperCase() + resourceName.slice(1);
          methodName = 'delete' + resourceTitle;
        }

        // Set the resource name
        $scope._resourceName = $scope.resourceName || resourceName;
        $scope.deleteMessage = $scope.message || 'Are you sure you wish to delete the ' + $scope._resourceName + '?';

        // Create delete capability.
        $scope.onDelete = function() {
          // Rebuild resourceTitle, $scope.resourceName could have changed
          var resourceName = $scope.resourceName || $scope._resourceName;
          var resourceTitle = resourceName.charAt(0).toUpperCase() + resourceName.slice(1);
          // Called when the delete is done.
          var onDeleteDone = function(data) {
            $scope.showAlerts({
              type: 'success',
              message: resourceTitle + ' was deleted.'
            });
            Formio.clearCache();
            $scope.$emit('delete', data);
          };

          if ($scope.action) {
            $http.delete($scope.action).then(onDeleteDone, FormioScope.onError($scope, $element));
          }
          else if (loader) {
            if (!methodName) return;
            if (typeof loader[methodName] !== 'function') return;
            loader[methodName]().then(onDeleteDone, FormioScope.onError($scope, $element));
          }
        };
        $scope.onCancel = function() {
          $scope.$emit('cancel');
        };
      }
    ]
  };
};

},{}],211:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  '$compile',
  '$templateCache',
  function(
    $compile,
    $templateCache
  ) {
    return {
      scope: false,
      link: function(scope, element) {
        element.replaceWith($compile($templateCache.get(scope.template))(scope));
        scope.$emit('formElementRender', element);
      }
    };
  }
];

},{}],212:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    scope: false,
    restrict: 'E',
    templateUrl: 'formio/errors.html'
  };
};

},{}],213:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    replace: true,
    restrict: 'E',
    scope: {
      form: '=',
      submission: '=',
      ignore: '=?'
    },
    templateUrl: 'formio/submission.html',
    controller: [
      '$scope',
      'FormioUtils',
      function(
        $scope,
        FormioUtils
      ) {
        $scope.isVisible = function(component, row) {
          return FormioUtils.isVisible(
            component,
            row,
            $scope.submission ? $scope.submission.data : null,
            $scope.ignore
          );
        };
      }
    ]
  };
};

},{}],214:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    replace: true,
    restrict: 'E',
    scope: {
      src: '=?',
      form: '=?',
      submissions: '=?',
      perPage: '=?'
    },
    templateUrl: 'formio/submissions.html',
    controller: [
      '$scope',
      '$element',
      'FormioScope',
      function(
        $scope,
        $element,
        FormioScope
      ) {
        $scope._src = $scope.src || '';
        $scope.formioAlerts = [];
        // Shows the given alerts (single or array), and dismisses old alerts
        this.showAlerts = $scope.showAlerts = function(alerts) {
          $scope.formioAlerts = [].concat(alerts);
        };

        $scope.perPage = $scope.perPage === undefined ? 10 : $scope.perPage;
        $scope.formio = FormioScope.register($scope, $element, {
          form: true,
          submissions: true
        });

        $scope.currentPage = 1;
        $scope.pageChanged = function(page) {
          $scope.skip = (page - 1) * $scope.perPage;
          $scope.updateSubmissions();
        };

        $scope.tableView = function(component) {
          return !component.hasOwnProperty('tableView') || component.tableView;
        };

        $scope.$watch('submissions', function(submissions) {
          if (submissions && submissions.length > 0) {
            $scope.$emit('submissionLoad', $scope.submissions);
          }
        });
      }
    ]
  };
};

},{}],215:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    templateUrl: 'formio-wizard.html',
    scope: {
      src: '=?',
      formAction: '=?',
      form: '=?',
      submission: '=?',
      readOnly: '=?',
      hideComponents: '=?',
      disableComponents: '=?',
      formioOptions: '=?',
      storage: '=?'
    },
    link: function(scope, element) {
      // From https://siongui.github.io/2013/05/12/angularjs-get-element-offset-position/
      var offset = function(elm) {
        try {
          return elm.offset();
        }
        catch (e) {
          // Do nothing...
        }
        var rawDom = elm[0];
        var _x = 0;
        var _y = 0;
        var body = document.documentElement || document.body;
        var scrollX = window.pageXOffset || body.scrollLeft;
        var scrollY = window.pageYOffset || body.scrollTop;
        _x = rawDom.getBoundingClientRect().left + scrollX;
        _y = rawDom.getBoundingClientRect().top + scrollY;
        return {
          left: _x,
          top: _y
        };
      };

      scope.wizardLoaded = false;
      scope.wizardTop = offset(element).top;
      if (scope.wizardTop > 50) {
        scope.wizardTop -= 50;
      }
      scope.wizardElement = angular.element('.formio-wizard', element);
    },
    controller: [
      '$scope',
      '$compile',
      '$element',
      'Formio',
      'FormioScope',
      'FormioUtils',
      '$http',
      '$timeout',
      function(
        $scope,
        $compile,
        $element,
        Formio,
        FormioScope,
        FormioUtils,
        $http,
        $timeout
      ) {
        var session = ($scope.storage && !$scope.readOnly) ? localStorage.getItem($scope.storage) : false;
        if (session) {
          session = angular.fromJson(session);
        }

        $scope.formio = null;
        $scope.page = {};
        $scope.pages = [];
        $scope.hasTitles = false;
        $scope.colclass = '';
        if (!$scope.submission || !Object.keys($scope.submission).length) {
          $scope.submission = session ? {data: session.data} : {data: {}};
        }
        $scope.currentPage = session ? session.page : 0;
        $scope.formioAlerts = [];

        var getForm = function() {
          var element = $element.find('#formio-wizard-form');
          if (!element.length) {
            return {};
          }
          return element.children().scope().formioForm;
        };

        // Show the current page.
        var showPage = function(scroll) {
          $scope.wizardLoaded = false;
          $scope.page.components = [];
          $scope.page.components.length = 0;
          $timeout(function() {
            // If the page is past the components length, try to clear first.
            if ($scope.currentPage >= $scope.pages.length) {
              $scope.clear();
            }

            if ($scope.storage && !$scope.readOnly) {
              localStorage.setItem($scope.storage, angular.toJson({
                page: $scope.currentPage,
                data: $scope.submission.data
              }));
            }

            $scope.page.components = $scope.pages[$scope.currentPage].components;
            $scope.formioAlerts = [];
            if (scroll) {
              window.scrollTo(0, $scope.wizardTop);
            }
            $scope.wizardLoaded = true;
            $scope.$emit('wizardPage', $scope.currentPage);
            $timeout($scope.$apply.bind($scope));
          });
        };

        if (!$scope.form && $scope.src) {
          (new Formio($scope.src)).loadForm().then(function(form) {
            $scope.form = form;
            if (!$scope.wizardLoaded) {
              showPage();
            }
          });
        }

        // Shows the given alerts (single or array), and dismisses old alerts
        this.showAlerts = $scope.showAlerts = function(alerts) {
          $scope.formioAlerts = [].concat(alerts);
        };

        $scope.clear = function() {
          if ($scope.storage && !$scope.readOnly) {
            localStorage.setItem($scope.storage, '');
          }
          $scope.submission = {data: {}};
          $scope.currentPage = 0;
        };

        // Check for errors.
        $scope.checkErrors = function() {
          if (!$scope.isValid()) {
            // Change all of the fields to not be pristine.
            angular.forEach($element.find('[name="formioForm"]').children(), function(element) {
              var elementScope = angular.element(element).scope();
              var fieldForm = elementScope.formioForm;
              if (fieldForm[elementScope.component.key]) {
                fieldForm[elementScope.component.key].$pristine = false;
              }
            });
            $scope.formioAlerts = [{
              type: 'danger',
              message: 'Please fix the following errors before proceeding.'
            }];
            return true;
          }
          return false;
        };

        // Submit the submission.
        $scope.submit = function() {
          if ($scope.checkErrors()) {
            return;
          }

          // Create a sanitized submission object.
          var submissionData = {data: {}};
          if ($scope.submission._id) {
            submissionData._id = $scope.submission._id;
          }
          if ($scope.submission.data._id) {
            submissionData._id = $scope.submission.data._id;
          }

          var grabIds = function(input) {
            if (!input) {
              return [];
            }

            if (!(input instanceof Array)) {
              input = [input];
            }

            var final = [];
            input.forEach(function(element) {
              if (element && element._id) {
                final.push(element._id);
              }
            });

            return final;
          };

          var defaultPermissions = {};
          FormioUtils.eachComponent($scope.form.components, function(component) {
            if (component.type === 'resource' && component.key && component.defaultPermission) {
              defaultPermissions[component.key] = component.defaultPermission;
            }
            if (submissionData.data.hasOwnProperty(component.key) && (component.type === 'number')) {
              var value = $scope.submission.data[component.key];
              if (component.type === 'number') {
                submissionData.data[component.key] = value ? parseFloat(value) : 0;
              }
              else {
                submissionData.data[component.key] = value;
              }
            }
          }, true);

          angular.forEach($scope.submission.data, function(value, key) {
            submissionData.data[key] = value;

            // Setup the submission access.
            var perm = defaultPermissions[key];
            if (perm) {
              submissionData.access = submissionData.access || [];

              // Coerce value into an array for plucking.
              if (!(value instanceof Array)) {
                value = [value];
              }

              // Try to find and update an existing permission.
              var found = false;
              submissionData.access.forEach(function(permission) {
                if (permission.type === perm) {
                  found = true;
                  permission.resources = permission.resources || [];
                  permission.resources.concat(grabIds(value));
                }
              });

              // Add a permission, because one was not found.
              if (!found) {
                submissionData.access.push({
                  type: perm,
                  resources: grabIds(value)
                });
              }
            }
          });
          // Strip out any angular keys.
          submissionData = angular.copy(submissionData);

          var submitEvent = $scope.$emit('formSubmit', submissionData);
          if (submitEvent.defaultPrevented) {
              // Listener wants to cancel the form submission
              return;
          }

          var onDone = function(submission) {
            if ($scope.storage && !$scope.readOnly) {
              localStorage.setItem($scope.storage, '');
            }
            $scope.showAlerts({
              type: 'success',
              message: 'Submission Complete!'
            });
            $scope.$emit('formSubmission', submission);
          };

          // Save to specified action.
          if ($scope.action) {
            var method = submissionData._id ? 'put' : 'post';
            $http[method]($scope.action, submissionData).then(function(submission) {
              Formio.clearCache();
              onDone(submission);
            }, FormioScope.onError($scope, $element));
          }
          else if ($scope.formio && !$scope.formio.noSubmit) {
            $scope.formio.saveSubmission(submissionData).then(onDone).catch(FormioScope.onError($scope, $element));
          }
          else {
            onDone(submissionData);
          }
        };

        $scope.cancel = function() {
          $scope.clear();
          showPage(true);
          $scope.$emit('cancel');
        };

        // Move onto the next page.
        $scope.next = function() {
          if ($scope.checkErrors()) {
            return;
          }
          if ($scope.currentPage >= ($scope.pages.length - 1)) {
            return;
          }
          $scope.currentPage++;
          showPage(true);
          $scope.$emit('wizardNext', $scope.currentPage);
        };

        // Move onto the previous page.
        $scope.prev = function() {
          if ($scope.currentPage < 1) {
            return;
          }
          $scope.currentPage--;
          showPage(true);
          $scope.$emit('wizardPrev', $scope.currentPage);
        };

        $scope.goto = function(page) {
          if (page < 0) {
            return;
          }
          if (page >= $scope.pages.length) {
            return;
          }
          $scope.currentPage = page;
          showPage(true);
        };

        $scope.isValid = function() {
          return getForm().$valid;
        };

        $scope.$on('wizardGoToPage', function(event, page) {
          $scope.goto(page);
        });

        var updatePages = function() {
          if ($scope.pages.length > 6) {
            $scope.margin = ((1 - ($scope.pages.length * 0.0833333333)) / 2) * 100;
            $scope.colclass = 'col-sm-1';
          }
          else {
            $scope.margin = ((1 - ($scope.pages.length * 0.1666666667)) / 2) * 100;
            $scope.colclass = 'col-sm-2';
          }
        };

        var allPages = [];
        var hasConditionalPages = false;
        var setForm = function(form) {
          $scope.pages = [];
          angular.forEach(form.components, function(component) {
            // Only include panels for the pages.
            if (component.type === 'panel') {
              if (!$scope.hasTitles && component.title) {
                $scope.hasTitles = true;
              }
              if (component.customConditional) {
                hasConditionalPages = true;
              }
              else if (component.conditional && component.conditional.when) {
                hasConditionalPages = true;
              }
              // Make sure this page is not in the hide compoenents array.
              if (
                ($scope.hideComponents) &&
                (component.key) &&
                ($scope.hideComponents.indexOf(component.key) !== -1)
              ) {
                return;
              }
              allPages.push(component);
              $scope.pages.push(component);
            }
          });

          // FOR-71
          if (!$scope.builder && hasConditionalPages) {
            $scope.$watch('submission.data', function(data) {
              var newPages = [];
              angular.forEach(allPages, function(page) {
                if (FormioUtils.isVisible(page, null, data)) {
                  newPages.push(page);
                }
              });
              $scope.pages = newPages;
              updatePages();
              setTimeout($scope.$apply.bind($scope), 10);
            }, true);
          }

          $scope.form = $scope.form ? angular.merge($scope.form, angular.copy(form)) : angular.copy(form);
          $scope.page = angular.copy(form);
          $scope.page.display = 'form';
          $scope.$emit('wizardFormLoad', form);
          updatePages();
          showPage();
        };

        // FOR-71
        if (!$scope.builder) {
          $scope.$watch('form', function(form) {
            if (
              $scope.src ||
              !form ||
              !Object.keys(form).length ||
              !form.components ||
              !form.components.length
            ) {
              return;
            }
            var formUrl = form.project ? '/project/' + form.project : '';
            formUrl += '/form/' + form._id;
            $scope.formio = new Formio(formUrl);
            setForm(form);
          });
        }

        // When the components length changes update the pages.
        $scope.$watch('form.components.length', updatePages);

        // Load the form.
        if ($scope.src) {
          $scope.formio = new Formio($scope.src);
          $scope.formio.loadForm().then(function(form) {
            setForm(form);
          });
        }
        else {
          $scope.src = '';
          $scope.formio = new Formio($scope.src);
        }
      }
    ]
  };
};

},{}],216:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'Formio',
  'formioComponents',
  '$timeout',
  function(
    Formio,
    formioComponents,
    $timeout
  ) {
    return {
      onError: function($scope, $element) {
        return function(error) {
          if ((error.name === 'ValidationError') && $element) {
            $element.find('#form-group-' + error.details[0].path).addClass('has-error');
            var message = 'ValidationError: ' + error.details[0].message;
            $scope.showAlerts({
              type: 'danger',
              message: message
            });
          }
          else {
            if (error instanceof Error) {
              error = error.toString();
            }
            else if (typeof error === 'object') {
              error = JSON.stringify(error);
            }
            $scope.showAlerts({
              type: 'danger',
              message: error
            });
          }
          $scope.$emit('formError', error);
        };
      },
      register: function($scope, $element, options) {
        var loader = null;
        $scope.formLoading = true;
        $scope.form = angular.isDefined($scope.form) ? $scope.form : {};
        $scope.submission = angular.isDefined($scope.submission) ? $scope.submission : {data: {}};
        $scope.submissions = angular.isDefined($scope.submissions) ? $scope.submissions : [];

        // Keep track of the elements rendered.
        var elementsRendered = 0;
        $scope.$on('formElementRender', function() {
          elementsRendered++;
          if (elementsRendered === $scope.form.components.length) {
            $timeout(function() {
              $scope.$emit('formRender', $scope.form);
            });
          }
        });

        $scope.setLoading = function(_loading) {
          $scope.formLoading = _loading;
        };

        // Used to set the form action.
        var getAction = function(action) {
          if (!action) return '';
          if (action.substr(0, 1) === '/') {
            action = Formio.getBaseUrl() + action;
          }
          return action;
        };

        // Set the action.
        $scope.action = getAction($scope.formAction);

        // Allow sub components the ability to add new form components to the form.
        var addedData = {};
        $scope.$on('addFormComponent', function(event, component) {
          if (!addedData.hasOwnProperty(component.settings.key)) {
            addedData[component.settings.key] = true;
            var defaultComponent = formioComponents.components[component.type];
            $scope.form.components.push(angular.extend(defaultComponent.settings, component.settings));
          }
        });

        // Set the action if they provided it in the form.
        $scope.$watch('form.action', function(value) {
          if (!value) return;
          var action = getAction(value);
          if (action) {
            $scope.action = action;
          }
        });

        // Trigger a form load event when the components length is more than 0.
        $scope.$watch('form.components.length', function() {
          if (
            !$scope.form ||
            !$scope.form.components ||
            !$scope.form.components.length
          ) {
            return;
          }
          $scope.setLoading(false);
          $scope.$emit('formLoad', $scope.form);
        });

        $scope.updateSubmissions = function() {
          $scope.setLoading(true);
          var params = {};
          if ($scope.perPage) params.limit = $scope.perPage;
          if ($scope.skip) params.skip = $scope.skip;
          loader.loadSubmissions({params: params}).then(function(submissions) {
            angular.merge($scope.submissions, angular.copy(submissions));
            $scope.setLoading(false);
            $scope.$emit('submissionsLoad', submissions);
          }, this.onError($scope));
        }.bind(this);

        if ($scope._src) {
          loader = new Formio($scope._src);
          if (options.form) {
            $scope.setLoading(true);

            // If a form is already provided, then skip the load.
            if ($scope.form && Object.keys($scope.form).length) {
              $scope.setLoading(false);
              $scope.$emit('formLoad', $scope.form);
            }
            else {
              loader.loadForm().then(function(form) {
                angular.merge($scope.form, angular.copy(form));
                $scope.setLoading(false);
                $scope.$emit('formLoad', $scope.form);
              }, this.onError($scope));
            }
          }
          if (options.submission && loader.submissionId) {
            $scope.setLoading(true);

            // If a submission is already provided, then skip the load.
            if ($scope.submission && Object.keys($scope.submission.data).length) {
              $scope.setLoading(false);
              $scope.$emit('submissionLoad', $scope.submission);
            }
            else {
              loader.loadSubmission().then(function(submission) {
                angular.merge($scope.submission, angular.copy(submission));
                $scope.setLoading(false);
                $scope.$emit('submissionLoad', submission);
              }, this.onError($scope));
            }
          }
          if (options.submissions) {
            $scope.updateSubmissions();
          }
        }
        else {
          // If they provide a url to the form, we still need to create it but tell it to not submit.
          if ($scope.url) {
            loader = new Formio($scope.url);
            loader.noSubmit = true;
          }

          $scope.formoLoaded = true;
          $scope.formLoading = !$scope.form || (Object.keys($scope.form).length === 0) || !$scope.form.components.length;
          $scope.setLoading($scope.formLoading);

          // Emit the events if these objects are already loaded.
          if (!$scope.formLoading) {
            $scope.$emit('formLoad', $scope.form);
          }
          if ($scope.submission) {
            $scope.$emit('submissionLoad', $scope.submission);
          }
          if ($scope.submissions) {
            $scope.$emit('submissionsLoad', $scope.submissions);
          }
        }

        // Return the loader.
        return loader;
      }
    };
  }
];

},{}],217:[function(_dereq_,module,exports){
"use strict";
var formioUtils = _dereq_('formiojs/utils');

module.exports = function() {
  return {
    checkVisible: function(component, row, data) {
      var visible = formioUtils.checkCondition(component, row, data);
      if (!visible) {
        if (!component.hasOwnProperty('clearOnHide') || component.clearOnHide.toString() === 'true') {
          if (row && row.hasOwnProperty(component.key)) {
            delete row[component.key];
          }
          if (data && data.hasOwnProperty(component.key)) {
            delete data[component.key];
          }
        }
        return false;
      }
      return true;
    },
    isVisible: function(component, row, data, hide) {
      // If the component is in the hideComponents array, then hide it by default.
      if (hide && Array.isArray(hide) && (hide.indexOf(component.key) !== -1)) {
        return false;
      }

      return this.checkVisible(component, row, data);
    },
    flattenComponents: formioUtils.flattenComponents,
    eachComponent: formioUtils.eachComponent,
    getComponent: formioUtils.getComponent,
    getValue: formioUtils.getValue,
    hideFields: function(form, components) {
      this.eachComponent(form.components, function(component) {
        for (var i in components) {
          if (component.key === components[i]) {
            component.type = 'hidden';
          }
        }
      });
    },
    uniqueName: function(name) {
      var parts = name.toLowerCase().replace(/[^0-9a-z\.]/g, '').split('.');
      var fileName = parts[0];
      var ext = '';
      if (parts.length > 1) {
        ext = '.' + parts[(parts.length - 1)];
      }
      return fileName.substr(0, 10) + '-' + this.guid() + ext;
    },
    guid: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
      });
    },
    fieldWrap: function(input) {
      var multiInput = input.replace('data[component.key]', 'data[component.key][$index]');
      var inputLabel = '<label ng-if="component.label && !component.hideLabel" for="{{ component.key }}" class="control-label" ng-class="{\'field-required\': isRequired(component)}">{{ component.label | formioTranslate:null:builder }}</label>';
      var requiredInline = '<span ng-if="(component.hideLabel === true || component.label === \'\' || !component.label) && isRequired(component)" class="glyphicon glyphicon-asterisk form-control-feedback field-required-inline" aria-hidden="true"></span>';
      var template =
        '<div ng-if="!component.multiple">' +
          inputLabel +
          '<div class="input-group">' +
            '<div class="input-group-addon" ng-if="!!component.prefix">{{ component.prefix }}</div>' +
            input +
            requiredInline +
            '<div class="input-group-addon" ng-if="!!component.suffix">{{ component.suffix }}</div>' +
          '</div>' +
          '<div class="formio-errors">' +
            '<formio-errors ng-if="::!builder"></formio-errors>' +
          '</div>' +
        '</div>' +
        '<div ng-if="!!component.description" class="help-block">' +
          '<span>{{ component.description }}</span>' +
        '</div>' +
        '<div ng-if="component.multiple"><table class="table table-bordered">' +
          inputLabel +
          '<tr ng-repeat="value in data[component.key] track by $index">' +
            '<td>' +
              '<div class="input-group">' +
                '<div class="input-group-addon" ng-if="!!component.prefix">{{ component.prefix }}</div>' +
                  multiInput +
                  requiredInline +
                '<div class="input-group-addon" ng-if="!!component.suffix">{{ component.suffix }}</div>' +
              '</div>' +
              '<div class="formio-errors">' +
                '<formio-errors ng-if="::!builder"></formio-errors>' +
              '</div>' +
            '</td>' +
            '<td><a ng-click="removeFieldValue($index)" class="btn btn-default"><span class="glyphicon glyphicon-remove-circle"></span></a></td>' +
          '</tr>' +
          '<tr>' +
            '<td colspan="2"><a ng-click="addFieldValue()" class="btn btn-primary"><span class="glyphicon glyphicon-plus" aria-hidden="true"></span> {{ component.addAnother || "Add Another" | formioTranslate:null:builder }}</a></td>' +
          '</tr>' +
        '</table></div>';
      return template;
    },

    /**
     * Check if a component is required
     *
     * @param {Object} component The component to be checked
     * @param {Array} componentsToRequire An array of component keys manually set to mark specific components as required
     */
    isRequired: function(component, componentsToRequire) {
      return (component.validate && component.validate.required) || (Array.isArray(componentsToRequire) && componentsToRequire.indexOf(component.key) !== -1);
    }
  };
};

},{"formiojs/utils":9}],218:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  var generic = function(data, component) {
    if (typeof data === 'string') {
      return data;
    }
    var startTable = function(labels) {
      if (!(labels instanceof Array)) {
        labels = [labels];
      }

      var view = '<table class="table table-striped table-bordered"><thead><tr>';

      labels.forEach(function(item) {
        view += '<th>' + item + '</th>';
      });

      view += '</tr></thead>';
      view += '<tbody>';
      return view;
    };

    var finishTable = function() {
      return '</tbody></table>';
    };

    var makeRow = function(data, noRow) {
      var view = !noRow ? '<tr>' : '';

      if (typeof data === 'string' || typeof data === 'number') {
        view += '<td>' + data + '</td>';
      }
      else if (data === null || data === undefined) {
        view += '<td></td>';
      }
      else if (data instanceof Array) {
        data.forEach(function(item) {
          view += makeRow(item);
        });
      }
      else if (typeof data === 'object' && data !== null && data !== undefined) {
        var labels = Object.keys(data);

        view += '<td>' + startTable(labels);
        labels.forEach(function(key) {
          view += makeRow(data[key], true);
        });
        view += finishTable() + '</td>';
      }

      view += !noRow ? '</tr>' : '';
      return view;
    };

    // Create a template
    var view = '';
    var label;
    if (!label && component && component.label) {
      label = component.label;
    }
    else if (!label && component && component.key) {
      label = component.key;
    }
    else {
      label = '';
    }

    view += startTable(label);
    view += makeRow(data);
    view += finishTable();
    return view;
  };

  return {
    generic: generic
  };
};

},{}],219:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  '$q',
  '$rootScope',
  'Formio',
  function($q, $rootScope, Formio) {
    var Interceptor = {
      /**
       * Update JWT token received from response.
       */
      response: function(response) {
        var token = response.headers('x-jwt-token');
        if (response.status >= 200 && response.status < 300 && token && token !== '') {
          Formio.setToken(token);
        }
        return response;
      },

      /**
       * Intercept a response error.
       */
      responseError: function(response) {
        if (parseInt(response.status, 10) === 440) {
          response.loggedOut = true;
          Formio.setToken(null);
          $rootScope.$broadcast('formio.sessionExpired', response.body);
        }
        else if (parseInt(response.status, 10) === 401) {
          $rootScope.$broadcast('formio.unauthorized', response.body);
        }
        return $q.reject(response);
      },

      /**
       * Set the token in the request headers.
       */
      request: function(config) {
        if (config.disableJWT) return config;
        var token = Formio.getToken();
        if (token) config.headers['x-jwt-token'] = token;
        return config;
      }
    };

    return Interceptor;
  }
];

},{}],220:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'Formio',
  'formioComponents',
  '$interpolate',
  function(
    Formio,
    formioComponents,
    $interpolate
  ) {
    return function(value, component) {
      if (!value && value !== 0) {
        return '';
      }
      if (!component || !component.input|| !component.type) {
        return value;
      }
      var componentInfo = formioComponents.components[component.type];
      if (!componentInfo.tableView) {
        return value;
      }
      if (component.multiple && (value.length > 0)) {
        var values = [];
        angular.forEach(value, function(arrayValue) {
          values.push(componentInfo.tableView(arrayValue, component, $interpolate, formioComponents));
        });
        return values;
      }
      return componentInfo.tableView(value, component, $interpolate, formioComponents);
    };
  }
];

},{}],221:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'FormioUtils',
  function(FormioUtils) {
    return FormioUtils.flattenComponents;
  }
];

},{}],222:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  '$sce',
  function(
    $sce
  ) {
    return function(html) {
      return $sce.trustAsHtml(html);
    };
  }
];

},{}],223:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  function() {
    return function(components) {
      var tableComps = [];
      if (!components || !components.length) {
        return tableComps;
      }
      components.forEach(function(component) {
        if (component.tableView) {
          tableComps.push(component);
        }
      });
      return tableComps;
    };
  }
];

},{}],224:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'formioTableView',
  function(
    formioTableView
  ) {
    return function(value, component) {
      return formioTableView(value, component);
    };
  }
];

},{}],225:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'Formio',
  'formioTableView',
  function(
    Formio,
    formioTableView
  ) {
    return function(data, component) {
      return formioTableView(Formio.fieldData(data, component), component);
    };
  }
];

},{}],226:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  '$filter',
  '$injector',
  function(
    $filter,
    $injector
  ) {
    return function(text, key, builder) {
      /**
       * Lookup the available translate libraries, currently supports:
       * angular-translate: @see https://github.com/angular-translate/angular-translate
       * angular-gettext: @see https://github.com/rubenv/angular-gettext
       */
      var $translate, gettextCatalog;
      if ($injector.has('$translate')) {
        $translate = $injector.get('$translate');
      }
      else if ($injector.has('gettextCatalog')) {
        gettextCatalog = $injector.get('gettextCatalog');
      }
      if (builder) return text;
      try {
        // Translate text using either angular-translate or angular-gettext
        var translateText = function(text) {
          if ($translate) return $translate.instant(text);
          if (gettextCatalog) return gettextCatalog.getString(text);
          return text;
        };

        // Allow translating by field key which helps with large blocks of html.
        if (key) {
          var result = translateText(key);
          if (result === key) {
            result = translateText(text);
          }
          return result;
        }

        return translateText(text);
      }
      catch (e) {
        return text;
      }
    };
  }
];

},{}],227:[function(_dereq_,module,exports){
"use strict";
module.exports = ['$sce', function($sce) {
  return function(val) {
    return $sce.trustAsResourceUrl(val);
  };
}];

},{}],228:[function(_dereq_,module,exports){
"use strict";
_dereq_('./polyfills/polyfills');


var app = angular.module('formio', [
  'ngSanitize',
  'ui.bootstrap',
  'ui.bootstrap.datetimepicker',
  'ui.select',
  'ui.mask',
  'angularMoment',
  'ngFileUpload',
  'ngFileSaver'
]);

/**
 * Create the formio providers.
 */
app.provider('Formio', _dereq_('./providers/Formio'));

/**
 * Provides a way to register the Formio scope.
 */
app.factory('FormioScope', _dereq_('./factories/FormioScope'));

app.factory('FormioUtils', _dereq_('./factories/FormioUtils'));

app.factory('formioInterceptor', _dereq_('./factories/formioInterceptor'));

app.factory('formioTableView', _dereq_('./factories/formioTableView'));

app.directive('formio', _dereq_('./directives/formio'));

app.directive('formioDelete', _dereq_('./directives/formioDelete'));

app.directive('formioErrors', _dereq_('./directives/formioErrors'));

app.directive('customValidator', _dereq_('./directives/customValidator'));

app.directive('formioSubmissions', _dereq_('./directives/formioSubmissions'));

app.directive('formioSubmission', _dereq_('./directives/formioSubmission'));

app.directive('formioComponent', _dereq_('./directives/formioComponent'));

app.directive('formioComponentView', _dereq_('./directives/formioComponentView'));

app.directive('formioElement', _dereq_('./directives/formioElement'));

app.directive('formioWizard', _dereq_('./directives/formioWizard'));

app.directive('formioBindHtml', _dereq_('./directives/formioBindHtml.js'));

/**
 * Filter to flatten form components.
 */
app.filter('flattenComponents', _dereq_('./filters/flattenComponents'));
app.filter('tableComponents', _dereq_('./filters/tableComponents'));
app.filter('tableView', _dereq_('./filters/tableView'));
app.filter('tableFieldView', _dereq_('./filters/tableFieldView'));
app.filter('safehtml', _dereq_('./filters/safehtml'));
app.filter('formioTranslate', _dereq_('./filters/translate'));
app.filter('trustAsResourceUrl', _dereq_('./filters/trusturl'));
app.config([
  '$httpProvider',
  '$injector',
  function(
    $httpProvider,
    $injector
  ) {
    if (!$httpProvider.defaults.headers.get) {
      $httpProvider.defaults.headers.get = {};
    }

    // Make sure that ngAnimate doesn't mess up loader.
    try {
      $injector.get('$animateProvider').classNameFilter(/^((?!(fa-spinner|glyphicon-spin)).)*$/);
    }
    /* eslint-disable no-empty */
    catch (err) {}
    /* eslint-enable no-empty */

    // Disable IE caching for GET requests.
    $httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache';
    $httpProvider.defaults.headers.get.Pragma = 'no-cache';
    $httpProvider.interceptors.push('formioInterceptor');
  }
]);

app.run([
  '$templateCache',
  '$rootScope',
  '$window',
  function($templateCache, $rootScope, $window) {
    $window.addEventListener('message', function(event) {
      var eventData = null;
      try {
        eventData = JSON.parse(event.data);
      }
      catch (err) {
        eventData = null;
      }
      if (eventData && eventData.name) {
        $rootScope.$broadcast('iframe-' + eventData.name, eventData.data);
      }
    });

    // The template for the formio forms.
    $templateCache.put('formio.html',
      "<div>\n  <i style=\"font-size: 2em;\" ng-if=\"formLoading\" ng-class=\"{'formio-hidden': !formLoading}\" class=\"formio-loading glyphicon glyphicon-refresh glyphicon-spin\"></i>\n  <formio-wizard ng-if=\"form.display === 'wizard'\" src=\"src\" form=\"form\" submission=\"submission\" form-action=\"formAction\" read-only=\"readOnly\" hide-components=\"hideComponents\" disable-components=\"disableComponents\" formio-options=\"formioOptions\" storage=\"form.name\"></formio-wizard>\n  <div ng-if=\"form.display === 'pdf' && form.settings.pdf\" style=\"position:relative;\">\n    <span style=\"position:absolute;right:10px;top:10px;cursor:pointer;\" class=\"btn btn-default no-disable\" ng-click=\"zoomIn()\"><spann class=\"glyphicon glyphicon-zoom-in\"></spann></span>\n    <span style=\"position:absolute;right:10px;top:60px;cursor:pointer;\" class=\"btn btn-default no-disable\" ng-click=\"zoomOut()\"><span class=\"glyphicon glyphicon-zoom-out\"></span></span>\n    <a ng-if=\"downloadUrl\" style=\"position:absolute;right:10px;top:110px;cursor:pointer;\" class=\"btn btn-primary no-disable\" href=\"{{ downloadUrl | trustAsResourceUrl }}\" target=\"_blank\"><span class=\"glyphicon glyphicon-cloud-download\"></span></a>\n    <iframe src=\"{{ getIframeSrc(form.settings.pdf) | trustAsResourceUrl }}\" seamless class=\"formio-iframe\"></iframe>\n    <button ng-if=\"!readOnly && !form.builder\" type=\"button\" class=\"btn btn-primary\" ng-click=\"submitIFrameForm()\">Submit</button>\n  </div>\n  <form ng-if=\"!form.display || (form.display === 'form')\" role=\"form\" name=\"formioForm\" ng-submit=\"onSubmit(formioForm)\" novalidate>\n    <div ng-repeat=\"alert in formioAlerts track by $index\" class=\"alert alert-{{ alert.type }}\" role=\"alert\" ng-if=\"::!builder\">\n      {{ alert.message | formioTranslate:null:builder }}\n    </div>\n    <!-- DO NOT PUT \"track by $index\" HERE SINCE DYNAMICALLY ADDING/REMOVING COMPONENTS WILL BREAK -->\n    <formio-component\n      ng-repeat=\"component in form.components track by $index\"\n      component=\"component\"\n      ng-if=\"builder ? '::true' : isVisible(component)\"\n      data=\"submission.data\"\n      formio-form=\"formioForm\"\n      formio=\"formio\"\n      submission=\"submission\"\n      hide-components=\"hideComponents\"\n      read-only=\"isDisabled(component, submission.data)\"\n      builder=\"builder\"\n    ></formio-component>\n  </form>\n</div>\n"
    );

    $templateCache.put('formio-wizard.html',
      "<div class=\"formio-wizard-wrapper\">\n  <div class=\"row bs-wizard\" style=\"border-bottom:0;\" ng-class=\"{hasTitles: hasTitles}\">\n    <div ng-class=\"{disabled: ($index > currentPage), active: ($index == currentPage), complete: ($index < currentPage), noTitle: !page.title}\" class=\"{{ colclass }} bs-wizard-step\" ng-repeat=\"page in pages track by $index\">\n      <div class=\"bs-wizard-stepnum-wrapper\">\n        <div class=\"text-center bs-wizard-stepnum\" ng-if=\"page.title\">{{ page.title }}</div>\n      </div>\n      <div class=\"progress\"><div class=\"progress-bar progress-bar-primary\"></div></div>\n      <a ng-click=\"goto($index)\" class=\"bs-wizard-dot bg-primary\"><div class=\"bs-wizard-dot-inner bg-success\"></div></a>\n    </div>\n  </div>\n  <style type=\"text/css\">.bs-wizard > .bs-wizard-step:first-child { margin-left: {{ margin }}%; }</style>\n  <i ng-show=\"!wizardLoaded\" id=\"formio-loading\" style=\"font-size: 2em;\" class=\"glyphicon glyphicon-refresh glyphicon-spin\"></i>\n  <div ng-repeat=\"alert in formioAlerts track by $index\" class=\"alert alert-{{ alert.type }}\" role=\"alert\">{{ alert.message | formioTranslate:null:builder }}</div>\n  <div class=\"formio-wizard\">\n    <formio\n      ng-if=\"wizardLoaded\"\n      submission=\"submission\"\n      form=\"page\"\n      read-only=\"readOnly\"\n      hide-components=\"hideComponents\"\n      disable-components=\"disableComponents\"\n      formio-options=\"formioOptions\"\n      id=\"formio-wizard-form\"\n    ></formio>\n  </div>\n  <ul ng-show=\"wizardLoaded\" class=\"list-inline\">\n    <li><a class=\"btn btn-default\" ng-click=\"cancel()\">Cancel</a></li>\n    <li ng-if=\"currentPage > 0\"><a class=\"btn btn-primary\" ng-click=\"prev()\">Previous</a></li>\n    <li ng-if=\"currentPage < (pages.length - 1)\">\n      <a class=\"btn btn-primary\" ng-click=\"next()\">Next</a>\n    </li>\n    <li ng-if=\"currentPage >= (pages.length - 1)\">\n      <a class=\"btn btn-primary\" ng-click=\"submit()\">Submit Form</a>\n    </li>\n  </ul>\n</div>\n"
    );

    $templateCache.put('formio-delete.html',
      "<form role=\"form\">\n  <div ng-repeat=\"alert in formioAlerts track by $index\" class=\"alert alert-{{ alert.type }}\" role=\"alert\">\n    {{ alert.message | formioTranslate:null:builder }}\n  </div>\n  <h3>{{ deleteMessage | formioTranslate:null:builder }}</h3>\n  <div class=\"btn-toolbar\">\n    <button ng-click=\"onDelete()\" class=\"btn btn-danger\">{{ 'Yes' | formioTranslate:null:builder }}</button>\n    <button ng-click=\"onCancel()\" class=\"btn btn-default\">{{ 'No' | formioTranslate:null:builder }}</button>\n  </div>\n</form>\n"
    );

    $templateCache.put('formio/submission.html',
      "<div>\n  <div ng-repeat=\"component in form.components track by $index\" ng-if=\"submission && submission.data\">\n    <formio-component-view\n      form=\"form\"\n      component=\"component\"\n      data=\"submission.data\"\n      ignore=\"ignore\"\n      submission=\"submission\"\n      ng-if=\"builder ? '::true' : isVisible(component)\"\n      builder=\"builder\"\n    ></formio-component-view>\n  </div>\n</div>\n"
    );

    $templateCache.put('formio/submissions.html',
      "<div>\n  <div ng-repeat=\"alert in formioAlerts track by $index\" class=\"alert alert-{{ alert.type }}\" role=\"alert\">\n    {{ alert.message | formioTranslate:null:builder }}\n  </div>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th ng-repeat=\"component in form.components | flattenComponents track by $index\" ng-if=\"tableView(component)\">{{ component.label || component.key }}</th>\n        <th>Submitted</th>\n        <th>Updated</th>\n        <th>Operations</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr ng-repeat=\"submission in submissions track by $index\" class=\"formio-submission\" ng-click=\"$emit('submissionView', submission)\">\n        <td ng-repeat=\"component in form.components | flattenComponents track by $index\" ng-if=\"tableView(component)\">{{ submission.data | tableView:component }}</td>\n        <td>{{ submission.created | amDateFormat:'l, h:mm:ss a' }}</td>\n        <td>{{ submission.modified | amDateFormat:'l, h:mm:ss a' }}</td>\n        <td>\n          <div class=\"button-group\" style=\"display:flex;\">\n            <a ng-click=\"$emit('submissionView', submission); $event.stopPropagation();\" class=\"btn btn-primary btn-xs\"><span class=\"glyphicon glyphicon-eye-open\"></span></a>&nbsp;\n            <a ng-click=\"$emit('submissionEdit', submission); $event.stopPropagation();\" class=\"btn btn-default btn-xs\"><span class=\"glyphicon glyphicon-edit\"></span></a>&nbsp;\n            <a ng-click=\"$emit('submissionDelete', submission); $event.stopPropagation();\" class=\"btn btn-danger btn-xs\"><span class=\"glyphicon glyphicon-remove-circle\"></span></a>\n          </div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n  <pagination\n    ng-if=\"submissions.serverCount > perPage\"\n    ng-model=\"currentPage\"\n    ng-change=\"pageChanged(currentPage)\"\n    total-items=\"submissions.serverCount\"\n    items-per-page=\"perPage\"\n    direction-links=\"false\"\n    boundary-links=\"true\"\n    first-text=\"&laquo;\"\n    last-text=\"&raquo;\"\n    >\n  </pagination>\n</div>\n"
    );

    // A formio component template.
    $templateCache.put('formio/component.html',
      "<div class=\"form-group form-field-type-{{ component.type }} formio-component-{{ component.key }} {{component.customClass}}\" id=\"form-group-{{ componentId }}\"\n     ng-class=\"{'has-feedback ': (component.hideLabel === true || component.label === '' || !component.label) && component.validate.required,\n             'has-error': formioForm[componentId].$invalid && !formioForm[componentId].$pristine }\"\n     ng-style=\"component.style\"\n     ng-hide=\"component.hidden\">\n  <formio-element></formio-element>\n</div>\n\n"
    );

    $templateCache.put('formio/component-view.html',
      "<div name=\"{{ componentId }}\" class=\"form-group has-feedback form-field-type-{{ component.type }} {{component.customClass}} formio-component-{{ component.key }}\" id=\"form-group-{{ componentId }}\" ng-style=\"component.style\">\n  <formio-element></formio-element>\n</div>\n"
    );

    $templateCache.put('formio/element-view.html',
      "<div>\n  <div ng-if=\"component.label\"><strong>{{ component.label }}</strong></div>\n  <div formio-bind-html=\"data | tableView:component\"></div>\n</div>\n"
    );

    $templateCache.put('formio/errors.html',
      "<div ng-show=\"formioForm[componentId].$error && !formioForm[componentId].$pristine\">\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.email\">{{ component.label || component.placeholder || component.key }} {{'must be a valid email' | formioTranslate:null:builder}}.</p>\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.required\">{{ component.label || component.placeholder || component.key }} {{'is required' | formioTranslate:null:builder}}.</p>\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.number\">{{ component.label || component.placeholder || component.key }} {{'must be a number' | formioTranslate:null:builder}}.</p>\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.maxlength\">{{ component.label || component.placeholder || component.key }} {{'must be shorter than' | formioTranslate:null:builder}} {{ component.validate.maxLength + 1 }} {{'characters' | formioTranslate:null:builder}}.</p>\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.minlength\">{{ component.label || component.placeholder || component.key }} {{'must be longer than' | formioTranslate:null:builder}} {{ component.validate.minLength - 1 }} {{'characters' | formioTranslate:null:builder}}.</p>\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.min\">{{ component.label || component.placeholder || component.key }} {{'must be greater than or equal to' | formioTranslate:null:builder}} {{ component.validate.min }}.</p>\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.max\">{{ component.label || component.placeholder || component.key }} {{'must be less than or equal to' | formioTranslate:null:builder}} {{ component.validate.max }}.</p>\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.custom\">{{ component.customError | formioTranslate }}</p>\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.pattern\">{{ component.label || component.placeholder || component.key }} {{'does not match the pattern' | formioTranslate:null:builder}} {{ component.validate.pattern }}</p>\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.day\">{{ component.label || component.placeholder || component.key }} {{'must be a valid date' | formioTranslate:null:builder}}.</p>\n</div>\n"
    );
  }
]);

_dereq_('./components');

},{"./components":189,"./directives/customValidator":205,"./directives/formio":206,"./directives/formioBindHtml.js":207,"./directives/formioComponent":208,"./directives/formioComponentView":209,"./directives/formioDelete":210,"./directives/formioElement":211,"./directives/formioErrors":212,"./directives/formioSubmission":213,"./directives/formioSubmissions":214,"./directives/formioWizard":215,"./factories/FormioScope":216,"./factories/FormioUtils":217,"./factories/formioInterceptor":219,"./factories/formioTableView":220,"./filters/flattenComponents":221,"./filters/safehtml":222,"./filters/tableComponents":223,"./filters/tableFieldView":224,"./filters/tableView":225,"./filters/translate":226,"./filters/trusturl":227,"./polyfills/polyfills":230,"./providers/Formio":231}],229:[function(_dereq_,module,exports){
"use strict";
'use strict';

if (typeof Object.assign != 'function') {
  (function() {
    Object.assign = function(target) {
      'use strict';
      // We must check against these specific cases.
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);
      /* eslint-disable max-depth */
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];
        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      /* eslint-enable max-depth */
      return output;
    };
  })();
}

},{}],230:[function(_dereq_,module,exports){
"use strict";
'use strict';

_dereq_('./Object.assign');

},{"./Object.assign":229}],231:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  // The formio class.
  var Formio = _dereq_('formiojs');

  // Return the provider interface.
  return {

    // Expose Formio configuration functions
    setBaseUrl: Formio.setBaseUrl,
    getBaseUrl: Formio.getBaseUrl,
    setApiUrl: Formio.setBaseUrl,
    getApiUrl: Formio.getBaseUrl,
    setAppUrl: Formio.setAppUrl,
    getAppUrl: Formio.getAppUrl,
    registerPlugin: Formio.registerPlugin,
    getPlugin: Formio.getPlugin,
    providers: Formio.providers,
    setDomain: function() {
      // Remove this?
    },

    $get: [
      '$rootScope',
      '$q',
      function(
        $rootScope,
        $q
      ) {
        var wrapQPromise = function(promise) {
          return $q.when(promise)
          .catch(function(error) {
            if (error === 'Unauthorized') {
              $rootScope.$broadcast('formio.unauthorized', error);
            }
            else if (error === 'Login Timeout') {
              $rootScope.$broadcast('formio.sessionExpired', error);
            }
            // Propagate error
            throw error;
          });
        };

        Formio.registerPlugin({
          priority: -100,
          // Wrap Formio.request's promises with $q so $apply gets called correctly.
          wrapRequestPromise: wrapQPromise,
          wrapStaticRequestPromise: wrapQPromise
        }, 'ngFormioPromiseWrapper');

        // Broadcast offline events from $rootScope
        Formio.events.onAny(function() {
          var event = 'formio.' + this.event;
          var args = [].splice.call(arguments, 0);
          args.unshift(event);
          $rootScope.$apply(function() {
            $rootScope.$broadcast.apply($rootScope, args);
          });
        });

        // Return the formio interface.
        return Formio;
      }
    ]
  };
};

},{"formiojs":2}]},{},[228])(228)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMi9saWIvZXZlbnRlbWl0dGVyMi5qcyIsIm5vZGVfbW9kdWxlcy9mb3JtaW9qcy9idWlsZC9mb3JtaW8uanMiLCJub2RlX21vZHVsZXMvZm9ybWlvanMvYnVpbGQvcHJvdmlkZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zvcm1pb2pzL2J1aWxkL3Byb3ZpZGVycy9zdG9yYWdlL2Ryb3Bib3guanMiLCJub2RlX21vZHVsZXMvZm9ybWlvanMvYnVpbGQvcHJvdmlkZXJzL3N0b3JhZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZm9ybWlvanMvYnVpbGQvcHJvdmlkZXJzL3N0b3JhZ2UvczMuanMiLCJub2RlX21vZHVsZXMvZm9ybWlvanMvYnVpbGQvcHJvdmlkZXJzL3N0b3JhZ2UvdXJsLmpzIiwibm9kZV9tb2R1bGVzL2Zvcm1pb2pzL2J1aWxkL3V0aWxzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zvcm1pb2pzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tbG9naWMtanMvbG9naWMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hZGRNYXBFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZFNldEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmVEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL25hdGl2ZS1wcm9taXNlLW9ubHkvbGliL25wby5zcmMuanMiLCJub2RlX21vZHVsZXMvc2hhbGxvdy1jb3B5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hdHVyZV9wYWQvZGlzdC9zaWduYXR1cmVfcGFkLmpzIiwibm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsInNyYy9jb21wb25lbnRzL2FkZHJlc3MuanMiLCJzcmMvY29tcG9uZW50cy9idXR0b24uanMiLCJzcmMvY29tcG9uZW50cy9jaGVja2JveC5qcyIsInNyYy9jb21wb25lbnRzL2NvbHVtbnMuanMiLCJzcmMvY29tcG9uZW50cy9jb21wb25lbnRzLmpzIiwic3JjL2NvbXBvbmVudHMvY29udGFpbmVyLmpzIiwic3JjL2NvbXBvbmVudHMvY29udGVudC5qcyIsInNyYy9jb21wb25lbnRzL2N1cnJlbmN5LmpzIiwic3JjL2NvbXBvbmVudHMvY3VzdG9tLmpzIiwic3JjL2NvbXBvbmVudHMvZGF0YWdyaWQuanMiLCJzcmMvY29tcG9uZW50cy9kYXRldGltZS5qcyIsInNyYy9jb21wb25lbnRzL2RheS5qcyIsInNyYy9jb21wb25lbnRzL2VtYWlsLmpzIiwic3JjL2NvbXBvbmVudHMvZmllbGRzZXQuanMiLCJzcmMvY29tcG9uZW50cy9maWxlLmpzIiwic3JjL2NvbXBvbmVudHMvaGlkZGVuLmpzIiwic3JjL2NvbXBvbmVudHMvaHRtbGVsZW1lbnQuanMiLCJzcmMvY29tcG9uZW50cy9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL251bWJlci5qcyIsInNyYy9jb21wb25lbnRzL3BhZ2UuanMiLCJzcmMvY29tcG9uZW50cy9wYW5lbC5qcyIsInNyYy9jb21wb25lbnRzL3Bhc3N3b3JkLmpzIiwic3JjL2NvbXBvbmVudHMvcGhvbmVudW1iZXIuanMiLCJzcmMvY29tcG9uZW50cy9yYWRpby5qcyIsInNyYy9jb21wb25lbnRzL3Jlc291cmNlLmpzIiwic3JjL2NvbXBvbmVudHMvc2VsZWN0LmpzIiwic3JjL2NvbXBvbmVudHMvc2VsZWN0Ym94ZXMuanMiLCJzcmMvY29tcG9uZW50cy9zaWduYXR1cmUuanMiLCJzcmMvY29tcG9uZW50cy9zdXJ2ZXkuanMiLCJzcmMvY29tcG9uZW50cy90YWJsZS5qcyIsInNyYy9jb21wb25lbnRzL3RleHRhcmVhLmpzIiwic3JjL2NvbXBvbmVudHMvdGV4dGZpZWxkLmpzIiwic3JjL2NvbXBvbmVudHMvd2VsbC5qcyIsInNyYy9kaXJlY3RpdmVzL2N1c3RvbVZhbGlkYXRvci5qcyIsInNyYy9kaXJlY3RpdmVzL2Zvcm1pby5qcyIsInNyYy9kaXJlY3RpdmVzL2Zvcm1pb0JpbmRIdG1sLmpzIiwic3JjL2RpcmVjdGl2ZXMvZm9ybWlvQ29tcG9uZW50LmpzIiwic3JjL2RpcmVjdGl2ZXMvZm9ybWlvQ29tcG9uZW50Vmlldy5qcyIsInNyYy9kaXJlY3RpdmVzL2Zvcm1pb0RlbGV0ZS5qcyIsInNyYy9kaXJlY3RpdmVzL2Zvcm1pb0VsZW1lbnQuanMiLCJzcmMvZGlyZWN0aXZlcy9mb3JtaW9FcnJvcnMuanMiLCJzcmMvZGlyZWN0aXZlcy9mb3JtaW9TdWJtaXNzaW9uLmpzIiwic3JjL2RpcmVjdGl2ZXMvZm9ybWlvU3VibWlzc2lvbnMuanMiLCJzcmMvZGlyZWN0aXZlcy9mb3JtaW9XaXphcmQuanMiLCJzcmMvZmFjdG9yaWVzL0Zvcm1pb1Njb3BlLmpzIiwic3JjL2ZhY3Rvcmllcy9Gb3JtaW9VdGlscy5qcyIsInNyYy9mYWN0b3JpZXMvR3JpZFV0aWxzLmpzIiwic3JjL2ZhY3Rvcmllcy9mb3JtaW9JbnRlcmNlcHRvci5qcyIsInNyYy9mYWN0b3JpZXMvZm9ybWlvVGFibGVWaWV3LmpzIiwic3JjL2ZpbHRlcnMvZmxhdHRlbkNvbXBvbmVudHMuanMiLCJzcmMvZmlsdGVycy9zYWZlaHRtbC5qcyIsInNyYy9maWx0ZXJzL3RhYmxlQ29tcG9uZW50cy5qcyIsInNyYy9maWx0ZXJzL3RhYmxlRmllbGRWaWV3LmpzIiwic3JjL2ZpbHRlcnMvdGFibGVWaWV3LmpzIiwic3JjL2ZpbHRlcnMvdHJhbnNsYXRlLmpzIiwic3JjL2ZpbHRlcnMvdHJ1c3R1cmwuanMiLCJzcmMvZm9ybWlvLmpzIiwic3JjL3BvbHlmaWxscy9PYmplY3QuYXNzaWduLmpzIiwic3JjL3BvbHlmaWxscy9wb2x5ZmlsbHMuanMiLCJzcmMvcHJvdmlkZXJzL0Zvcm1pby5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyohXHJcbiAqIEV2ZW50RW1pdHRlcjJcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2hpajFueC9FdmVudEVtaXR0ZXIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBoaWoxbnhcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4gKi9cclxuOyFmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuXHJcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheSA6IGZ1bmN0aW9uIF9pc0FycmF5KG9iaikge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XHJcbiAgfTtcclxuICB2YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xyXG5cclxuICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgdGhpcy5fZXZlbnRzID0ge307XHJcbiAgICBpZiAodGhpcy5fY29uZikge1xyXG4gICAgICBjb25maWd1cmUuY2FsbCh0aGlzLCB0aGlzLl9jb25mKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZShjb25mKSB7XHJcbiAgICBpZiAoY29uZikge1xyXG4gICAgICB0aGlzLl9jb25mID0gY29uZjtcclxuXHJcbiAgICAgIGNvbmYuZGVsaW1pdGVyICYmICh0aGlzLmRlbGltaXRlciA9IGNvbmYuZGVsaW1pdGVyKTtcclxuICAgICAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IGNvbmYubWF4TGlzdGVuZXJzICE9PSB1bmRlZmluZWQgPyBjb25mLm1heExpc3RlbmVycyA6IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XHJcbiAgICAgIGNvbmYud2lsZGNhcmQgJiYgKHRoaXMud2lsZGNhcmQgPSBjb25mLndpbGRjYXJkKTtcclxuICAgICAgY29uZi5uZXdMaXN0ZW5lciAmJiAodGhpcy5uZXdMaXN0ZW5lciA9IGNvbmYubmV3TGlzdGVuZXIpO1xyXG4gICAgICBjb25mLnZlcmJvc2VNZW1vcnlMZWFrICYmICh0aGlzLnZlcmJvc2VNZW1vcnlMZWFrID0gY29uZi52ZXJib3NlTWVtb3J5TGVhayk7XHJcblxyXG4gICAgICBpZiAodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJUcmVlID0ge307XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbG9nUG9zc2libGVNZW1vcnlMZWFrKGNvdW50LCBldmVudE5hbWUpIHtcclxuICAgIHZhciBlcnJvck1zZyA9ICcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcclxuICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcclxuICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJztcclxuXHJcbiAgICBpZih0aGlzLnZlcmJvc2VNZW1vcnlMZWFrKXtcclxuICAgICAgZXJyb3JNc2cgKz0gJyBFdmVudCBuYW1lOiAlcy4nO1xyXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yTXNnLCBjb3VudCwgZXZlbnROYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JNc2csIGNvdW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29uc29sZS50cmFjZSl7XHJcbiAgICAgIGNvbnNvbGUudHJhY2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcihjb25mKSB7XHJcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcclxuICAgIHRoaXMubmV3TGlzdGVuZXIgPSBmYWxzZTtcclxuICAgIHRoaXMudmVyYm9zZU1lbW9yeUxlYWsgPSBmYWxzZTtcclxuICAgIGNvbmZpZ3VyZS5jYWxsKHRoaXMsIGNvbmYpO1xyXG4gIH1cclxuICBFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGV4cG9ydGluZyBFdmVudEVtaXR0ZXIgcHJvcGVydHlcclxuXHJcbiAgLy9cclxuICAvLyBBdHRlbnRpb24sIGZ1bmN0aW9uIHJldHVybiB0eXBlIG5vdyBpcyBhcnJheSwgYWx3YXlzICFcclxuICAvLyBJdCBoYXMgemVybyBlbGVtZW50cyBpZiBubyBhbnkgbWF0Y2hlcyBmb3VuZCBhbmQgb25lIG9yIG1vcmVcclxuICAvLyBlbGVtZW50cyAobGVhZnMpIGlmIHRoZXJlIGFyZSBtYXRjaGVzXHJcbiAgLy9cclxuICBmdW5jdGlvbiBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWUsIGkpIHtcclxuICAgIGlmICghdHJlZSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB2YXIgbGlzdGVuZXJzPVtdLCBsZWFmLCBsZW4sIGJyYW5jaCwgeFRyZWUsIHh4VHJlZSwgaXNvbGF0ZWRCcmFuY2gsIGVuZFJlYWNoZWQsXHJcbiAgICAgICAgdHlwZUxlbmd0aCA9IHR5cGUubGVuZ3RoLCBjdXJyZW50VHlwZSA9IHR5cGVbaV0sIG5leHRUeXBlID0gdHlwZVtpKzFdO1xyXG4gICAgaWYgKGkgPT09IHR5cGVMZW5ndGggJiYgdHJlZS5fbGlzdGVuZXJzKSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIElmIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50KHMpIGxpc3QgYW5kIHRoZSB0cmVlIGhhcyBsaXN0ZW5lcnNcclxuICAgICAgLy8gaW52b2tlIHRob3NlIGxpc3RlbmVycy5cclxuICAgICAgLy9cclxuICAgICAgaWYgKHR5cGVvZiB0cmVlLl9saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBoYW5kbGVycyAmJiBoYW5kbGVycy5wdXNoKHRyZWUuX2xpc3RlbmVycyk7XHJcbiAgICAgICAgcmV0dXJuIFt0cmVlXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGxlYWYgPSAwLCBsZW4gPSB0cmVlLl9saXN0ZW5lcnMubGVuZ3RoOyBsZWFmIDwgbGVuOyBsZWFmKyspIHtcclxuICAgICAgICAgIGhhbmRsZXJzICYmIGhhbmRsZXJzLnB1c2godHJlZS5fbGlzdGVuZXJzW2xlYWZdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFt0cmVlXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgoY3VycmVudFR5cGUgPT09ICcqJyB8fCBjdXJyZW50VHlwZSA9PT0gJyoqJykgfHwgdHJlZVtjdXJyZW50VHlwZV0pIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gSWYgdGhlIGV2ZW50IGVtaXR0ZWQgaXMgJyonIGF0IHRoaXMgcGFydFxyXG4gICAgICAvLyBvciB0aGVyZSBpcyBhIGNvbmNyZXRlIG1hdGNoIGF0IHRoaXMgcGF0Y2hcclxuICAgICAgLy9cclxuICAgICAgaWYgKGN1cnJlbnRUeXBlID09PSAnKicpIHtcclxuICAgICAgICBmb3IgKGJyYW5jaCBpbiB0cmVlKSB7XHJcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycgJiYgdHJlZS5oYXNPd25Qcm9wZXJ0eShicmFuY2gpKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkrMSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xyXG4gICAgICB9IGVsc2UgaWYoY3VycmVudFR5cGUgPT09ICcqKicpIHtcclxuICAgICAgICBlbmRSZWFjaGVkID0gKGkrMSA9PT0gdHlwZUxlbmd0aCB8fCAoaSsyID09PSB0eXBlTGVuZ3RoICYmIG5leHRUeXBlID09PSAnKicpKTtcclxuICAgICAgICBpZihlbmRSZWFjaGVkICYmIHRyZWUuX2xpc3RlbmVycykge1xyXG4gICAgICAgICAgLy8gVGhlIG5leHQgZWxlbWVudCBoYXMgYSBfbGlzdGVuZXJzLCBhZGQgaXQgdG8gdGhlIGhhbmRsZXJzLlxyXG4gICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWUsIHR5cGVMZW5ndGgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoYnJhbmNoIGluIHRyZWUpIHtcclxuICAgICAgICAgIGlmIChicmFuY2ggIT09ICdfbGlzdGVuZXJzJyAmJiB0cmVlLmhhc093blByb3BlcnR5KGJyYW5jaCkpIHtcclxuICAgICAgICAgICAgaWYoYnJhbmNoID09PSAnKicgfHwgYnJhbmNoID09PSAnKionKSB7XHJcbiAgICAgICAgICAgICAgaWYodHJlZVticmFuY2hdLl9saXN0ZW5lcnMgJiYgIWVuZFJlYWNoZWQpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIHR5cGVMZW5ndGgpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoYnJhbmNoID09PSBuZXh0VHlwZSkge1xyXG4gICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkrMikpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIE5vIG1hdGNoIG9uIHRoaXMgb25lLCBzaGlmdCBpbnRvIHRoZSB0cmVlIGJ1dCBub3QgaW4gdGhlIHR5cGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2N1cnJlbnRUeXBlXSwgaSsxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgeFRyZWUgPSB0cmVlWycqJ107XHJcbiAgICBpZiAoeFRyZWUpIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gSWYgdGhlIGxpc3RlbmVyIHRyZWUgd2lsbCBhbGxvdyBhbnkgbWF0Y2ggZm9yIHRoaXMgcGFydCxcclxuICAgICAgLy8gdGhlbiByZWN1cnNpdmVseSBleHBsb3JlIGFsbCBicmFuY2hlcyBvZiB0aGUgdHJlZVxyXG4gICAgICAvL1xyXG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHhUcmVlLCBpKzEpO1xyXG4gICAgfVxyXG5cclxuICAgIHh4VHJlZSA9IHRyZWVbJyoqJ107XHJcbiAgICBpZih4eFRyZWUpIHtcclxuICAgICAgaWYoaSA8IHR5cGVMZW5ndGgpIHtcclxuICAgICAgICBpZih4eFRyZWUuX2xpc3RlbmVycykge1xyXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGxpc3RlbmVyIG9uIGEgJyoqJywgaXQgd2lsbCBjYXRjaCBhbGwsIHNvIGFkZCBpdHMgaGFuZGxlci5cclxuICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlLCB0eXBlTGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJ1aWxkIGFycmF5cyBvZiBtYXRjaGluZyBuZXh0IGJyYW5jaGVzIGFuZCBvdGhlcnMuXHJcbiAgICAgICAgZm9yKGJyYW5jaCBpbiB4eFRyZWUpIHtcclxuICAgICAgICAgIGlmKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnICYmIHh4VHJlZS5oYXNPd25Qcm9wZXJ0eShicmFuY2gpKSB7XHJcbiAgICAgICAgICAgIGlmKGJyYW5jaCA9PT0gbmV4dFR5cGUpIHtcclxuICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBuZXh0IGVsZW1lbnQgd2lsbCBtYXRjaCwgc28ganVtcCB0d2ljZS5cclxuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVticmFuY2hdLCBpKzIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoYnJhbmNoID09PSBjdXJyZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgIC8vIEN1cnJlbnQgbm9kZSBtYXRjaGVzLCBtb3ZlIGludG8gdGhlIHRyZWUuXHJcbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbYnJhbmNoXSwgaSsxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpc29sYXRlZEJyYW5jaCA9IHt9O1xyXG4gICAgICAgICAgICAgIGlzb2xhdGVkQnJhbmNoW2JyYW5jaF0gPSB4eFRyZWVbYnJhbmNoXTtcclxuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHsgJyoqJzogaXNvbGF0ZWRCcmFuY2ggfSwgaSsxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmKHh4VHJlZS5fbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgLy8gV2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgYW5kIHN0aWxsIG9uIGEgJyoqJ1xyXG4gICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlLCB0eXBlTGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIGlmKHh4VHJlZVsnKiddICYmIHh4VHJlZVsnKiddLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVsnKiddLCB0eXBlTGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsaXN0ZW5lcnM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBncm93TGlzdGVuZXJUcmVlKHR5cGUsIGxpc3RlbmVyKSB7XHJcblxyXG4gICAgdHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBMb29rcyBmb3IgdHdvIGNvbnNlY3V0aXZlICcqKicsIGlmIHNvLCBkb24ndCBhZGQgdGhlIGV2ZW50IGF0IGFsbC5cclxuICAgIC8vXHJcbiAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSB0eXBlLmxlbmd0aDsgaSsxIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYodHlwZVtpXSA9PT0gJyoqJyAmJiB0eXBlW2krMV0gPT09ICcqKicpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHJlZSA9IHRoaXMubGlzdGVuZXJUcmVlO1xyXG4gICAgdmFyIG5hbWUgPSB0eXBlLnNoaWZ0KCk7XHJcblxyXG4gICAgd2hpbGUgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgaWYgKCF0cmVlW25hbWVdKSB7XHJcbiAgICAgICAgdHJlZVtuYW1lXSA9IHt9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cmVlID0gdHJlZVtuYW1lXTtcclxuXHJcbiAgICAgIGlmICh0eXBlLmxlbmd0aCA9PT0gMCkge1xyXG5cclxuICAgICAgICBpZiAoIXRyZWUuX2xpc3RlbmVycykge1xyXG4gICAgICAgICAgdHJlZS5fbGlzdGVuZXJzID0gbGlzdGVuZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB0cmVlLl9saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzID0gW3RyZWUuX2xpc3RlbmVyc107XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG5cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgIXRyZWUuX2xpc3RlbmVycy53YXJuZWQgJiZcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA+IDAgJiZcclxuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLmxlbmd0aCA+IHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnNcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMud2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbG9nUG9zc2libGVNZW1vcnlMZWFrLmNhbGwodGhpcywgdHJlZS5fbGlzdGVuZXJzLmxlbmd0aCwgbmFtZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIG5hbWUgPSB0eXBlLnNoaWZ0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW5cclxuICAvLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcclxuICAvLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cclxuICAvL1xyXG4gIC8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xyXG4gIC8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmRlbGltaXRlciA9ICcuJztcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XHJcbiAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XHJcbiAgICAgIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBuO1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbmYpIHRoaXMuX2NvbmYgPSB7fTtcclxuICAgICAgdGhpcy5fY29uZi5tYXhMaXN0ZW5lcnMgPSBuO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnQgPSAnJztcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKSB7XHJcbiAgICB0aGlzLm1hbnkoZXZlbnQsIDEsIGZuKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbnkgb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xyXG4gICAgICBpZiAoLS10dGwgPT09IDApIHtcclxuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGlzdGVuZXIuX29yaWdpbiA9IGZuO1xyXG5cclxuICAgIHRoaXMub24oZXZlbnQsIGxpc3RlbmVyKTtcclxuXHJcbiAgICByZXR1cm4gc2VsZjtcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xyXG5cclxuICAgIGlmICh0eXBlID09PSAnbmV3TGlzdGVuZXInICYmICF0aGlzLm5ld0xpc3RlbmVyKSB7XHJcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIHZhciBhcmdzLGwsaSxqO1xyXG4gICAgdmFyIGhhbmRsZXI7XHJcblxyXG4gICAgaWYgKHRoaXMuX2FsbCAmJiB0aGlzLl9hbGwubGVuZ3RoKSB7XHJcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9hbGwuc2xpY2UoKTtcclxuICAgICAgaWYgKGFsID4gMykge1xyXG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwpO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBhbDsgaisrKSBhcmdzW2pdID0gYXJndW1lbnRzW2pdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcclxuICAgICAgICBzd2l0Y2ggKGFsKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgaGFuZGxlciA9IFtdO1xyXG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcclxuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlciwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xyXG4gICAgICAgIHN3aXRjaCAoYWwpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xyXG4gICAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xyXG4gICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgIC8vIG5lZWQgdG8gbWFrZSBjb3B5IG9mIGhhbmRsZXJzIGJlY2F1c2UgbGlzdCBjYW4gY2hhbmdlIGluIHRoZSBtaWRkbGVcclxuICAgICAgICAvLyBvZiBlbWl0IGNhbGxcclxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5zbGljZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci5sZW5ndGgpIHtcclxuICAgICAgaWYgKGFsID4gMykge1xyXG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcclxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XHJcbiAgICAgICAgc3dpdGNoIChhbCkge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBoYW5kbGVyW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2FsbCAmJiB0eXBlID09PSAnZXJyb3InKSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAhIXRoaXMuX2FsbDtcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXRBc3luYyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICduZXdMaXN0ZW5lcicgJiYgIXRoaXMubmV3TGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtmYWxzZV0pOyB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb21pc2VzPSBbXTtcclxuXHJcbiAgICB2YXIgYWwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgdmFyIGFyZ3MsbCxpLGo7XHJcbiAgICB2YXIgaGFuZGxlcjtcclxuXHJcbiAgICBpZiAodGhpcy5fYWxsKSB7XHJcbiAgICAgIGlmIChhbCA+IDMpIHtcclxuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsKTtcclxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqXSA9IGFyZ3VtZW50c1tqXTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5fYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xyXG4gICAgICAgIHN3aXRjaCAoYWwpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uYXBwbHkodGhpcywgYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgIGhhbmRsZXIgPSBbXTtcclxuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XHJcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXIsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcclxuICAgICAgc3dpdGNoIChhbCkge1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcykpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcclxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XHJcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChoYW5kbGVyICYmIGhhbmRsZXIubGVuZ3RoKSB7XHJcbiAgICAgIGlmIChhbCA+IDMpIHtcclxuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XHJcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xyXG4gICAgICAgIHN3aXRjaCAoYWwpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uY2FsbCh0aGlzKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmFwcGx5KHRoaXMsIGFyZ3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2FsbCAmJiB0eXBlID09PSAnZXJyb3InKSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhcmd1bWVudHNbMV0pOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5vbkFueSh0eXBlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uIG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcclxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJzXCIuXHJcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xyXG5cclxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgIGdyb3dMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XHJcbiAgICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxyXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIENoYW5nZSB0byBhcnJheS5cclxuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxyXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgJiZcclxuICAgICAgICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID4gMCAmJlxyXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xyXG4gICAgICAgIGxvZ1Bvc3NpYmxlTWVtb3J5TGVhay5jYWxsKHRoaXMsIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgsIHR5cGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbkFueSA9IGZ1bmN0aW9uKGZuKSB7XHJcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25Bbnkgb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fYWxsKSB7XHJcbiAgICAgIHRoaXMuX2FsbCA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0aGUgZnVuY3Rpb24gdG8gdGhlIGV2ZW50IGxpc3RlbmVyIGNvbGxlY3Rpb24uXHJcbiAgICB0aGlzLl9hbGwucHVzaChmbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhhbmRsZXJzLGxlYWZzPVtdO1xyXG5cclxuICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XHJcbiAgICAgIGxlYWZzID0gc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgbnVsbCwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cclxuICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xyXG4gICAgICBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICAgICAgbGVhZnMucHVzaCh7X2xpc3RlbmVyczpoYW5kbGVyc30pO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGlMZWFmPTA7IGlMZWFmPGxlYWZzLmxlbmd0aDsgaUxlYWYrKykge1xyXG4gICAgICB2YXIgbGVhZiA9IGxlYWZzW2lMZWFmXTtcclxuICAgICAgaGFuZGxlcnMgPSBsZWFmLl9saXN0ZW5lcnM7XHJcbiAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSAtMTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoaGFuZGxlcnNbaV0gPT09IGxpc3RlbmVyIHx8XHJcbiAgICAgICAgICAgIChoYW5kbGVyc1tpXS5saXN0ZW5lciAmJiBoYW5kbGVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHx8XHJcbiAgICAgICAgICAgIChoYW5kbGVyc1tpXS5fb3JpZ2luICYmIGhhbmRsZXJzW2ldLl9vcmlnaW4gPT09IGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgICAgICBsZWFmLl9saXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKHBvc2l0aW9uLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGxlYWYuX2xpc3RlbmVycztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgdHlwZSwgbGlzdGVuZXIpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChoYW5kbGVycyA9PT0gbGlzdGVuZXIgfHxcclxuICAgICAgICAoaGFuZGxlcnMubGlzdGVuZXIgJiYgaGFuZGxlcnMubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB8fFxyXG4gICAgICAgIChoYW5kbGVycy5fb3JpZ2luICYmIGhhbmRsZXJzLl9vcmlnaW4gPT09IGxpc3RlbmVyKSkge1xyXG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgICAgIGRlbGV0ZSBsZWFmLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsIHR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3Qocm9vdCkge1xyXG4gICAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocm9vdCk7XHJcbiAgICAgIGZvciAodmFyIGkgaW4ga2V5cykge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgIHZhciBvYmogPSByb290W2tleV07XHJcbiAgICAgICAgaWYgKChvYmogaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHx8IChvYmogPT09IG51bGwpKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdChyb290W2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGRlbGV0ZSByb290W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHRoaXMubGlzdGVuZXJUcmVlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZkFueSA9IGZ1bmN0aW9uKGZuKSB7XHJcbiAgICB2YXIgaSA9IDAsIGwgPSAwLCBmbnM7XHJcbiAgICBpZiAoZm4gJiYgdGhpcy5fYWxsICYmIHRoaXMuX2FsbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGZucyA9IHRoaXMuX2FsbDtcclxuICAgICAgZm9yKGkgPSAwLCBsID0gZm5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmKGZuID09PSBmbnNbaV0pIHtcclxuICAgICAgICAgIGZucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lckFueVwiLCBmbik7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZucyA9IHRoaXMuX2FsbDtcclxuICAgICAgZm9yKGkgPSAwLCBsID0gZm5zLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lckFueVwiLCBmbnNbaV0pO1xyXG4gICAgICB0aGlzLl9hbGwgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZjtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAhdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XHJcbiAgICAgIHZhciBsZWFmcyA9IHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIG51bGwsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XHJcblxyXG4gICAgICBmb3IgKHZhciBpTGVhZj0wOyBpTGVhZjxsZWFmcy5sZW5ndGg7IGlMZWFmKyspIHtcclxuICAgICAgICB2YXIgbGVhZiA9IGxlYWZzW2lMZWFmXTtcclxuICAgICAgICBsZWFmLl9saXN0ZW5lcnMgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHMpIHtcclxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgdmFyIGhhbmRsZXJzID0gW107XHJcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xyXG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVycywgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcclxuICAgICAgcmV0dXJuIGhhbmRsZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFtdO1xyXG4gICAgaWYgKCFpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcclxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnNBbnkgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBpZih0aGlzLl9hbGwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2FsbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gIH07XHJcblxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgLy8gQ29tbW9uSlNcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIC8vIEJyb3dzZXIgZ2xvYmFsLlxyXG4gICAgd2luZG93LkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7XHJcbiAgfVxyXG59KCk7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gSW50ZW50aW9uYWxseSB1c2UgbmF0aXZlLXByb21pc2Utb25seSBoZXJlLi4uIE90aGVyIHByb21pc2UgbGlicmFyaWVzIChlczYtcHJvbWlzZSlcbi8vIGR1Y2stcHVuY2ggdGhlIGdsb2JhbCBQcm9taXNlIGRlZmluaXRpb24gd2hpY2ggbWVzc2VzIHVwIEFuZ3VsYXIgMiBzaW5jZSBpdFxuLy8gYWxzbyBkdWNrLXB1bmNoZXMgdGhlIGdsb2JhbCBQcm9taXNlIGRlZmluaXRpb24uIEZvciBub3csIGtlZXAgbmF0aXZlLXByb21pc2Utb25seS5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoXCJuYXRpdmUtcHJvbWlzZS1vbmx5XCIpO1xucmVxdWlyZSgnd2hhdHdnLWZldGNoJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMicpLkV2ZW50RW1pdHRlcjI7XG52YXIgY29weSA9IHJlcXVpcmUoJ3NoYWxsb3ctY29weScpO1xuXG4vKipcbiAqIFRoZSBGb3JtaW8gaW50ZXJmYWNlIGNsYXNzLlxuICpcbiAqICAgbGV0IGZvcm1pbyA9IG5ldyBGb3JtaW8oJ2h0dHBzOi8vZXhhbXBsZXMuZm9ybS5pby9leGFtcGxlJyk7XG4gKi9cblxudmFyIEZvcm1pbyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9ybWlvKHBhdGgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1pbyk7XG5cbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhbiBpbnN0YW5jZSBvZiBGb3JtaW8uXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZvcm1pbykpIHtcbiAgICAgIHJldHVybiBuZXcgRm9ybWlvKHBhdGgpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgb3VyIHZhcmlhYmxlcy5cbiAgICB0aGlzLmJhc2UgPSAnJztcbiAgICB0aGlzLnByb2plY3RzVXJsID0gJyc7XG4gICAgdGhpcy5wcm9qZWN0VXJsID0gJyc7XG4gICAgdGhpcy5wcm9qZWN0SWQgPSAnJztcbiAgICB0aGlzLmZvcm1VcmwgPSAnJztcbiAgICB0aGlzLmZvcm1zVXJsID0gJyc7XG4gICAgdGhpcy5mb3JtSWQgPSAnJztcbiAgICB0aGlzLnN1Ym1pc3Npb25zVXJsID0gJyc7XG4gICAgdGhpcy5zdWJtaXNzaW9uVXJsID0gJyc7XG4gICAgdGhpcy5zdWJtaXNzaW9uSWQgPSAnJztcbiAgICB0aGlzLmFjdGlvbnNVcmwgPSAnJztcbiAgICB0aGlzLmFjdGlvbklkID0gJyc7XG4gICAgdGhpcy5hY3Rpb25VcmwgPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0gJyc7XG5cbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnYmFzZScpKSB7XG4gICAgICB0aGlzLmJhc2UgPSBvcHRpb25zLmJhc2U7XG4gICAgfSBlbHNlIGlmIChGb3JtaW8uYmFzZVVybCkge1xuICAgICAgdGhpcy5iYXNlID0gRm9ybWlvLmJhc2VVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmFzZSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLm1hdGNoKC9odHRwW3NdPzpcXC9cXC9hcGkuLylbMF07XG4gICAgfVxuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAvLyBBbGxvdyB1c2VyIHRvIGNyZWF0ZSBuZXcgcHJvamVjdHMgaWYgdGhpcyB3YXMgaW5zdGFudGlhdGVkIHdpdGhvdXRcbiAgICAgIC8vIGEgdXJsXG4gICAgICB0aGlzLnByb2plY3RVcmwgPSB0aGlzLmJhc2UgKyAnL3Byb2plY3QnO1xuICAgICAgdGhpcy5wcm9qZWN0c1VybCA9IHRoaXMuYmFzZSArICcvcHJvamVjdCc7XG4gICAgICB0aGlzLnByb2plY3RJZCA9IGZhbHNlO1xuICAgICAgdGhpcy5xdWVyeSA9ICcnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdwcm9qZWN0JykpIHtcbiAgICAgIHRoaXMucHJvamVjdFVybCA9IG9wdGlvbnMucHJvamVjdDtcbiAgICB9XG5cbiAgICB2YXIgcHJvamVjdCA9IHRoaXMucHJvamVjdFVybCB8fCBGb3JtaW8ucHJvamVjdFVybDtcblxuICAgIC8vIFRoZSBiYXNlVVJMIGlzIHRoZSBzYW1lIGFzIHRoZSBwcm9qZWN0VXJsLiBUaGlzIGlzIGFsbW9zdCBjZXJ0YWlubHkgYWdhaW5zdFxuICAgIC8vIHRoZSBPcGVuIFNvdXJjZSBzZXJ2ZXIuXG4gICAgaWYgKHByb2plY3QgJiYgdGhpcy5iYXNlID09PSBwcm9qZWN0KSB7XG4gICAgICB0aGlzLm5vUHJvamVjdCA9IHRydWU7XG4gICAgICB0aGlzLnByb2plY3RVcmwgPSB0aGlzLmJhc2U7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIHRvIGFuIGFic29sdXRlIHBhdGguXG4gICAgaWYgKHBhdGguaW5kZXhPZignaHR0cCcpICE9PSAwICYmIHBhdGguaW5kZXhPZignLy8nKSAhPT0gMCkge1xuICAgICAgcGF0aCA9IHRoaXMuYmFzZSArIHBhdGg7XG4gICAgfVxuXG4gICAgdmFyIGhvc3RwYXJ0cyA9IEZvcm1pby5nZXRVcmxQYXJ0cyhwYXRoKTtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgaG9zdE5hbWUgPSBob3N0cGFydHNbMV0gKyBob3N0cGFydHNbMl07XG4gICAgcGF0aCA9IGhvc3RwYXJ0cy5sZW5ndGggPiAzID8gaG9zdHBhcnRzWzNdIDogJyc7XG4gICAgdmFyIHF1ZXJ5cGFydHMgPSBwYXRoLnNwbGl0KCc/Jyk7XG4gICAgaWYgKHF1ZXJ5cGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgcGF0aCA9IHF1ZXJ5cGFydHNbMF07XG4gICAgICB0aGlzLnF1ZXJ5ID0gJz8nICsgcXVlcnlwYXJ0c1sxXTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBhIHNwZWNpZmljIHBhdGguXG4gICAgdmFyIHJlZ2lzdGVyUGF0aCA9IGZ1bmN0aW9uIHJlZ2lzdGVyUGF0aChuYW1lLCBiYXNlKSB7XG4gICAgICBfdGhpc1tuYW1lICsgJ3NVcmwnXSA9IGJhc2UgKyAnLycgKyBuYW1lO1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFwvJyArIG5hbWUgKyAnXFwvKFteL10rKScpO1xuICAgICAgaWYgKHBhdGguc2VhcmNoKHJlZ2V4KSAhPT0gLTEpIHtcbiAgICAgICAgcGFydHMgPSBwYXRoLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgX3RoaXNbbmFtZSArICdVcmwnXSA9IHBhcnRzID8gYmFzZSArIHBhcnRzWzBdIDogJyc7XG4gICAgICAgIF90aGlzW25hbWUgKyAnSWQnXSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXSA6ICcnO1xuICAgICAgICBiYXNlICs9IHBhcnRzWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfTtcblxuICAgIC8vIFJlZ2lzdGVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICAgIHZhciByZWdpc3Rlckl0ZW1zID0gZnVuY3Rpb24gcmVnaXN0ZXJJdGVtcyhpdGVtcywgYmFzZSwgc3RhdGljQmFzZSkge1xuICAgICAgZm9yICh2YXIgaSBpbiBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVySXRlbXMoaXRlbSwgYmFzZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdCYXNlID0gcmVnaXN0ZXJQYXRoKGl0ZW0sIGJhc2UpO1xuICAgICAgICAgICAgYmFzZSA9IHN0YXRpY0Jhc2UgPyBiYXNlIDogbmV3QmFzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLnByb2plY3RVcmwgfHwgdGhpcy5wcm9qZWN0VXJsID09PSB0aGlzLmJhc2UpIHtcbiAgICAgIHRoaXMucHJvamVjdFVybCA9IGhvc3ROYW1lO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ub1Byb2plY3QpIHtcbiAgICAgIC8vIERldGVybWluZSB0aGUgcHJvamVjdFVybCBhbmQgcHJvamVjdElkXG4gICAgICBpZiAocGF0aC5zZWFyY2goLyhefFxcLykocHJvamVjdCkoJHxcXC8pLykgIT09IC0xKSB7XG4gICAgICAgIC8vIEdldCBwcm9qZWN0IGlkIGFzIHByb2plY3QvOnByb2plY3RJZC5cbiAgICAgICAgcmVnaXN0ZXJJdGVtcyhbJ3Byb2plY3QnXSwgaG9zdE5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChob3N0TmFtZSA9PT0gdGhpcy5iYXNlKSB7XG4gICAgICAgIC8vIEdldCBwcm9qZWN0IGlkIGFzIGZpcnN0IHBhcnQgb2YgcGF0aCAoc3ViZGlyZWN0b3J5KS5cbiAgICAgICAgaWYgKGhvc3RwYXJ0cy5sZW5ndGggPiAzICYmIHBhdGguc3BsaXQoJy8nKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIHBhdGhQYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgICBwYXRoUGFydHMuc2hpZnQoKTsgLy8gVGhyb3cgYXdheSB0aGUgZmlyc3QgLy5cbiAgICAgICAgICB0aGlzLnByb2plY3RJZCA9IHBhdGhQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgIHBhdGggPSAnLycgKyBwYXRoUGFydHMuam9pbignLycpO1xuICAgICAgICAgIHRoaXMucHJvamVjdFVybCA9IGhvc3ROYW1lICsgJy8nICsgdGhpcy5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCBwcm9qZWN0IGlkIGZyb20gc3ViZG9tYWluLlxuICAgICAgICBpZiAoaG9zdHBhcnRzLmxlbmd0aCA+IDIgJiYgKGhvc3RwYXJ0c1syXS5zcGxpdCgnLicpLmxlbmd0aCA+IDIgfHwgaG9zdE5hbWUuaW5kZXhPZignbG9jYWxob3N0JykgIT09IC0xKSkge1xuICAgICAgICAgIHRoaXMucHJvamVjdFVybCA9IGhvc3ROYW1lO1xuICAgICAgICAgIHRoaXMucHJvamVjdElkID0gaG9zdHBhcnRzWzJdLnNwbGl0KCcuJylbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucHJvamVjdHNVcmwgPSB0aGlzLnByb2plY3RzVXJsIHx8IHRoaXMuYmFzZSArICcvcHJvamVjdCc7XG4gICAgfVxuXG4gICAgLy8gQ29uZmlndXJlIEZvcm0gdXJscyBhbmQgZm9ybSBpZHMuXG4gICAgaWYgKHBhdGguc2VhcmNoKC8oXnxcXC8pKHByb2plY3R8Zm9ybSkoJHxcXC8pLykgIT09IC0xKSB7XG4gICAgICByZWdpc3Rlckl0ZW1zKFsnZm9ybScsIFsnc3VibWlzc2lvbicsICdhY3Rpb24nXV0sIHRoaXMucHJvamVjdFVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdWJSZWdFeCA9IG5ldyBSZWdFeHAoJ1xcLyhzdWJtaXNzaW9ufGFjdGlvbikoJHxcXC8uKiknKTtcbiAgICAgIHZhciBzdWJzID0gcGF0aC5tYXRjaChzdWJSZWdFeCk7XG4gICAgICB0aGlzLnBhdGhUeXBlID0gc3VicyAmJiBzdWJzLmxlbmd0aCA+IDEgPyBzdWJzWzFdIDogJyc7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHN1YlJlZ0V4LCAnJyk7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgdGhpcy5mb3Jtc1VybCA9IHRoaXMucHJvamVjdFVybCArICcvZm9ybSc7XG4gICAgICB0aGlzLmZvcm1VcmwgPSB0aGlzLnByb2plY3RVcmwgKyBwYXRoO1xuICAgICAgdGhpcy5mb3JtSWQgPSBwYXRoLnJlcGxhY2UoL15cXC8rfFxcLyskL2csICcnKTtcbiAgICAgIHZhciBpdGVtcyA9IFsnc3VibWlzc2lvbicsICdhY3Rpb24nXTtcbiAgICAgIGZvciAodmFyIGkgaW4gaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICB0aGlzW2l0ZW0gKyAnc1VybCddID0gdGhpcy5wcm9qZWN0VXJsICsgcGF0aCArICcvJyArIGl0ZW07XG4gICAgICAgICAgaWYgKHRoaXMucGF0aFR5cGUgPT09IGl0ZW0gJiYgc3Vicy5sZW5ndGggPiAyICYmIHN1YnNbMl0pIHtcbiAgICAgICAgICAgIHRoaXNbaXRlbSArICdJZCddID0gc3Vic1syXS5yZXBsYWNlKC9eXFwvK3xcXC8rJC9nLCAnJyk7XG4gICAgICAgICAgICB0aGlzW2l0ZW0gKyAnVXJsJ10gPSB0aGlzLnByb2plY3RVcmwgKyBwYXRoICsgc3Vic1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGFwcCB1cmwgaWYgaXQgaXMgbm90IHNldC5cbiAgICBpZiAoIUZvcm1pby5wcm9qZWN0VXJsU2V0KSB7XG4gICAgICBGb3JtaW8ucHJvamVjdFVybCA9IHRoaXMucHJvamVjdFVybDtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRm9ybWlvLCBbe1xuICAgIGtleTogJ2RlbGV0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUodHlwZSwgb3B0cykge1xuICAgICAgdmFyIF9pZCA9IHR5cGUgKyAnSWQnO1xuICAgICAgdmFyIF91cmwgPSB0eXBlICsgJ1VybCc7XG4gICAgICBpZiAoIXRoaXNbX2lkXSkge1xuICAgICAgICBQcm9taXNlLnJlamVjdCgnTm90aGluZyB0byBkZWxldGUnKTtcbiAgICAgIH1cbiAgICAgIEZvcm1pby5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QodHlwZSwgdGhpc1tfdXJsXSwgJ2RlbGV0ZScsIG51bGwsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXgodHlwZSwgcXVlcnksIG9wdHMpIHtcbiAgICAgIHZhciBfdXJsID0gdHlwZSArICdVcmwnO1xuICAgICAgcXVlcnkgPSBxdWVyeSB8fCAnJztcbiAgICAgIGlmIChxdWVyeSAmJiAodHlwZW9mIHF1ZXJ5ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihxdWVyeSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBxdWVyeSA9ICc/JyArIEZvcm1pby5zZXJpYWxpemUocXVlcnkucGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KHR5cGUsIHRoaXNbX3VybF0gKyBxdWVyeSwgJ2dldCcsIG51bGwsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NhdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlKHR5cGUsIGRhdGEsIG9wdHMpIHtcbiAgICAgIHZhciBfaWQgPSB0eXBlICsgJ0lkJztcbiAgICAgIHZhciBfdXJsID0gdHlwZSArICdVcmwnO1xuICAgICAgdmFyIG1ldGhvZCA9IHRoaXNbX2lkXSB8fCBkYXRhLl9pZCA/ICdwdXQnIDogJ3Bvc3QnO1xuICAgICAgdmFyIHJlcVVybCA9IHRoaXNbX2lkXSA/IHRoaXNbX3VybF0gOiB0aGlzW3R5cGUgKyAnc1VybCddO1xuICAgICAgaWYgKCF0aGlzW19pZF0gJiYgZGF0YS5faWQgJiYgbWV0aG9kID09PSAncHV0JyAmJiByZXFVcmwuaW5kZXhPZihkYXRhLl9pZCkgPT09IC0xKSB7XG4gICAgICAgIHJlcVVybCArPSAnLycgKyBkYXRhLl9pZDtcbiAgICAgIH1cbiAgICAgIEZvcm1pby5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QodHlwZSwgcmVxVXJsICsgdGhpcy5xdWVyeSwgbWV0aG9kLCBkYXRhLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh0eXBlLCBxdWVyeSwgb3B0cykge1xuICAgICAgdmFyIF9pZCA9IHR5cGUgKyAnSWQnO1xuICAgICAgdmFyIF91cmwgPSB0eXBlICsgJ1VybCc7XG4gICAgICBpZiAocXVlcnkgJiYgKHR5cGVvZiBxdWVyeSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocXVlcnkpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcXVlcnkgPSBGb3JtaW8uc2VyaWFsaXplKHF1ZXJ5LnBhcmFtcyk7XG4gICAgICB9XG4gICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5ID8gdGhpcy5xdWVyeSArICcmJyArIHF1ZXJ5IDogJz8nICsgcXVlcnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeSA9IHRoaXMucXVlcnk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXNbX2lkXSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ01pc3NpbmcgJyArIF9pZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCh0eXBlLCB0aGlzW191cmxdICsgcXVlcnksICdnZXQnLCBudWxsLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYWtlUmVxdWVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KHR5cGUsIHVybCwgbWV0aG9kLCBkYXRhLCBvcHRzKSB7XG4gICAgICBtZXRob2QgPSAobWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCFvcHRzIHx8ICh0eXBlb2Ygb3B0cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0cykpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciByZXF1ZXN0QXJncyA9IHtcbiAgICAgICAgZm9ybWlvOiB0aGlzLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIG9wdHM6IG9wdHNcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gRm9ybWlvLnBsdWdpbldhaXQoJ3ByZVJlcXVlc3QnLCByZXF1ZXN0QXJncykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2luR2V0KCdyZXF1ZXN0JywgcmVxdWVzdEFyZ3MpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBGb3JtaW8ucmVxdWVzdCh1cmwsIG1ldGhvZCwgZGF0YSwgb3B0cy5oZWFkZXIsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gRm9ybWlvLnBsdWdpbkFsdGVyKCd3cmFwUmVxdWVzdFByb21pc2UnLCByZXF1ZXN0LCByZXF1ZXN0QXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZFByb2plY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkUHJvamVjdChxdWVyeSwgb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZCgncHJvamVjdCcsIHF1ZXJ5LCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYXZlUHJvamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmVQcm9qZWN0KGRhdGEsIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhdmUoJ3Byb2plY3QnLCBkYXRhLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVQcm9qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlUHJvamVjdChvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxldGUoJ3Byb2plY3QnLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkRm9ybScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRGb3JtKHF1ZXJ5LCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkKCdmb3JtJywgcXVlcnksIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NhdmVGb3JtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZUZvcm0oZGF0YSwgb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuc2F2ZSgnZm9ybScsIGRhdGEsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUZvcm0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVGb3JtKG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGV0ZSgnZm9ybScsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRGb3JtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRGb3JtcyhxdWVyeSwgb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXgoJ2Zvcm1zJywgcXVlcnksIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRTdWJtaXNzaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFN1Ym1pc3Npb24ocXVlcnksIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWQoJ3N1Ym1pc3Npb24nLCBxdWVyeSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2F2ZVN1Ym1pc3Npb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlU3VibWlzc2lvbihkYXRhLCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYXZlKCdzdWJtaXNzaW9uJywgZGF0YSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlU3VibWlzc2lvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVN1Ym1pc3Npb24ob3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKCdzdWJtaXNzaW9uJywgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZFN1Ym1pc3Npb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFN1Ym1pc3Npb25zKHF1ZXJ5LCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCgnc3VibWlzc2lvbnMnLCBxdWVyeSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZEFjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRBY3Rpb24ocXVlcnksIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWQoJ2FjdGlvbicsIHF1ZXJ5LCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYXZlQWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZUFjdGlvbihkYXRhLCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYXZlKCdhY3Rpb24nLCBkYXRhLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVBY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVBY3Rpb24ob3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKCdhY3Rpb24nLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkQWN0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRBY3Rpb25zKHF1ZXJ5LCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCgnYWN0aW9ucycsIHF1ZXJ5LCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdmFpbGFibGVBY3Rpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXZhaWxhYmxlQWN0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KCdhdmFpbGFibGVBY3Rpb25zJywgdGhpcy5mb3JtVXJsICsgJy9hY3Rpb25zJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWN0aW9uSW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGlvbkluZm8obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QoJ2FjdGlvbkluZm8nLCB0aGlzLmZvcm1VcmwgKyAnL2FjdGlvbnMvJyArIG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0ZW1wb3JhcnkgYXV0aGVudGljYXRpb24gdG9rZW4gZm9yIHNpbmdsZSBwdXJwb3NlIHRva2VuIGdlbmVyYXRpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFRlbXBUb2tlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRlbXBUb2tlbihleHBpcmUsIGFsbG93ZWQpIHtcbiAgICAgIHZhciB0b2tlbiA9IEZvcm1pby5nZXRUb2tlbigpO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1lvdSBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gZ2VuZXJhdGUgYSB0ZW1wb3JhcnkgYXV0aCB0b2tlbi4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KCd0ZW1wVG9rZW4nLCB0aGlzLnByb2plY3RVcmwgKyAnL3Rva2VuJywgJ0dFVCcsIG51bGwsIHtcbiAgICAgICAgaGVhZGVyOiBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgJ3gtZXhwaXJlJzogZXhwaXJlLFxuICAgICAgICAgICd4LWFsbG93JzogYWxsb3dlZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBsb2FkRmlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwbG9hZEZpbGUoc3RvcmFnZSwgZmlsZSwgZmlsZU5hbWUsIGRpciwgcHJvZ3Jlc3NDYWxsYmFjaywgdXJsKSB7XG4gICAgICB2YXIgcmVxdWVzdEFyZ3MgPSB7XG4gICAgICAgIHByb3ZpZGVyOiBzdG9yYWdlLFxuICAgICAgICBtZXRob2Q6ICd1cGxvYWQnLFxuICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgIGRpcjogZGlyXG4gICAgICB9O1xuICAgICAgdmFyIHJlcXVlc3QgPSBGb3JtaW8ucGx1Z2luV2FpdCgncHJlUmVxdWVzdCcsIHJlcXVlc3RBcmdzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5HZXQoJ2ZpbGVSZXF1ZXN0JywgcmVxdWVzdEFyZ3MpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChzdG9yYWdlICYmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpZiAoRm9ybWlvLnByb3ZpZGVycy5zdG9yYWdlLmhhc093blByb3BlcnR5KHN0b3JhZ2UpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBGb3JtaW8ucHJvdmlkZXJzLnN0b3JhZ2Vbc3RvcmFnZV0odGhpcyk7XG4gICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci51cGxvYWRGaWxlKGZpbGUsIGZpbGVOYW1lLCBkaXIsIHByb2dyZXNzQ2FsbGJhY2ssIHVybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyAnU3RvcmFnZSBwcm92aWRlciBub3QgZm91bmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHsgdXJsOiAnJyB9O1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5BbHRlcignd3JhcEZpbGVSZXF1ZXN0UHJvbWlzZScsIHJlcXVlc3QsIHJlcXVlc3RBcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkb3dubG9hZEZpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3dubG9hZEZpbGUoZmlsZSkge1xuICAgICAgdmFyIHJlcXVlc3RBcmdzID0ge1xuICAgICAgICBtZXRob2Q6ICdkb3dubG9hZCcsXG4gICAgICAgIGZpbGU6IGZpbGVcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gRm9ybWlvLnBsdWdpbldhaXQoJ3ByZVJlcXVlc3QnLCByZXF1ZXN0QXJncykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2luR2V0KCdmaWxlUmVxdWVzdCcsIHJlcXVlc3RBcmdzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoZmlsZS5zdG9yYWdlICYmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpZiAoRm9ybWlvLnByb3ZpZGVycy5zdG9yYWdlLmhhc093blByb3BlcnR5KGZpbGUuc3RvcmFnZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEZvcm1pby5wcm92aWRlcnMuc3RvcmFnZVtmaWxlLnN0b3JhZ2VdKHRoaXMpO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZG93bmxvYWRGaWxlKGZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgJ1N0b3JhZ2UgcHJvdmlkZXIgbm90IGZvdW5kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCB7IHVybDogJycgfTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2luQWx0ZXIoJ3dyYXBGaWxlUmVxdWVzdFByb21pc2UnLCByZXF1ZXN0LCByZXF1ZXN0QXJncyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdsb2FkUHJvamVjdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkUHJvamVjdHMocXVlcnksIG9wdHMpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkgfHwgJyc7XG4gICAgICBpZiAoKHR5cGVvZiBxdWVyeSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocXVlcnkpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcXVlcnkgPSAnPycgKyBzZXJpYWxpemUocXVlcnkucGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGb3JtaW8ubWFrZVN0YXRpY1JlcXVlc3QoRm9ybWlvLmJhc2VVcmwgKyAnL3Byb2plY3QnICsgcXVlcnkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFVybFBhcnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VXJsUGFydHModXJsKSB7XG4gICAgICB2YXIgcmVnZXggPSAnXihodHRwW3NdPzpcXFxcL1xcXFwvKSc7XG4gICAgICBpZiAodGhpcy5iYXNlICYmIHVybC5pbmRleE9mKHRoaXMuYmFzZSkgPT09IDApIHtcbiAgICAgICAgcmVnZXggKz0gJygnICsgdGhpcy5iYXNlLnJlcGxhY2UoL15odHRwW3NdPzpcXC9cXC8vLCAnJykgKyAnKSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdleCArPSAnKFteL10rKSc7XG4gICAgICB9XG4gICAgICByZWdleCArPSAnKCR8XFxcXC8uKiknO1xuICAgICAgcmV0dXJuIHVybC5tYXRjaChuZXcgUmVnRXhwKHJlZ2V4KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VyaWFsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICAgICAgdmFyIHN0ciA9IFtdO1xuICAgICAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIHN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtwXSkpO1xuICAgICAgICB9XG4gICAgICB9cmV0dXJuIHN0ci5qb2luKFwiJlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYWtlU3RhdGljUmVxdWVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VTdGF0aWNSZXF1ZXN0KHVybCwgbWV0aG9kLCBkYXRhLCBvcHRzKSB7XG4gICAgICBtZXRob2QgPSAobWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCFvcHRzIHx8ICh0eXBlb2Ygb3B0cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0cykpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG4gICAgICB2YXIgcmVxdWVzdEFyZ3MgPSB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfTtcblxuICAgICAgdmFyIHJlcXVlc3QgPSBGb3JtaW8ucGx1Z2luV2FpdCgncHJlUmVxdWVzdCcsIHJlcXVlc3RBcmdzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5HZXQoJ3N0YXRpY1JlcXVlc3QnLCByZXF1ZXN0QXJncykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1pby5yZXF1ZXN0KHVybCwgbWV0aG9kLCBkYXRhLCBvcHRzLmhlYWRlciwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2luQWx0ZXIoJ3dyYXBTdGF0aWNSZXF1ZXN0UHJvbWlzZScsIHJlcXVlc3QsIHJlcXVlc3RBcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXF1ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG1ldGhvZCwgZGF0YSwgaGVhZGVyLCBvcHRzKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05vIHVybCBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgbWV0aG9kID0gKG1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKTtcblxuICAgICAgLy8gRm9yIHJldmVyc2UgY29tcGF0aWJpbGl0eSwgaWYgdGhleSBwcm92aWRlZCB0aGUgaWdub3JlQ2FjaGUgcGFyYW1ldGVyLFxuICAgICAgLy8gdGhlbiBjaGFuZ2UgaXQgYmFjayB0byB0aGUgb3B0aW9ucyBmb3JtYXQgd2hlcmUgdGhhdCBpcyBhIHBhcmFtZXRlci5cbiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdHMgPSB7IGlnbm9yZUNhY2hlOiBvcHRzIH07XG4gICAgICB9XG4gICAgICBpZiAoIW9wdHMgfHwgKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRzKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhY2hlS2V5ID0gYnRvYSh1cmwpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBHZXQgdGhlIGNhY2hlZCBwcm9taXNlIHRvIHNhdmUgbXVsdGlwbGUgbG9hZHMuXG4gICAgICAgIGlmICghb3B0cy5pZ25vcmVDYWNoZSAmJiBtZXRob2QgPT09ICdHRVQnICYmIEZvcm1pby5jYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShGb3JtaW8uY2FjaGVbY2FjaGVLZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1ZXN0VG9rZW4gPSAnJztcbiAgICAgICAgcmVzb2x2ZShuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgLy8gU2V0IHVwIGFuZCBmZXRjaCByZXF1ZXN0XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSBoZWFkZXIgfHwgbmV3IEhlYWRlcnMoe1xuICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBGb3JtaW8uZ2V0VG9rZW4oKTtcbiAgICAgICAgICBpZiAodG9rZW4gJiYgIW9wdHMubm9Ub2tlbikge1xuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoJ3gtand0LXRva2VuJywgdG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVxdWVzdFRva2VuID0gaGVhZGVycy5nZXQoJ3gtand0LXRva2VuJyk7XG4gICAgICAgICAgcmVzb2x2ZShmZXRjaCh1cmwsIG9wdGlvbnMpKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGVyci5tZXNzYWdlID0gJ0NvdWxkIG5vdCBjb25uZWN0IHRvIEFQSSBzZXJ2ZXIgKCcgKyBlcnIubWVzc2FnZSArICcpJztcbiAgICAgICAgICBlcnIubmV0d29ya0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDQwKSB7XG4gICAgICAgICAgICAgIEZvcm1pby5zZXRUb2tlbihudWxsKTtcbiAgICAgICAgICAgICAgRm9ybWlvLmV2ZW50cy5lbWl0KCdmb3JtaW8uc2Vzc2lvbkV4cGlyZWQnLCByZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgRm9ybWlvLmV2ZW50cy5lbWl0KCdmb3JtaW8udW5hdXRob3JpemVkJywgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBhbmQgcmV0dXJuIHRoZSBlcnJvciBhcyBhIHJlamVjdGVkIHByb21pc2UgdG8gcmVqZWN0IHRoaXMgcHJvbWlzZVxuICAgICAgICAgICAgcmV0dXJuIChyZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpICE9PSAtMSA/IHJlc3BvbnNlLmpzb24oKSA6IHJlc3BvbnNlLnRleHQoKSkudGhlbihmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBIYW5kbGUgZmV0Y2ggcmVzdWx0c1xuICAgICAgICAgIHZhciB0b2tlbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LWp3dC10b2tlbicpO1xuXG4gICAgICAgICAgLy8gSW4gc29tZSBzdHJhbmdlIGNhc2VzLCB0aGUgZmV0Y2ggbGlicmFyeSB3aWxsIHJldHVybiBhbiB4LWp3dC10b2tlbiB3aXRob3V0IHNlbmRpbmdcbiAgICAgICAgICAvLyBvbmUgdG8gdGhlIHNlcnZlci4gVGhpcyBoYXMgZXZlbiBiZWVuIGRlYnVnZ2VkIG9uIHRoZSBzZXJ2ZXIgdG8gdmVyaWZ5IHRoYXQgbm8gdG9rZW5cbiAgICAgICAgICAvLyB3YXMgaW50cm9kdWNlZCB3aXRoIHRoZSByZXF1ZXN0LCBidXQgdGhlIHJlc3BvbnNlIGNvbnRhaW5zIGEgdG9rZW4uIFRoaXMgaXMgYW4gSW52YWxpZFxuICAgICAgICAgIC8vIGNhc2Ugd2hlcmUgd2UgZG8gbm90IHNlbmQgYW4geC1qd3QtdG9rZW4gYW5kIGdldCBvbmUgaW4gcmV0dXJuIGZvciBhbnkgR0VUIHJlcXVlc3QuXG4gICAgICAgICAgdmFyIHRva2VuSW50cm9kdWNlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnICYmICFyZXF1ZXN0VG9rZW4gJiYgdG9rZW4gJiYgdXJsLmluZGV4T2YoJ3Rva2VuPScpID09PSAtMSAmJiB1cmwuaW5kZXhPZigneC1qd3QtdG9rZW49JyA9PT0gLTEpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Rva2VuIHdhcyBpbnRyb2R1Y2VkIGluIHJlcXVlc3QuJyk7XG4gICAgICAgICAgICB0b2tlbkludHJvZHVjZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCAmJiB0b2tlbiAmJiB0b2tlbiAhPT0gJycgJiYgIXRva2VuSW50cm9kdWNlZCkge1xuICAgICAgICAgICAgRm9ybWlvLnNldFRva2VuKHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gMjA0IGlzIG5vIGNvbnRlbnQuIERvbid0IHRyeSB0byAuanNvbigpIGl0LlxuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgIT09IC0xID8gcmVzcG9uc2UuanNvbigpIDogcmVzcG9uc2UudGV4dCgpKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIEFkZCBzb21lIGNvbnRlbnQtcmFuZ2UgbWV0YWRhdGEgdG8gdGhlIHJlc3VsdCBoZXJlXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1yYW5nZScpO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihyZXN1bHQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICBpZiAocmFuZ2VbMF0gIT09ICcqJykge1xuICAgICAgICAgICAgICAgIHZhciBza2lwTGltaXQgPSByYW5nZVswXS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gTnVtYmVyKHNraXBMaW1pdFswXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmxpbWl0ID0gc2tpcExpbWl0WzFdIC0gc2tpcExpbWl0WzBdICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQuc2VydmVyQ291bnQgPSByYW5nZVsxXSA9PT0gJyonID8gcmFuZ2VbMV0gOiBOdW1iZXIocmFuZ2VbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wdHMuZ2V0SGVhZGVycykge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHsgcmVzdWx0OiByZXN1bHQsIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChlcnIgPT09ICdCYWQgVG9rZW4nKSB7XG4gICAgICAgICAgICBGb3JtaW8uc2V0VG9rZW4obnVsbCk7XG4gICAgICAgICAgICBGb3JtaW8uZXZlbnRzLmVtaXQoJ2Zvcm1pby5iYWRUb2tlbicsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChGb3JtaW8uY2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZmFpbGVkIHByb21pc2VzIGZyb20gY2FjaGVcbiAgICAgICAgICAgIGRlbGV0ZSBGb3JtaW8uY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9wYWdhdGUgZXJyb3Igc28gY2xpZW50IGNhbiBoYW5kbGUgYWNjb3JkaW5nbHlcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAvLyBTYXZlIHRoZSBjYWNoZVxuICAgICAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgIEZvcm1pby5jYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNoYWxsb3cgY29weSByZXN1bHQgc28gbW9kaWZpY2F0aW9ucyBkb24ndCBlbmQgdXAgaW4gY2FjaGVcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgIHZhciByZXN1bHRDb3B5ID0gcmVzdWx0Lm1hcChjb3B5KTtcbiAgICAgICAgICByZXN1bHRDb3B5LnNraXAgPSByZXN1bHQuc2tpcDtcbiAgICAgICAgICByZXN1bHRDb3B5LmxpbWl0ID0gcmVzdWx0LmxpbWl0O1xuICAgICAgICAgIHJlc3VsdENvcHkuc2VydmVyQ291bnQgPSByZXN1bHQuc2VydmVyQ291bnQ7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdENvcHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHkocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFRva2VuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VG9rZW4odG9rZW4pIHtcbiAgICAgIHRva2VuID0gdG9rZW4gfHwgJyc7XG4gICAgICBpZiAodG9rZW4gPT09IHRoaXMudG9rZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICBGb3JtaW8uc2V0VXNlcihudWxsKTtcbiAgICAgICAgLy8gaU9TIGluIHByaXZhdGUgYnJvd3NlIG1vZGUgd2lsbCB0aHJvdyBhbiBlcnJvciBidXQgd2UgY2FuJ3QgZGV0ZWN0IGFoZWFkIG9mIHRpbWUgdGhhdCB3ZSBhcmUgaW4gcHJpdmF0ZSBtb2RlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZm9ybWlvVG9rZW4nKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpT1MgaW4gcHJpdmF0ZSBicm93c2UgbW9kZSB3aWxsIHRocm93IGFuIGVycm9yIGJ1dCB3ZSBjYW4ndCBkZXRlY3QgYWhlYWQgb2YgdGltZSB0aGF0IHdlIGFyZSBpbiBwcml2YXRlIG1vZGUuXG4gICAgICB0cnkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZm9ybWlvVG9rZW4nLCB0b2tlbik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgIH1cbiAgICAgIHJldHVybiBGb3JtaW8uY3VycmVudFVzZXIoKTsgLy8gUnVuIHRoaXMgc28gdXNlciBpcyB1cGRhdGVkIGlmIG51bGxcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUb2tlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRva2VuKCkge1xuICAgICAgaWYgKHRoaXMudG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZm9ybWlvVG9rZW4nKSB8fCAnJztcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRVc2VyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXNlcih1c2VyKSB7XG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgdGhpcy5zZXRUb2tlbihudWxsKTtcbiAgICAgICAgLy8gaU9TIGluIHByaXZhdGUgYnJvd3NlIG1vZGUgd2lsbCB0aHJvdyBhbiBlcnJvciBidXQgd2UgY2FuJ3QgZGV0ZWN0IGFoZWFkIG9mIHRpbWUgdGhhdCB3ZSBhcmUgaW4gcHJpdmF0ZSBtb2RlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZm9ybWlvVXNlcicpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlPUyBpbiBwcml2YXRlIGJyb3dzZSBtb2RlIHdpbGwgdGhyb3cgYW4gZXJyb3IgYnV0IHdlIGNhbid0IGRldGVjdCBhaGVhZCBvZiB0aW1lIHRoYXQgd2UgYXJlIGluIHByaXZhdGUgbW9kZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdmb3JtaW9Vc2VyJywgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VXNlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVzZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZm9ybWlvVXNlcicpIHx8IG51bGwpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0QmFzZVVybCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEJhc2VVcmwodXJsKSB7XG4gICAgICBGb3JtaW8uYmFzZVVybCA9IHVybDtcbiAgICAgIGlmICghRm9ybWlvLnByb2plY3RVcmxTZXQpIHtcbiAgICAgICAgRm9ybWlvLnByb2plY3RVcmwgPSB1cmw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QmFzZVVybCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VVcmwoKSB7XG4gICAgICByZXR1cm4gRm9ybWlvLmJhc2VVcmw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0QXBpVXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXBpVXJsKHVybCkge1xuICAgICAgcmV0dXJuIEZvcm1pby5zZXRCYXNlVXJsKHVybCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QXBpVXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXBpVXJsKCkge1xuICAgICAgcmV0dXJuIEZvcm1pby5nZXRCYXNlVXJsKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0QXBwVXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXBwVXJsKHVybCkge1xuICAgICAgY29uc29sZS53YXJuKCdGb3JtaW8uc2V0QXBwVXJsKCkgaXMgZGVwcmVjYXRlZC4gVXNlIEZvcm1pby5zZXRQcm9qZWN0VXJsIGluc3RlYWQuJyk7XG4gICAgICBGb3JtaW8ucHJvamVjdFVybCA9IHVybDtcbiAgICAgIEZvcm1pby5wcm9qZWN0VXJsU2V0ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRQcm9qZWN0VXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvamVjdFVybCh1cmwpIHtcbiAgICAgIEZvcm1pby5wcm9qZWN0VXJsID0gdXJsO1xuICAgICAgRm9ybWlvLnByb2plY3RVcmxTZXQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEFwcFVybCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFwcFVybCgpIHtcbiAgICAgIGNvbnNvbGUud2FybignRm9ybWlvLmdldEFwcFVybCgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBGb3JtaW8uZ2V0UHJvamVjdFVybCBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIEZvcm1pby5wcm9qZWN0VXJsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFByb2plY3RVcmwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9qZWN0VXJsKCkge1xuICAgICAgcmV0dXJuIEZvcm1pby5wcm9qZWN0VXJsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyQ2FjaGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgRm9ybWlvLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbm9vcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vb3AoKSB7fVxuICB9LCB7XG4gICAga2V5OiAnaWRlbnRpdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlcmVnaXN0ZXJQbHVnaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXJlZ2lzdGVyUGx1Z2luKHBsdWdpbikge1xuICAgICAgdmFyIGJlZm9yZUxlbmd0aCA9IEZvcm1pby5wbHVnaW5zLmxlbmd0aDtcbiAgICAgIEZvcm1pby5wbHVnaW5zID0gRm9ybWlvLnBsdWdpbnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmIChwICE9PSBwbHVnaW4gJiYgcC5fX25hbWUgIT09IHBsdWdpbikgcmV0dXJuIHRydWU7XG4gICAgICAgIChwLmRlcmVnaXN0ZXIgfHwgRm9ybWlvLm5vb3ApLmNhbGwocCwgRm9ybWlvKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmVmb3JlTGVuZ3RoICE9PSBGb3JtaW8ucGx1Z2lucy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXJQbHVnaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlclBsdWdpbihwbHVnaW4sIG5hbWUpIHtcbiAgICAgIEZvcm1pby5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIEZvcm1pby5wbHVnaW5zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChiLnByaW9yaXR5IHx8IDApIC0gKGEucHJpb3JpdHkgfHwgMCk7XG4gICAgICB9KTtcbiAgICAgIHBsdWdpbi5fX25hbWUgPSBuYW1lO1xuICAgICAgKHBsdWdpbi5pbml0IHx8IEZvcm1pby5ub29wKS5jYWxsKHBsdWdpbiwgRm9ybWlvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQbHVnaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBwbHVnaW4pIHtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKHBsdWdpbi5fX25hbWUgPT09IG5hbWUpIHJldHVybiBwbHVnaW47XG4gICAgICB9LCBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwbHVnaW5XYWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGx1Z2luV2FpdChwbHVnaW5Gbikge1xuICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoRm9ybWlvLnBsdWdpbnMubWFwKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIChwbHVnaW5bcGx1Z2luRm5dIHx8IEZvcm1pby5ub29wKS5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BsdWdpbkdldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsdWdpbkdldChwbHVnaW5Gbikge1xuICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICB2YXIgY2FsbFBsdWdpbiA9IGZ1bmN0aW9uIGNhbGxQbHVnaW4oaW5kZXgsIHBsdWdpbkZuKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSBGb3JtaW8ucGx1Z2luc1tpbmRleF07XG4gICAgICAgIGlmICghcGx1Z2luKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKChwbHVnaW4gJiYgcGx1Z2luW3BsdWdpbkZuXSB8fCBGb3JtaW8ubm9vcCkuYXBwbHkocGx1Z2luLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHJldHVybiBjYWxsUGx1Z2luLmFwcGx5KG51bGwsIFtpbmRleCArIDFdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBjYWxsUGx1Z2luLmFwcGx5KG51bGwsIFswXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BsdWdpbkFsdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGx1Z2luQWx0ZXIocGx1Z2luRm4sIHZhbHVlKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2lucy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIChwbHVnaW5bcGx1Z2luRm5dIHx8IEZvcm1pby5pZGVudGl0eSkuYXBwbHkocGx1Z2luLCBbdmFsdWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9LCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3VycmVudFVzZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJyZW50VXNlcigpIHtcbiAgICAgIHZhciB1cmwgPSBGb3JtaW8uYmFzZVVybCArICcvY3VycmVudCc7XG4gICAgICB2YXIgdXNlciA9IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5BbHRlcignd3JhcFN0YXRpY1JlcXVlc3RQcm9taXNlJywgUHJvbWlzZS5yZXNvbHZlKHVzZXIpLCB7XG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciB0b2tlbiA9IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5BbHRlcignd3JhcFN0YXRpY1JlcXVlc3RQcm9taXNlJywgUHJvbWlzZS5yZXNvbHZlKG51bGwpLCB7XG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGb3JtaW8ubWFrZVN0YXRpY1JlcXVlc3QodXJsKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBGb3JtaW8uc2V0VXNlcihyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvZ291dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICAgIEZvcm1pby5zZXRUb2tlbihudWxsKTtcbiAgICAgIEZvcm1pby5zZXRVc2VyKG51bGwpO1xuICAgICAgRm9ybWlvLmNsZWFyQ2FjaGUoKTtcbiAgICAgIHJldHVybiBGb3JtaW8ubWFrZVN0YXRpY1JlcXVlc3QoRm9ybWlvLmJhc2VVcmwgKyAnL2xvZ291dCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhbiBIVE1MIGZvcm0gdG8gRm9ybS5pby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Zvcm0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtKF9mb3JtLCBvcHRpb25zLCBkb25lKSB7XG4gICAgICAvLyBGaXggdGhlIHBhcmFtZXRlcnMuXG4gICAgICBpZiAoIWRvbmUgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgZG9uZSA9IGRvbmUgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBJRiB0aGV5IHByb3ZpZGUgYSBqcXVlcnkgb2JqZWN0LCB0aGVuIHNlbGVjdCB0aGUgZWxlbWVudC5cbiAgICAgIGlmIChfZm9ybS5qcXVlcnkpIHtcbiAgICAgICAgX2Zvcm0gPSBfZm9ybVswXTtcbiAgICAgIH1cbiAgICAgIGlmICghX2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoJ0ludmFsaWQgRm9ybScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ2V0QWN0aW9uID0gZnVuY3Rpb24gZ2V0QWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5mb3JtIHx8IF9mb3JtLmdldEF0dHJpYnV0ZSgnYWN0aW9uJyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3VibWlzc2lvbiBvYmplY3QuXG4gICAgICAgKiBAcmV0dXJucyB7e2RhdGE6IHt9fX1cbiAgICAgICAqL1xuICAgICAgdmFyIGdldFN1Ym1pc3Npb24gPSBmdW5jdGlvbiBnZXRTdWJtaXNzaW9uKCkge1xuICAgICAgICB2YXIgc3VibWlzc2lvbiA9IHsgZGF0YToge30gfTtcbiAgICAgICAgdmFyIHNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgaXNBcnJheSA9IHBhdGguc3Vic3RyKC0yKSA9PT0gJ1tdJztcbiAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgnW10nLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwYXRocyA9IHBhdGgucmVwbGFjZSgvXFxbfFxcXVxcWy9nLCAnLicpLnJlcGxhY2UoL1xcXSQvZywgJycpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBzdWJtaXNzaW9uO1xuICAgICAgICAgIHdoaWxlIChwYXRoID0gcGF0aHMuc2hpZnQoKSkge1xuICAgICAgICAgICAgaWYgKCFwYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRbcGF0aF0pIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRbcGF0aF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFtwYXRoXS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50W3BhdGhdID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghY3VycmVudFtwYXRoXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbcGF0aF0gPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0IHRoZSBmb3JtIGRhdGEgZnJvbSB0aGlzIGZvcm0uXG4gICAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShfZm9ybSk7XG4gICAgICAgIHZhciBlbnRyaWVzID0gZm9ybURhdGEuZW50cmllcygpO1xuICAgICAgICB2YXIgZW50cnkgPSBudWxsO1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyaWVzLm5leHQoKS52YWx1ZSkge1xuICAgICAgICAgIHNldFZhbHVlKGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Ym1pc3Npb247XG4gICAgICB9O1xuXG4gICAgICAvLyBTdWJtaXRzIHRoZSBmb3JtLlxuICAgICAgdmFyIHN1Ym1pdCA9IGZ1bmN0aW9uIHN1Ym1pdChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhY3Rpb24gPSBnZXRBY3Rpb24oKTtcbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3IEZvcm1pbyhhY3Rpb24pLnNhdmVTdWJtaXNzaW9uKGdldFN1Ym1pc3Npb24oKSkudGhlbihmdW5jdGlvbiAoc3ViKSB7XG4gICAgICAgICAgZG9uZShudWxsLCBzdWIpO1xuICAgICAgICB9LCBkb25lKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEF0dGFjaCBmb3JtaW8gdG8gdGhlIHByb3ZpZGVkIGZvcm0uXG4gICAgICBpZiAoX2Zvcm0uYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgX2Zvcm0uYXR0YWNoRXZlbnQoJ3N1Ym1pdCcsIHN1Ym1pdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBzdWJtaXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWJtaXQ6IHN1Ym1pdCxcbiAgICAgICAgZ2V0QWN0aW9uOiBnZXRBY3Rpb24sXG4gICAgICAgIGdldFN1Ym1pc3Npb246IGdldFN1Ym1pc3Npb25cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmllbGREYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmllbGREYXRhKGRhdGEsIGNvbXBvbmVudCkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICghY29tcG9uZW50IHx8ICFjb21wb25lbnQua2V5KSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBvbmVudC5rZXkuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkYXRhO1xuICAgICAgICB2YXIgcGFydHMgPSBjb21wb25lbnQua2V5LnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBrZXkgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGtleSA9IHBhcnRzW2ldO1xuXG4gICAgICAgICAgLy8gSGFuZGxlIG5lc3RlZCByZXNvdXJjZXNcbiAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ19pZCcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmV0dXJuIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kIG9uIHRoZSB2YWx1ZS5cbiAgICAgICAgICBpZiAoIXZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IG9sZCBzaW5nbGUgZmllbGQgZGF0YSBpbiBzdWJtaXNzaW9ucyB0byBtdWx0aXBsZVxuICAgICAgICAgIGlmIChrZXkgPT09IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdICYmIGNvbXBvbmVudC5tdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZVtrZXldKSkge1xuICAgICAgICAgICAgdmFsdWVba2V5XSA9IFt2YWx1ZVtrZXldXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIG9mIHRoaXMga2V5LlxuICAgICAgICAgIHZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb252ZXJ0IG9sZCBzaW5nbGUgZmllbGQgZGF0YSBpbiBzdWJtaXNzaW9ucyB0byBtdWx0aXBsZVxuICAgICAgICBpZiAoY29tcG9uZW50Lm11bHRpcGxlICYmICFBcnJheS5pc0FycmF5KGRhdGFbY29tcG9uZW50LmtleV0pKSB7XG4gICAgICAgICAgZGF0YVtjb21wb25lbnQua2V5XSA9IFtkYXRhW2NvbXBvbmVudC5rZXldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVtjb21wb25lbnQua2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9ybWlvO1xufSgpO1xuXG4vLyBEZWZpbmUgYWxsIHRoZSBzdGF0aWMgcHJvcGVydGllcy5cblxuXG5leHBvcnRzLkZvcm1pbyA9IEZvcm1pbztcbkZvcm1pby5iYXNlVXJsID0gJ2h0dHBzOi8vYXBpLmZvcm0uaW8nO1xuRm9ybWlvLnByb2plY3RVcmwgPSBGb3JtaW8uYmFzZVVybDtcbkZvcm1pby5wcm9qZWN0VXJsU2V0ID0gZmFsc2U7XG5Gb3JtaW8ucGx1Z2lucyA9IFtdO1xuRm9ybWlvLmNhY2hlID0ge307XG5Gb3JtaW8ucHJvdmlkZXJzID0gcmVxdWlyZSgnLi9wcm92aWRlcnMnKTtcbkZvcm1pby5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKHtcbiAgd2lsZGNhcmQ6IGZhbHNlLFxuICBtYXhMaXN0ZW5lcnM6IDBcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5Gb3JtaW8gPSBGb3JtaW87IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmFnZTogcmVxdWlyZSgnLi9zdG9yYWdlJylcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoXCJuYXRpdmUtcHJvbWlzZS1vbmx5XCIpO1xudmFyIGRyb3Bib3ggPSBmdW5jdGlvbiBkcm9wYm94KGZvcm1pbykge1xuICByZXR1cm4ge1xuICAgIHVwbG9hZEZpbGU6IGZ1bmN0aW9uIHVwbG9hZEZpbGUoZmlsZSwgZmlsZU5hbWUsIGRpciwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gU2VuZCB0aGUgZmlsZSB3aXRoIGRhdGEuXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBwcm9ncmVzc0NhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZkID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZkLmFwcGVuZCgnbmFtZScsIGZpbGVOYW1lKTtcbiAgICAgICAgZmQuYXBwZW5kKCdkaXInLCBkaXIpO1xuICAgICAgICBmZC5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcblxuICAgICAgICAvLyBGaXJlIG9uIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGVyci5uZXR3b3JrRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0b3JhZ2UgPSAnZHJvcGJveCc7XG4gICAgICAgICAgICByZXNwb25zZS5zaXplID0gZmlsZS5zaXplO1xuICAgICAgICAgICAgcmVzcG9uc2UudHlwZSA9IGZpbGUudHlwZTtcbiAgICAgICAgICAgIHJlc3BvbnNlLnVybCA9IHJlc3BvbnNlLnBhdGhfbG93ZXI7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHhoci5yZXNwb25zZSB8fCAnVW5hYmxlIHRvIHVwbG9hZCBmaWxlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgZm9ybWlvLmZvcm1VcmwgKyAnL3N0b3JhZ2UvZHJvcGJveCcpO1xuICAgICAgICB2YXIgdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdmb3JtaW9Ub2tlbicpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gU3dhbGxvdyBlcnJvci5cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcigneC1qd3QtdG9rZW4nLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnNlbmQoZmQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkb3dubG9hZEZpbGU6IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlKSB7XG4gICAgICB2YXIgdG9rZW4gPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Zvcm1pb1Rva2VuJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFN3YWxsb3cgZXJyb3IuXG4gICAgICB9XG4gICAgICBmaWxlLnVybCA9IGZvcm1pby5mb3JtVXJsICsgJy9zdG9yYWdlL2Ryb3Bib3g/cGF0aF9sb3dlcj0nICsgZmlsZS5wYXRoX2xvd2VyICsgKHRva2VuID8gJyZ4LWp3dC10b2tlbj0nICsgdG9rZW4gOiAnJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGUpO1xuICAgIH1cbiAgfTtcbn07XG5cbmRyb3Bib3gudGl0bGUgPSAnRHJvcGJveCc7XG5tb2R1bGUuZXhwb3J0cyA9IGRyb3Bib3g7IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJvcGJveDogcmVxdWlyZSgnLi9kcm9wYm94LmpzJyksXG4gIHMzOiByZXF1aXJlKCcuL3MzLmpzJyksXG4gIHVybDogcmVxdWlyZSgnLi91cmwuanMnKVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZShcIm5hdGl2ZS1wcm9taXNlLW9ubHlcIik7XG52YXIgczMgPSBmdW5jdGlvbiBzMyhmb3JtaW8pIHtcbiAgcmV0dXJuIHtcbiAgICB1cGxvYWRGaWxlOiBmdW5jdGlvbiB1cGxvYWRGaWxlKGZpbGUsIGZpbGVOYW1lLCBkaXIsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIFNlbmQgdGhlIHByZSByZXNwb25zZSB0byBzaWduIHRoZSB1cGxvYWQuXG4gICAgICAgIHZhciBwcmUgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICB2YXIgcHJlZmQgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgcHJlZmQuYXBwZW5kKCduYW1lJywgZmlsZU5hbWUpO1xuICAgICAgICBwcmVmZC5hcHBlbmQoJ3NpemUnLCBmaWxlLnNpemUpO1xuICAgICAgICBwcmVmZC5hcHBlbmQoJ3R5cGUnLCBmaWxlLnR5cGUpO1xuXG4gICAgICAgIC8vIFRoaXMgb25seSBmaXJlcyBvbiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIHByZS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGVyci5uZXR3b3JrRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByZS5vbmFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHByZS5zdGF0dXMgPj0gMjAwICYmIHByZS5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UocHJlLnJlc3BvbnNlKTtcblxuICAgICAgICAgICAgLy8gU2VuZCB0aGUgZmlsZSB3aXRoIGRhdGEuXG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3NDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBwcm9ncmVzc0NhbGxiYWNrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNwb25zZS5kYXRhLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhLmtleSArPSBkaXIgKyBmaWxlTmFtZTtcblxuICAgICAgICAgICAgdmFyIGZkID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgICBmZC5hcHBlbmQoa2V5LCByZXNwb25zZS5kYXRhW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmQuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG5cbiAgICAgICAgICAgIC8vIEZpcmUgb24gbmV0d29yayBlcnJvci5cbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBlcnIubmV0d29ya0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgc3RvcmFnZTogJ3MzJyxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgYnVja2V0OiByZXNwb25zZS5idWNrZXQsXG4gICAgICAgICAgICAgICAgICBrZXk6IHJlc3BvbnNlLmRhdGEua2V5LFxuICAgICAgICAgICAgICAgICAgdXJsOiByZXNwb25zZS51cmwgKyByZXNwb25zZS5kYXRhLmtleSxcbiAgICAgICAgICAgICAgICAgIGFjbDogcmVzcG9uc2UuZGF0YS5hY2wsXG4gICAgICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoeGhyLnJlc3BvbnNlIHx8ICdVbmFibGUgdG8gdXBsb2FkIGZpbGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCByZXNwb25zZS51cmwpO1xuXG4gICAgICAgICAgICB4aHIuc2VuZChmZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChwcmUucmVzcG9uc2UgfHwgJ1VuYWJsZSB0byBzaWduIGZpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJlLm9wZW4oJ1BPU1QnLCBmb3JtaW8uZm9ybVVybCArICcvc3RvcmFnZS9zMycpO1xuXG4gICAgICAgIHByZS5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICBwcmUuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgdmFyIHRva2VuID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZm9ybWlvVG9rZW4nKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIHN3YWxsb3cgZXJyb3IuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgcHJlLnNldFJlcXVlc3RIZWFkZXIoJ3gtand0LXRva2VuJywgdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICB0eXBlOiBmaWxlLnR5cGVcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkb3dubG9hZEZpbGU6IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlKSB7XG4gICAgICBpZiAoZmlsZS5hY2wgIT09ICdwdWJsaWMtcmVhZCcpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1pby5tYWtlUmVxdWVzdCgnZmlsZScsIGZvcm1pby5mb3JtVXJsICsgJy9zdG9yYWdlL3MzP2J1Y2tldD0nICsgZmlsZS5idWNrZXQgKyAnJmtleT0nICsgZmlsZS5rZXksICdHRVQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuczMudGl0bGUgPSAnUzMnO1xubW9kdWxlLmV4cG9ydHMgPSBzMzsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZShcIm5hdGl2ZS1wcm9taXNlLW9ubHlcIik7XG52YXIgdXJsID0gZnVuY3Rpb24gdXJsKGZvcm1pbykge1xuICByZXR1cm4ge1xuICAgIHRpdGxlOiAnVXJsJyxcbiAgICBuYW1lOiAndXJsJyxcbiAgICB1cGxvYWRGaWxlOiBmdW5jdGlvbiB1cGxvYWRGaWxlKGZpbGUsIGZpbGVOYW1lLCBkaXIsIHByb2dyZXNzQ2FsbGJhY2ssIHVybCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgZGlyOiBkaXIsXG4gICAgICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgZmlsZTogZmlsZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNlbmQgdGhlIGZpbGUgd2l0aCBkYXRhLlxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9ncmVzc0NhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gcHJvZ3Jlc3NDYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGZkLmFwcGVuZChrZXksIGRhdGFba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHRlc3QgaWYgeGhyLnJlc3BvbnNlIGlzIGRlY29kZWQgb3Igbm90LlxuICAgICAgICAgICAgdmFyIHJlc3BEYXRhID0ge307XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXNwRGF0YSA9IHR5cGVvZiB4aHIucmVzcG9uc2UgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpIDoge307XG4gICAgICAgICAgICAgIHJlc3BEYXRhID0gcmVzcERhdGEgJiYgcmVzcERhdGEuZGF0YSA/IHJlc3BEYXRhLmRhdGEgOiB7fTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICByZXNwRGF0YSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3RvcmFnZTogJ3VybCcsXG4gICAgICAgICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICB1cmw6IHhoci5yZXNwb25zZVVSTCArICcvJyArIGZpbGVOYW1lLFxuICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgICAgZGF0YTogcmVzcERhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoeGhyLnJlc3BvbnNlIHx8ICdVbmFibGUgdG8gdXBsb2FkIGZpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRmlyZSBvbiBuZXR3b3JrIGVycm9yLlxuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWplY3QoeGhyKTtcbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWplY3QoeGhyKTtcbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCk7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdmb3JtaW9Ub2tlbicpO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcigneC1qd3QtdG9rZW4nLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnNlbmQoZmQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkb3dubG9hZEZpbGU6IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIG9yaWdpbmFsIGFzIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGUpO1xuICAgIH1cbiAgfTtcbn07XG5cbnVybC50aXRsZSA9ICdVcmwnO1xubW9kdWxlLmV4cG9ydHMgPSB1cmw7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfanNvbkxvZ2ljSnMgPSByZXF1aXJlKCdqc29uLWxvZ2ljLWpzJyk7XG5cbnZhciBfanNvbkxvZ2ljSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNvbkxvZ2ljSnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX2dldCA9IHJlcXVpcmUoJ2xvZGFzaC9nZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBjb21wb25lbnQgaXMgYSBsYXlvdXQgY29tcG9uZW50IG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudFxuICAgKiAgIFRoZSBjb21wb25lbnQgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgaXMgYSBsYXlvdXQgY29tcG9uZW50LlxuICAgKi9cbiAgaXNMYXlvdXRDb21wb25lbnQ6IGZ1bmN0aW9uIGlzTGF5b3V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQuY29sdW1ucyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5jb2x1bW5zKSB8fCBjb21wb25lbnQucm93cyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5yb3dzKSB8fCBjb21wb25lbnQuY29tcG9uZW50cyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5jb21wb25lbnRzKSA/IHRydWUgOiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGVhY2ggY29tcG9uZW50IHdpdGhpbiBhIGZvcm0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnRzXG4gICAqICAgVGhlIGNvbXBvbmVudHMgdG8gaXRlcmF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogICBUaGUgaXRlcmF0aW9uIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUFsbFxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgbGF5b3V0IGNvbXBvbmVudHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqICAgVGhlIGN1cnJlbnQgZGF0YSBwYXRoIG9mIHRoZSBlbGVtZW50LiBFeGFtcGxlOiBkYXRhLnVzZXIuZmlyc3ROYW1lXG4gICAqL1xuICBlYWNoQ29tcG9uZW50OiBmdW5jdGlvbiBlYWNoQ29tcG9uZW50KGNvbXBvbmVudHMsIGZuLCBpbmNsdWRlQWxsLCBwYXRoKSB7XG4gICAgaWYgKCFjb21wb25lbnRzKSByZXR1cm47XG4gICAgcGF0aCA9IHBhdGggfHwgJyc7XG4gICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHZhciBoYXNDb2x1bW5zID0gY29tcG9uZW50LmNvbHVtbnMgJiYgQXJyYXkuaXNBcnJheShjb21wb25lbnQuY29sdW1ucyk7XG4gICAgICB2YXIgaGFzUm93cyA9IGNvbXBvbmVudC5yb3dzICYmIEFycmF5LmlzQXJyYXkoY29tcG9uZW50LnJvd3MpO1xuICAgICAgdmFyIGhhc0NvbXBzID0gY29tcG9uZW50LmNvbXBvbmVudHMgJiYgQXJyYXkuaXNBcnJheShjb21wb25lbnQuY29tcG9uZW50cyk7XG4gICAgICB2YXIgbm9SZWN1cnNlID0gZmFsc2U7XG4gICAgICB2YXIgbmV3UGF0aCA9IGNvbXBvbmVudC5rZXkgPyBwYXRoID8gcGF0aCArICcuJyArIGNvbXBvbmVudC5rZXkgOiBjb21wb25lbnQua2V5IDogJyc7XG5cbiAgICAgIGlmIChpbmNsdWRlQWxsIHx8IGNvbXBvbmVudC50cmVlIHx8ICFoYXNDb2x1bW5zICYmICFoYXNSb3dzICYmICFoYXNDb21wcykge1xuICAgICAgICBub1JlY3Vyc2UgPSBmbihjb21wb25lbnQsIG5ld1BhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3ViUGF0aCA9IGZ1bmN0aW9uIHN1YlBhdGgoKSB7XG4gICAgICAgIGlmIChjb21wb25lbnQua2V5ICYmIChjb21wb25lbnQudHlwZSA9PT0gJ2RhdGFncmlkJyB8fCBjb21wb25lbnQudHlwZSA9PT0gJ2NvbnRhaW5lcicpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ld1BhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIW5vUmVjdXJzZSkge1xuICAgICAgICBpZiAoaGFzQ29sdW1ucykge1xuICAgICAgICAgIGNvbXBvbmVudC5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgZWFjaENvbXBvbmVudChjb2x1bW4uY29tcG9uZW50cywgZm4sIGluY2x1ZGVBbGwsIHN1YlBhdGgoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzUm93cykge1xuICAgICAgICAgIFtdLmNvbmNhdC5hcHBseShbXSwgY29tcG9uZW50LnJvd3MpLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgZWFjaENvbXBvbmVudChyb3cuY29tcG9uZW50cywgZm4sIGluY2x1ZGVBbGwsIHN1YlBhdGgoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ29tcHMpIHtcbiAgICAgICAgICBlYWNoQ29tcG9uZW50KGNvbXBvbmVudC5jb21wb25lbnRzLCBmbiwgaW5jbHVkZUFsbCwgc3ViUGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBjb21wb25lbnQgYnkgaXRzIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50c1xuICAgKiAgIFRoZSBjb21wb25lbnRzIHRvIGl0ZXJhdGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogICBUaGUga2V5IG9mIHRoZSBjb21wb25lbnQgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiAgIFRoZSBjb21wb25lbnQgdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBrZXksIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAqL1xuICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIGdldENvbXBvbmVudChjb21wb25lbnRzLCBrZXkpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIG1vZHVsZS5leHBvcnRzLmVhY2hDb21wb25lbnQoY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgaWYgKGNvbXBvbmVudC5rZXkgPT09IGtleSkge1xuICAgICAgICByZXN1bHQgPSBjb21wb25lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogRmxhdHRlbiB0aGUgZm9ybSBjb21wb25lbnRzIGZvciBkYXRhIG1hbmlwdWxhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudHNcbiAgICogICBUaGUgY29tcG9uZW50cyB0byBpdGVyYXRlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVBbGxcbiAgICogICBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIGxheW91dCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiAgIFRoZSBmbGF0dGVuZWQgY29tcG9uZW50cyBtYXAuXG4gICAqL1xuICBmbGF0dGVuQ29tcG9uZW50czogZnVuY3Rpb24gZmxhdHRlbkNvbXBvbmVudHMoY29tcG9uZW50cywgaW5jbHVkZUFsbCkge1xuICAgIHZhciBmbGF0dGVuZWQgPSB7fTtcbiAgICBtb2R1bGUuZXhwb3J0cy5lYWNoQ29tcG9uZW50KGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQsIHBhdGgpIHtcbiAgICAgIGZsYXR0ZW5lZFtwYXRoXSA9IGNvbXBvbmVudDtcbiAgICB9LCBpbmNsdWRlQWxsKTtcbiAgICByZXR1cm4gZmxhdHRlbmVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIGNvbmRpdGlvbnMgZm9yIGEgcHJvdmlkZWQgY29tcG9uZW50IGFuZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50XG4gICAqICAgVGhlIGNvbXBvbmVudCB0byBjaGVjayBmb3IgdGhlIGNvbmRpdGlvbi5cbiAgICogQHBhcmFtIHJvd1xuICAgKiAgIFRoZSBkYXRhIHdpdGhpbiBhIHJvd1xuICAgKiBAcGFyYW0gZGF0YVxuICAgKiAgIFRoZSBmdWxsIHN1Ym1pc3Npb24gZGF0YS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVja0NvbmRpdGlvbjogZnVuY3Rpb24gY2hlY2tDb25kaXRpb24oY29tcG9uZW50LCByb3csIGRhdGEpIHtcbiAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdjdXN0b21Db25kaXRpb25hbCcpICYmIGNvbXBvbmVudC5jdXN0b21Db25kaXRpb25hbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNjcmlwdCA9ICcoZnVuY3Rpb24oKSB7IHZhciBzaG93ID0gdHJ1ZTsnO1xuICAgICAgICBzY3JpcHQgKz0gY29tcG9uZW50LmN1c3RvbUNvbmRpdGlvbmFsLnRvU3RyaW5nKCk7XG4gICAgICAgIHNjcmlwdCArPSAnOyByZXR1cm4gc2hvdzsgfSkoKSc7XG4gICAgICAgIHZhciByZXN1bHQgPSBldmFsKHNjcmlwdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKSA9PT0gJ3RydWUnO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGVycm9yIG9jY3VycmVkIGluIGEgY3VzdG9tIGNvbmRpdGlvbmFsIHN0YXRlbWVudCBmb3IgY29tcG9uZW50ICcgKyBjb21wb25lbnQua2V5LCBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbmFsJykgJiYgY29tcG9uZW50LmNvbmRpdGlvbmFsICYmIGNvbXBvbmVudC5jb25kaXRpb25hbC53aGVuKSB7XG4gICAgICB2YXIgY29uZCA9IGNvbXBvbmVudC5jb25kaXRpb25hbDtcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICBpZiAocm93KSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSh7IGRhdGE6IHJvdyB9LCBjb25kLndoZW4pO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSh7IGRhdGE6IGRhdGEgfSwgY29uZC53aGVuKTtcbiAgICAgIH1cbiAgICAgIC8vIEZPUi00MDAgLSBGaXggaXNzdWUgd2hlcmUgZmFsc2V5IHZhbHVlcyB3ZXJlIGJlaW5nIGV2YWx1YXRlZCBhcyBzaG93PXRydWVcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFNwZWNpYWwgY2hlY2sgZm9yIHNlbGVjdGJveGVzIGNvbXBvbmVudC5cbiAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShjb25kLmVxKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbY29uZC5lcV0udG9TdHJpbmcoKSA9PT0gY29uZC5zaG93LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICAvLyBGT1ItMTc5IC0gQ2hlY2sgZm9yIG11bHRpcGxlIHZhbHVlcy5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHZhbHVlLmluZGV4T2YoY29uZC5lcSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBjb25kLnNob3cudG9TdHJpbmcoKSA9PT0gJ3RydWUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSA9PT0gY29uZC5lcS50b1N0cmluZygpID09PSAoY29uZC5zaG93LnRvU3RyaW5nKCkgPT09ICd0cnVlJyk7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbmFsJykgJiYgY29tcG9uZW50LmNvbmRpdGlvbmFsICYmIGNvbXBvbmVudC5jb25kaXRpb25hbC5qc29uKSB7XG4gICAgICByZXR1cm4gX2pzb25Mb2dpY0pzMi5kZWZhdWx0LmFwcGx5KGNvbXBvbmVudC5jb25kaXRpb25hbC5qc29uLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHJvdzogcm93XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHNob3cuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIGEgY29tcG9uZW50IGtleSwgaW4gdGhlIGdpdmVuIHN1Ym1pc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJtaXNzaW9uXG4gICAqICAgQSBzdWJtaXNzaW9uIG9iamVjdCB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogICBBIGZvciBjb21wb25lbnRzIEFQSSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICovXG4gIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShzdWJtaXNzaW9uLCBrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHN1Ym1pc3Npb24uZGF0YSB8fCB7fTtcblxuICAgIHZhciBzZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goZGF0YSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfdHlwZW9mKGRhdGFba2V5c1tpXV0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWFyY2goZGF0YVtrZXlzW2ldXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzZWFyY2goZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgc3RyaW5nIGFuZCBhZGQgZGF0YSByZXBsYWNlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmdcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnMge1hNTHxzdHJpbmd8Knx2b2lkfVxuICAgKi9cbiAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHN0cmluZywgZGF0YSkge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFx7XFx7XFxzKihbXlxcc10qKVxccypcXH1cXH0vZywgZnVuY3Rpb24gKG1hdGNoLCB0b2tlbikge1xuICAgICAgcmV0dXJuIF9nZXQoZGF0YSwgdG9rZW4pO1xuICAgIH0pO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9idWlsZC91dGlscycpO1xuIiwiLyogZ2xvYmFscyBkZWZpbmUsbW9kdWxlICovXG4vKlxuVXNpbmcgYSBVbml2ZXJzYWwgTW9kdWxlIExvYWRlciB0aGF0IHNob3VsZCBiZSBicm93c2VyLCByZXF1aXJlLCBhbmQgQU1EIGZyaWVuZGx5XG5odHRwOi8vcmljb3N0YWNydXouY29tL2NoZWF0c2hlZXRzL3VtZGpzLmh0bWxcbiovXG47KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5qc29uTG9naWMgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvKiBnbG9iYWxzIGNvbnNvbGU6ZmFsc2UgKi9cblxuICBpZiAoICEgQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheVVuaXF1ZShhcnJheSkge1xuICAgIHZhciBhID0gW107XG4gICAgZm9yICh2YXIgaT0wLCBsPWFycmF5Lmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIGlmIChhLmluZGV4T2YoYXJyYXlbaV0pID09PSAtMSkge1xuICAgICAgICBhLnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHZhciBqc29uTG9naWMgPSB7fTtcbiAgdmFyIG9wZXJhdGlvbnMgPSB7XG4gICAgXCI9PVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSA9PSBiO1xuICAgIH0sXG4gICAgXCI9PT1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfSxcbiAgICBcIiE9XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICE9IGI7XG4gICAgfSxcbiAgICBcIiE9PVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAhPT0gYjtcbiAgICB9LFxuICAgIFwiPlwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSA+IGI7XG4gICAgfSxcbiAgICBcIj49XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID49IGI7XG4gICAgfSxcbiAgICBcIjxcIjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgcmV0dXJuIChjID09PSB1bmRlZmluZWQpID8gYSA8IGIgOiAoYSA8IGIpICYmIChiIDwgYyk7XG4gICAgfSxcbiAgICBcIjw9XCI6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiAoYyA9PT0gdW5kZWZpbmVkKSA/IGEgPD0gYiA6IChhIDw9IGIpICYmIChiIDw9IGMpO1xuICAgIH0sXG4gICAgXCIhIVwiOiBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4ganNvbkxvZ2ljLnRydXRoeShhKTtcbiAgICB9LFxuICAgIFwiIVwiOiBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gIWpzb25Mb2dpYy50cnV0aHkoYSk7XG4gICAgfSxcbiAgICBcIiVcIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgJSBiO1xuICAgIH0sXG4gICAgXCJsb2dcIjogZnVuY3Rpb24oYSkge1xuICAgICAgY29uc29sZS5sb2coYSk7IHJldHVybiBhO1xuICAgIH0sXG4gICAgXCJpblwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZih0eXBlb2YgYi5pbmRleE9mID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gKGIuaW5kZXhPZihhKSAhPT0gLTEpO1xuICAgIH0sXG4gICAgXCJjYXRcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsIFwiXCIpO1xuICAgIH0sXG4gICAgXCIrXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSwgMTApICsgcGFyc2VGbG9hdChiLCAxMCk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuICAgIFwiKlwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGEsIDEwKSAqIHBhcnNlRmxvYXQoYiwgMTApO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBcIi1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtYTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9XG4gICAgfSxcbiAgICBcIi9cIjogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAvIGI7IH0sXG4gICAgXCJtaW5cIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIFwibWF4XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBcIm1lcmdlXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfSwgW10pO1xuICAgIH0sXG4gICAgXCJ2YXJcIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIG5vdF9mb3VuZCA9IChiID09PSB1bmRlZmluZWQpID8gbnVsbCA6IGI7XG4gICAgICB2YXIgc3ViX3Byb3BzID0gU3RyaW5nKGEpLnNwbGl0KFwiLlwiKTtcbiAgICAgIHZhciBkYXRhID0gdGhpcztcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzdWJfcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRGVzY2VuZGluZyBpbnRvIGRhdGFcbiAgICAgICAgZGF0YSA9IGRhdGFbc3ViX3Byb3BzW2ldXTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdF9mb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBcIm1pc3NpbmdcIjogZnVuY3Rpb24oKSB7XG4gICAgICAvKlxuICAgICAgTWlzc2luZyBjYW4gcmVjZWl2ZSBtYW55IGtleXMgYXMgbWFueSBhcmd1bWVudHMsIGxpa2Uge1wibWlzc2luZzpbMSwyXX1cbiAgICAgIE1pc3NpbmcgY2FuIGFsc28gcmVjZWl2ZSAqb25lKiBhcmd1bWVudCB0aGF0IGlzIGFuIGFycmF5IG9mIGtleXMsXG4gICAgICB3aGljaCB0eXBpY2FsbHkgaGFwcGVucyBpZiBpdCdzIGFjdHVhbGx5IGFjdGluZyBvbiB0aGUgb3V0cHV0IG9mIGFub3RoZXIgY29tbWFuZFxuICAgICAgKGxpa2UgJ2lmJyBvciAnbWVyZ2UnKVxuICAgICAgKi9cblxuICAgICAgdmFyIG1pc3NpbmcgPSBbXTtcbiAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pID8gYXJndW1lbnRzWzBdIDogYXJndW1lbnRzO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0ganNvbkxvZ2ljLmFwcGx5KHtcInZhclwiOiBrZXl9LCB0aGlzKTtcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICBtaXNzaW5nLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlzc2luZztcbiAgICB9LFxuICAgIFwibWlzc2luZ19zb21lXCI6IGZ1bmN0aW9uKG5lZWRfY291bnQsIG9wdGlvbnMpIHtcbiAgICAgIC8vIG1pc3Npbmdfc29tZSB0YWtlcyB0d28gYXJndW1lbnRzLCBob3cgbWFueSAobWluaW11bSkgaXRlbXMgbXVzdCBiZSBwcmVzZW50LCBhbmQgYW4gYXJyYXkgb2Yga2V5cyAoanVzdCBsaWtlICdtaXNzaW5nJykgdG8gY2hlY2sgZm9yIHByZXNlbmNlLlxuICAgICAgdmFyIGFyZV9taXNzaW5nID0ganNvbkxvZ2ljLmFwcGx5KHtcIm1pc3NpbmdcIjogb3B0aW9uc30sIHRoaXMpO1xuXG4gICAgICBpZihvcHRpb25zLmxlbmd0aCAtIGFyZV9taXNzaW5nLmxlbmd0aCA+PSBuZWVkX2NvdW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gYXJlX21pc3Npbmc7XG4gICAgICB9XG4gICAgfSxcbiAgICBcIm1ldGhvZFwiOiBmdW5jdGlvbihvYmosIG1ldGhvZCwgYXJncykge1xuICAgICAgcmV0dXJuIG9ialttZXRob2RdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgfSxcblxuICB9O1xuXG4gIGpzb25Mb2dpYy5pc19sb2dpYyA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxvZ2ljICE9PSBudWxsICYmIHR5cGVvZiBsb2dpYyA9PT0gXCJvYmplY3RcIiAmJiAhIEFycmF5LmlzQXJyYXkobG9naWMpXG4gICAgKTtcbiAgfTtcblxuICAvKlxuICBUaGlzIGhlbHBlciB3aWxsIGRlZmVyIHRvIHRoZSBKc29uTG9naWMgc3BlYyBhcyBhIHRpZS1icmVha2VyIHdoZW4gZGlmZmVyZW50IGxhbmd1YWdlIGludGVycHJldGVycyBkZWZpbmUgZGlmZmVyZW50IGJlaGF2aW9yIGZvciB0aGUgdHJ1dGhpbmVzcyBvZiBwcmltaXRpdmVzLiAgRS5nLiwgUEhQIGNvbnNpZGVycyBlbXB0eSBhcnJheXMgdG8gYmUgZmFsc3ksIGJ1dCBKYXZhc2NyaXB0IGNvbnNpZGVycyB0aGVtIHRvIGJlIHRydXRoeS4gSnNvbkxvZ2ljLCBhcyBhbiBlY29zeXN0ZW0sIG5lZWRzIG9uZSBjb25zaXN0ZW50IGFuc3dlci5cblxuICBMaXRlcmFsIHwgSlMgICAgfCAgUEhQICB8ICBKc29uTG9naWNcbiAgLS0tLS0tLS0rLS0tLS0tLSstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLVxuICBbXSAgICAgIHwgdHJ1ZSAgfCBmYWxzZSB8IGZhbHNlXG4gIFwiMFwiICAgICB8IHRydWUgIHwgZmFsc2UgfCB0cnVlXG4gICovXG4gIGpzb25Mb2dpYy50cnV0aHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gISEgdmFsdWU7XG4gIH07XG5cblxuICBqc29uTG9naWMuZ2V0X29wZXJhdG9yID0gZnVuY3Rpb24obG9naWMpe1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsb2dpYylbMF07XG4gIH07XG5cbiAganNvbkxvZ2ljLmdldF92YWx1ZXMgPSBmdW5jdGlvbihsb2dpYyl7XG4gICAgcmV0dXJuIGxvZ2ljWyBqc29uTG9naWMuZ2V0X29wZXJhdG9yKGxvZ2ljKSBdO1xuICB9O1xuXG4gIGpzb25Mb2dpYy5hcHBseSA9IGZ1bmN0aW9uKGxvZ2ljLCBkYXRhKSB7XG4gICAgLy8gRG9lcyB0aGlzIGFycmF5IGNvbnRhaW4gbG9naWM/IE9ubHkgb25lIHdheSB0byBmaW5kIG91dC5cbiAgICBpZihBcnJheS5pc0FycmF5KGxvZ2ljKSkge1xuICAgICAgcmV0dXJuIGxvZ2ljLm1hcChmdW5jdGlvbihsKSB7XG4gICAgICAgIHJldHVybiBqc29uTG9naWMuYXBwbHkobCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gWW91J3ZlIHJlY3Vyc2VkIHRvIGEgcHJpbWl0aXZlLCBzdG9wIVxuICAgIGlmKCAhIGpzb25Mb2dpYy5pc19sb2dpYyhsb2dpYykgKSB7XG4gICAgICByZXR1cm4gbG9naWM7XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgICB2YXIgb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKGxvZ2ljKTtcbiAgICB2YXIgdmFsdWVzID0gbG9naWNbb3BdO1xuICAgIHZhciBpO1xuICAgIHZhciBjdXJyZW50O1xuXG4gICAgLy8gZWFzeSBzeW50YXggZm9yIHVuYXJ5IG9wZXJhdG9ycywgbGlrZSB7XCJ2YXJcIiA6IFwieFwifSBpbnN0ZWFkIG9mIHN0cmljdCB7XCJ2YXJcIiA6IFtcInhcIl19XG4gICAgaWYoICEgQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICB9XG5cbiAgICAvLyAnaWYnLCAnYW5kJywgYW5kICdvcicgdmlvbGF0ZSB0aGUgbm9ybWFsIHJ1bGUgb2YgZGVwdGgtZmlyc3QgY2FsY3VsYXRpbmcgY29uc2VxdWVudHMsIGxldCBlYWNoIG1hbmFnZSByZWN1cnNpb24gYXMgbmVlZGVkLlxuICAgIGlmKG9wID09PSBcImlmXCIgfHwgb3AgPT0gXCI/OlwiKSB7XG4gICAgICAvKiAnaWYnIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhIG9kZCBudW1iZXIgb2YgcGFyYW1ldGVycywgMyBvciBncmVhdGVyXG4gICAgICBUaGlzIHdvcmtzIG9uIHRoZSBwYXR0ZXJuOlxuICAgICAgaWYoIDAgKXsgMSB9ZWxzZXsgMiB9O1xuICAgICAgaWYoIDAgKXsgMSB9ZWxzZSBpZiggMiApeyAzIH1lbHNleyA0IH07XG4gICAgICBpZiggMCApeyAxIH1lbHNlIGlmKCAyICl7IDMgfWVsc2UgaWYoIDQgKXsgNSB9ZWxzZXsgNiB9O1xuXG4gICAgICBUaGUgaW1wbGVtZW50YXRpb24gaXM6XG4gICAgICBGb3IgcGFpcnMgb2YgdmFsdWVzICgwLDEgdGhlbiAyLDMgdGhlbiA0LDUgZXRjKVxuICAgICAgSWYgdGhlIGZpcnN0IGV2YWx1YXRlcyB0cnV0aHksIGV2YWx1YXRlIGFuZCByZXR1cm4gdGhlIHNlY29uZFxuICAgICAgSWYgdGhlIGZpcnN0IGV2YWx1YXRlcyBmYWxzeSwganVtcCB0byB0aGUgbmV4dCBwYWlyIChlLmcsIDAsMSB0byAyLDMpXG4gICAgICBnaXZlbiBvbmUgcGFyYW1ldGVyLCBldmFsdWF0ZSBhbmQgcmV0dXJuIGl0LiAoaXQncyBhbiBFbHNlIGFuZCBhbGwgdGhlIElmL0Vsc2VJZiB3ZXJlIGZhbHNlKVxuICAgICAgZ2l2ZW4gMCBwYXJhbWV0ZXJzLCByZXR1cm4gTlVMTCAobm90IGdyZWF0IHByYWN0aWNlLCBidXQgdGhlcmUgd2FzIG5vIEVsc2UpXG4gICAgICAqL1xuICAgICAgZm9yKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICBpZigganNvbkxvZ2ljLnRydXRoeSgganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSkgKSApIHtcbiAgICAgICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpKzFdLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYodmFsdWVzLmxlbmd0aCA9PT0gaSsxKSByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9ZWxzZSBpZihvcCA9PT0gXCJhbmRcIikgeyAvLyBSZXR1cm4gZmlyc3QgZmFsc3ksIG9yIGxhc3RcbiAgICAgIGZvcihpPTA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKz0xKSB7XG4gICAgICAgIGN1cnJlbnQgPSBqc29uTG9naWMuYXBwbHkodmFsdWVzW2ldLCBkYXRhKTtcbiAgICAgICAgaWYoICEganNvbkxvZ2ljLnRydXRoeShjdXJyZW50KSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDsgLy8gTGFzdFxuICAgIH1lbHNlIGlmKG9wID09PSBcIm9yXCIpIHsvLyBSZXR1cm4gZmlyc3QgdHJ1dGh5LCBvciBsYXN0XG4gICAgICBmb3IoaT0wOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICBjdXJyZW50ID0ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSk7XG4gICAgICAgIGlmKCBqc29uTG9naWMudHJ1dGh5KGN1cnJlbnQpICkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDsgLy8gTGFzdFxuICAgIH1cblxuXG4gICAgLy8gRXZlcnlvbmUgZWxzZSBnZXRzIGltbWVkaWF0ZSBkZXB0aC1maXJzdCByZWN1cnNpb25cbiAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIGpzb25Mb2dpYy5hcHBseSh2YWwsIGRhdGEpO1xuICAgIH0pO1xuXG5cbiAgICBpZih0eXBlb2Ygb3BlcmF0aW9uc1tvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG9wZXJhdGlvbnNbb3BdLmFwcGx5KGRhdGEsIHZhbHVlcyk7XG4gICAgfWVsc2UgaWYob3AuaW5kZXhPZihcIi5cIikgPiAwKSB7IC8vIENvbnRhaW5zIGEgZG90LCBhbmQgbm90IGluIHRoZSAwdGggcG9zaXRpb25cbiAgICAgIHZhciBzdWJfb3BzID0gU3RyaW5nKG9wKS5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gb3BlcmF0aW9ucztcbiAgICAgIGZvcihpID0gMDsgaSA8IHN1Yl9vcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRGVzY2VuZGluZyBpbnRvIG9wZXJhdGlvbnNcbiAgICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uW3N1Yl9vcHNbaV1dO1xuICAgICAgICBpZihvcGVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBvcGVyYXRpb24gXCIgKyBvcCArXG4gICAgICAgICAgXCIgKGZhaWxlZCBhdCBcIiArIHN1Yl9vcHMuc2xpY2UoMCwgaSsxKS5qb2luKFwiLlwiKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3BlcmF0aW9uLmFwcGx5KGRhdGEsIHZhbHVlcyk7XG4gICAgfWVsc2V7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgb3BlcmF0aW9uIFwiICsgb3AgKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgb3BlcmF0aW9uIGlzIGNhbGxlZCB3aXRoIFwiZGF0YVwiIGJvdW5kIHRvIGl0cyBcInRoaXNcIiBhbmQgXCJ2YWx1ZXNcIiBwYXNzZWQgYXMgYXJndW1lbnRzLlxuICAgIC8vIFN0cnVjdHVyZWQgY29tbWFuZHMgbGlrZSAlIG9yID4gY2FuIG5hbWUgZm9ybWFsIGFyZ3VtZW50cyB3aGlsZSBmbGV4aWJsZSBjb21tYW5kcyAobGlrZSBtaXNzaW5nIG9yIG1lcmdlKSBjYW4gb3BlcmF0ZSBvbiB0aGUgcHNldWRvLWFycmF5IGFyZ3VtZW50c1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9hcmd1bWVudHNcbiAgICByZXR1cm4gb3BlcmF0aW9uc1tvcF0uYXBwbHkoZGF0YSwgdmFsdWVzKTtcbiAgfTtcblxuICBqc29uTG9naWMudXNlc19kYXRhID0gZnVuY3Rpb24obG9naWMpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IFtdO1xuXG4gICAgaWYoIGpzb25Mb2dpYy5pc19sb2dpYyhsb2dpYykgKSB7XG4gICAgICB2YXIgb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKGxvZ2ljKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBsb2dpY1tvcF07XG5cbiAgICAgIGlmKCAhIEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgIH1cblxuICAgICAgaWYob3AgPT09IFwidmFyXCIpIHtcbiAgICAgICAgLy8gVGhpcyBkb2Vzbid0IGNvdmVyIHRoZSBjYXNlIHdoZXJlIHRoZSBhcmcgdG8gdmFyIGlzIGl0c2VsZiBhIHJ1bGUuXG4gICAgICAgIGNvbGxlY3Rpb24ucHVzaCh2YWx1ZXNbMF0pO1xuICAgICAgfWVsc2V7XG4gICAgICAgIC8vIFJlY3Vyc2lvbiFcbiAgICAgICAgdmFsdWVzLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICBjb2xsZWN0aW9uLnB1c2guYXBwbHkoY29sbGVjdGlvbiwganNvbkxvZ2ljLnVzZXNfZGF0YSh2YWwpICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVVuaXF1ZShjb2xsZWN0aW9uKTtcbiAgfTtcblxuICBqc29uTG9naWMuYWRkX29wZXJhdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGNvZGUpIHtcbiAgICBvcGVyYXRpb25zW25hbWVdID0gY29kZTtcbiAgfTtcblxuXG4gIGpzb25Mb2dpYy5ydWxlX2xpa2UgPSBmdW5jdGlvbihydWxlLCBwYXR0ZXJuKXtcblx0XHQvL2NvbnNvbGUubG9nKFwiSXMgXCIuIEpTT04uc3RyaW5naWZ5KHJ1bGUpIC4gXCIgbGlrZSBcIiAuIEpTT04uc3RyaW5naWZ5KHBhdHRlcm4pIC4gXCI/XCIpO1xuXHQgIGlmKHBhdHRlcm4gPT09IHJ1bGUpeyByZXR1cm4gdHJ1ZTsgfSAvL1RPRE8gOiBEZWVwIG9iamVjdCBlcXVpdmFsZW5jeT9cblx0ICBpZihwYXR0ZXJuID09PSBcIkBcIil7IHJldHVybiB0cnVlOyB9IC8vV2lsZGNhcmQhXG5cdCAgaWYocGF0dGVybiA9PT0gXCJudW1iZXJcIil7IHJldHVybiAodHlwZW9mIHJ1bGUgPT09ICdudW1iZXInKTsgfVxuXHQgIGlmKHBhdHRlcm4gPT09IFwic3RyaW5nXCIpeyByZXR1cm4gKHR5cGVvZiBydWxlID09PSAnc3RyaW5nJyk7IH1cblx0ICBpZihwYXR0ZXJuID09PSBcImFycmF5XCIpe1xuICAgICAgLy8hbG9naWMgdGVzdCBtaWdodCBiZSBzdXBlcmZsdW91cyBpbiBKYXZhU2NyaXB0XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShydWxlKSAmJiAhIGpzb25Mb2dpYy5pc19sb2dpYyhydWxlKTtcbiAgICB9XG5cblx0ICBpZihqc29uTG9naWMuaXNfbG9naWMocGF0dGVybikpe1xuXHQgICAgaWYoanNvbkxvZ2ljLmlzX2xvZ2ljKHJ1bGUpKXtcblx0ICAgICAgdmFyIHBhdHRlcm5fb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKHBhdHRlcm4pO1xuICAgICAgICB2YXIgcnVsZV9vcCA9IGpzb25Mb2dpYy5nZXRfb3BlcmF0b3IocnVsZSk7XG5cblx0ICAgICAgaWYocGF0dGVybl9vcCA9PT0gXCJAXCIgfHwgcGF0dGVybl9vcCA9PT0gcnVsZV9vcCl7XG5cdFx0XHRcdFx0Ly9lY2hvIFwiXFxuT3BlcmF0b3JzIG1hdGNoLCBnbyBkZWVwZXJcXG5cIjtcblx0ICAgICAgICByZXR1cm4ganNvbkxvZ2ljLnJ1bGVfbGlrZShcblx0XHRcdFx0XHRcdGpzb25Mb2dpYy5nZXRfdmFsdWVzKHJ1bGUsIGZhbHNlKSxcblx0XHRcdFx0XHRcdGpzb25Mb2dpYy5nZXRfdmFsdWVzKHBhdHRlcm4sIGZhbHNlKVxuXHRcdFx0XHRcdCk7XG5cdCAgICAgIH1cblxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlOyAvL3BhdHRlcm4gaXMgbG9naWMsIHJ1bGUgaXNuJ3QsIGNhbid0IGJlIGVxXG5cdCAgfVxuXG5cdCAgaWYoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSl7XG5cdCAgICBpZihBcnJheS5pc0FycmF5KHJ1bGUpKXtcblx0ICAgICAgaWYocGF0dGVybi5sZW5ndGggIT09IHJ1bGUubGVuZ3RoKXsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdC8qXG5cdFx0XHRcdFx0Tm90ZSwgYXJyYXkgb3JkZXIgTUFUVEVSUywgYmVjYXVzZSB3ZSdyZSB1c2luZyB0aGlzIGFycmF5IHRlc3QgbG9naWMgdG8gY29uc2lkZXIgYXJndW1lbnRzLCB3aGVyZSBvcmRlciBjYW4gbWF0dGVyLiAoZS5nLiwgKyBpcyBjb21tdXRhdGl2ZSwgYnV0ICctJyBvciAnaWYnIG9yICd2YXInIGFyZSBOT1QpXG5cdFx0XHRcdCovXG5cdCAgICAgIGZvcih2YXIgaSA9IDAgOyBpIDwgcGF0dGVybi5sZW5ndGggOyBpICs9IDEpe1xuXHQgICAgICAgIC8vSWYgYW55IGZhaWwsIHdlIGZhaWxcblx0ICAgICAgICBpZiggISBqc29uTG9naWMucnVsZV9saWtlKHJ1bGVbaV0sIHBhdHRlcm5baV0pKXsgcmV0dXJuIGZhbHNlOyB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRydWU7IC8vSWYgdGhleSAqYWxsKiBwYXNzZWQsIHdlIHBhc3Ncblx0ICAgIH1lbHNle1xuXHQgICAgICByZXR1cm4gZmFsc2U7IC8vUGF0dGVybiBpcyBhcnJheSwgcnVsZSBpc24ndFxuXHQgICAgfVxuXG5cdCAgfVxuXG5cdFx0Ly9Ob3QgbG9naWMsIG5vdCBhcnJheSwgbm90IGEgPT09IG1hdGNoIGZvciBydWxlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cbiAgcmV0dXJuIGpzb25Mb2dpYztcbn0pKTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQWRkcyB0aGUga2V5LXZhbHVlIGBwYWlyYCB0byBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXIgVGhlIGtleS12YWx1ZSBwYWlyIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG1hcGAuXG4gKi9cbmZ1bmN0aW9uIGFkZE1hcEVudHJ5KG1hcCwgcGFpcikge1xuICAvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xuICByZXR1cm4gbWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZE1hcEVudHJ5O1xuIiwiLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICovXG5mdW5jdGlvbiBhZGRTZXRFbnRyeShzZXQsIHZhbHVlKSB7XG4gIC8vIERvbid0IHJldHVybiBgc2V0LmFkZGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIHNldC5hZGQodmFsdWUpO1xuICByZXR1cm4gc2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFNldEVudHJ5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGJhc2VDbG9uZSwgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmlsdGVyO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCJ2YXIgYWRkTWFwRW50cnkgPSByZXF1aXJlKCcuL19hZGRNYXBFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgbWFwLlxuICovXG5mdW5jdGlvbiBjbG9uZU1hcChtYXAsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhtYXBUb0FycmF5KG1hcCksIENMT05FX0RFRVBfRkxBRykgOiBtYXBUb0FycmF5KG1hcCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkTWFwRW50cnksIG5ldyBtYXAuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lTWFwO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBhZGRTZXRFbnRyeSA9IHJlcXVpcmUoJy4vX2FkZFNldEVudHJ5JyksXG4gICAgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSwgQ0xPTkVfREVFUF9GTEFHKSA6IHNldFRvQXJyYXkoc2V0KTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRTZXRFbnRyeSwgbmV3IHNldC5jb25zdHJ1Y3Rvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTZXQ7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZU1hcCA9IHJlcXVpcmUoJy4vX2Nsb25lTWFwJyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU2V0ID0gcmVxdWlyZSgnLi9fY2xvbmVTZXQnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgY2xvbmVGdW5jLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBjbG9uZU1hcChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTZXQob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEZWVwO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIGJhc2VGaWx0ZXIgPSByZXF1aXJlKCcuL19iYXNlRmlsdGVyJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCJ2YXIgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAqIGBwYXRoYCBjcmVhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gKiAvLyA9PiA0XG4gKlxuICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICogLy8gPT4gNVxuICovXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwiLyohIE5hdGl2ZSBQcm9taXNlIE9ubHlcbiAgICB2MC44LjEgKGMpIEt5bGUgU2ltcHNvblxuICAgIE1JVCBMaWNlbnNlOiBodHRwOi8vZ2V0aWZ5Lm1pdC1saWNlbnNlLm9yZ1xuKi9cblxuKGZ1bmN0aW9uIFVNRChuYW1lLGNvbnRleHQsZGVmaW5pdGlvbil7XG5cdC8vIHNwZWNpYWwgZm9ybSBvZiBVTUQgZm9yIHBvbHlmaWxsaW5nIGFjcm9zcyBldmlyb25tZW50c1xuXHRjb250ZXh0W25hbWVdID0gY29udGV4dFtuYW1lXSB8fCBkZWZpbml0aW9uKCk7XG5cdGlmICh0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsgbW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0W25hbWVdOyB9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHsgZGVmaW5lKGZ1bmN0aW9uICRBTUQkKCl7IHJldHVybiBjb250ZXh0W25hbWVdOyB9KTsgfVxufSkoXCJQcm9taXNlXCIsdHlwZW9mIGdsb2JhbCAhPSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdGhpcyxmdW5jdGlvbiBERUYoKXtcblx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGJ1aWx0SW5Qcm9wLCBjeWNsZSwgc2NoZWR1bGluZ19xdWV1ZSxcblx0XHRUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0dGltZXIgPSAodHlwZW9mIHNldEltbWVkaWF0ZSAhPSBcInVuZGVmaW5lZFwiKSA/XG5cdFx0XHRmdW5jdGlvbiB0aW1lcihmbikgeyByZXR1cm4gc2V0SW1tZWRpYXRlKGZuKTsgfSA6XG5cdFx0XHRzZXRUaW1lb3V0XG5cdDtcblxuXHQvLyBkYW1taXQsIElFOC5cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJ4XCIse30pO1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsLGNvbmZpZykge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosbmFtZSx7XG5cdFx0XHRcdHZhbHVlOiB2YWwsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblx0Y2F0Y2ggKGVycikge1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsKSB7XG5cdFx0XHRvYmpbbmFtZV0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH1cblxuXHQvLyBOb3RlOiB1c2luZyBhIHF1ZXVlIGluc3RlYWQgb2YgYXJyYXkgZm9yIGVmZmljaWVuY3lcblx0c2NoZWR1bGluZ19xdWV1ZSA9IChmdW5jdGlvbiBRdWV1ZSgpIHtcblx0XHR2YXIgZmlyc3QsIGxhc3QsIGl0ZW07XG5cblx0XHRmdW5jdGlvbiBJdGVtKGZuLHNlbGYpIHtcblx0XHRcdHRoaXMuZm4gPSBmbjtcblx0XHRcdHRoaXMuc2VsZiA9IHNlbGY7XG5cdFx0XHR0aGlzLm5leHQgPSB2b2lkIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZDogZnVuY3Rpb24gYWRkKGZuLHNlbGYpIHtcblx0XHRcdFx0aXRlbSA9IG5ldyBJdGVtKGZuLHNlbGYpO1xuXHRcdFx0XHRpZiAobGFzdCkge1xuXHRcdFx0XHRcdGxhc3QubmV4dCA9IGl0ZW07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Zmlyc3QgPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3QgPSBpdGVtO1xuXHRcdFx0XHRpdGVtID0gdm9pZCAwO1xuXHRcdFx0fSxcblx0XHRcdGRyYWluOiBmdW5jdGlvbiBkcmFpbigpIHtcblx0XHRcdFx0dmFyIGYgPSBmaXJzdDtcblx0XHRcdFx0Zmlyc3QgPSBsYXN0ID0gY3ljbGUgPSB2b2lkIDA7XG5cblx0XHRcdFx0d2hpbGUgKGYpIHtcblx0XHRcdFx0XHRmLmZuLmNhbGwoZi5zZWxmKTtcblx0XHRcdFx0XHRmID0gZi5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBzY2hlZHVsZShmbixzZWxmKSB7XG5cdFx0c2NoZWR1bGluZ19xdWV1ZS5hZGQoZm4sc2VsZik7XG5cdFx0aWYgKCFjeWNsZSkge1xuXHRcdFx0Y3ljbGUgPSB0aW1lcihzY2hlZHVsaW5nX3F1ZXVlLmRyYWluKTtcblx0XHR9XG5cdH1cblxuXHQvLyBwcm9taXNlIGR1Y2sgdHlwaW5nXG5cdGZ1bmN0aW9uIGlzVGhlbmFibGUobykge1xuXHRcdHZhciBfdGhlbiwgb190eXBlID0gdHlwZW9mIG87XG5cblx0XHRpZiAobyAhPSBudWxsICYmXG5cdFx0XHQoXG5cdFx0XHRcdG9fdHlwZSA9PSBcIm9iamVjdFwiIHx8IG9fdHlwZSA9PSBcImZ1bmN0aW9uXCJcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdF90aGVuID0gby50aGVuO1xuXHRcdH1cblx0XHRyZXR1cm4gdHlwZW9mIF90aGVuID09IFwiZnVuY3Rpb25cIiA/IF90aGVuIDogZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBub3RpZnkoKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hhaW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5vdGlmeUlzb2xhdGVkKFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHQodGhpcy5zdGF0ZSA9PT0gMSkgPyB0aGlzLmNoYWluW2ldLnN1Y2Nlc3MgOiB0aGlzLmNoYWluW2ldLmZhaWx1cmUsXG5cdFx0XHRcdHRoaXMuY2hhaW5baV1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdHRoaXMuY2hhaW4ubGVuZ3RoID0gMDtcblx0fVxuXG5cdC8vIE5PVEU6IFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiB0byBpc29sYXRlXG5cdC8vIHRoZSBgdHJ5Li5jYXRjaGAgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBiZVxuXHQvLyBvcHRpbWl6ZWQgYmV0dGVyXG5cdGZ1bmN0aW9uIG5vdGlmeUlzb2xhdGVkKHNlbGYsY2IsY2hhaW4pIHtcblx0XHR2YXIgcmV0LCBfdGhlbjtcblx0XHR0cnkge1xuXHRcdFx0aWYgKGNiID09PSBmYWxzZSkge1xuXHRcdFx0XHRjaGFpbi5yZWplY3Qoc2VsZi5tc2cpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChjYiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHJldCA9IHNlbGYubXNnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldCA9IGNiLmNhbGwodm9pZCAwLHNlbGYubXNnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXQgPT09IGNoYWluLnByb21pc2UpIHtcblx0XHRcdFx0XHRjaGFpbi5yZWplY3QoVHlwZUVycm9yKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKHJldCkpIHtcblx0XHRcdFx0XHRfdGhlbi5jYWxsKHJldCxjaGFpbi5yZXNvbHZlLGNoYWluLnJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2hhaW4ucmVzb2x2ZShyZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdGNoYWluLnJlamVjdChlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmUobXNnKSB7XG5cdFx0dmFyIF90aGVuLCBzZWxmID0gdGhpcztcblxuXHRcdC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuXHRcdGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuXHRcdHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuXHRcdC8vIHVud3JhcFxuXHRcdGlmIChzZWxmLmRlZikge1xuXHRcdFx0c2VsZiA9IHNlbGYuZGVmO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKG1zZykpIHtcblx0XHRcdFx0c2NoZWR1bGUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgZGVmX3dyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdF90aGVuLmNhbGwobXNnLFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVzb2x2ZSQoKXsgcmVzb2x2ZS5hcHBseShkZWZfd3JhcHBlcixhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVqZWN0JCgpeyByZWplY3QuYXBwbHkoZGVmX3dyYXBwZXIsYXJndW1lbnRzKTsgfVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0cmVqZWN0LmNhbGwoZGVmX3dyYXBwZXIsZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2VsZi5tc2cgPSBtc2c7XG5cdFx0XHRcdHNlbGYuc3RhdGUgPSAxO1xuXHRcdFx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0c2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHJlamVjdC5jYWxsKG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKSxlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlamVjdChtc2cpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBhbHJlYWR5IHRyaWdnZXJlZD9cblx0XHRpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cblx0XHRzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cblx0XHQvLyB1bndyYXBcblx0XHRpZiAoc2VsZi5kZWYpIHtcblx0XHRcdHNlbGYgPSBzZWxmLmRlZjtcblx0XHR9XG5cblx0XHRzZWxmLm1zZyA9IG1zZztcblx0XHRzZWxmLnN0YXRlID0gMjtcblx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRzY2hlZHVsZShub3RpZnksc2VsZik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixyZXNvbHZlcixyZWplY3Rlcikge1xuXHRcdGZvciAodmFyIGlkeD0wOyBpZHg8YXJyLmxlbmd0aDsgaWR4KyspIHtcblx0XHRcdChmdW5jdGlvbiBJSUZFKGlkeCl7XG5cdFx0XHRcdENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pXG5cdFx0XHRcdC50aGVuKFxuXHRcdFx0XHRcdGZ1bmN0aW9uICRyZXNvbHZlciQobXNnKXtcblx0XHRcdFx0XHRcdHJlc29sdmVyKGlkeCxtc2cpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVqZWN0ZXJcblx0XHRcdFx0KTtcblx0XHRcdH0pKGlkeCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZldyYXBwZXIoc2VsZikge1xuXHRcdHRoaXMuZGVmID0gc2VsZjtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZihzZWxmKSB7XG5cdFx0dGhpcy5wcm9taXNlID0gc2VsZjtcblx0XHR0aGlzLnN0YXRlID0gMDtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHRcdHRoaXMuY2hhaW4gPSBbXTtcblx0XHR0aGlzLm1zZyA9IHZvaWQgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcblx0XHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX19OUE9fXyAhPT0gMCkge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgcHJvbWlzZVwiKTtcblx0XHR9XG5cblx0XHQvLyBpbnN0YW5jZSBzaGFkb3dpbmcgdGhlIGluaGVyaXRlZCBcImJyYW5kXCJcblx0XHQvLyB0byBzaWduYWwgYW4gYWxyZWFkeSBcImluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRcdHRoaXMuX19OUE9fXyA9IDE7XG5cblx0XHR2YXIgZGVmID0gbmV3IE1ha2VEZWYodGhpcyk7XG5cblx0XHR0aGlzW1widGhlblwiXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcyxmYWlsdXJlKSB7XG5cdFx0XHR2YXIgbyA9IHtcblx0XHRcdFx0c3VjY2VzczogdHlwZW9mIHN1Y2Nlc3MgPT0gXCJmdW5jdGlvblwiID8gc3VjY2VzcyA6IHRydWUsXG5cdFx0XHRcdGZhaWx1cmU6IHR5cGVvZiBmYWlsdXJlID09IFwiZnVuY3Rpb25cIiA/IGZhaWx1cmUgOiBmYWxzZVxuXHRcdFx0fTtcblx0XHRcdC8vIE5vdGU6IGB0aGVuKC4uKWAgaXRzZWxmIGNhbiBiZSBib3Jyb3dlZCB0byBiZSB1c2VkIGFnYWluc3Rcblx0XHRcdC8vIGEgZGlmZmVyZW50IHByb21pc2UgY29uc3RydWN0b3IgZm9yIG1ha2luZyB0aGUgY2hhaW5lZCBwcm9taXNlLFxuXHRcdFx0Ly8gYnkgc3Vic3RpdHV0aW5nIGEgZGlmZmVyZW50IGB0aGlzYCBiaW5kaW5nLlxuXHRcdFx0by5wcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24gZXh0cmFjdENoYWluKHJlc29sdmUscmVqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG8ucmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdG8ucmVqZWN0ID0gcmVqZWN0O1xuXHRcdFx0fSk7XG5cdFx0XHRkZWYuY2hhaW4ucHVzaChvKTtcblxuXHRcdFx0aWYgKGRlZi5zdGF0ZSAhPT0gMCkge1xuXHRcdFx0XHRzY2hlZHVsZShub3RpZnksZGVmKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG8ucHJvbWlzZTtcblx0XHR9O1xuXHRcdHRoaXNbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsZmFpbHVyZSk7XG5cdFx0fTtcblxuXHRcdHRyeSB7XG5cdFx0XHRleGVjdXRvci5jYWxsKFxuXHRcdFx0XHR2b2lkIDAsXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKXtcblx0XHRcdFx0XHRyZXNvbHZlLmNhbGwoZGVmLG1zZyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1JlamVjdChtc2cpIHtcblx0XHRcdFx0XHRyZWplY3QuY2FsbChkZWYsbXNnKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0cmVqZWN0LmNhbGwoZGVmLGVycik7XG5cdFx0fVxuXHR9XG5cblx0dmFyIFByb21pc2VQcm90b3R5cGUgPSBidWlsdEluUHJvcCh7fSxcImNvbnN0cnVjdG9yXCIsUHJvbWlzZSxcblx0XHQvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG5cdCk7XG5cblx0Ly8gTm90ZTogQW5kcm9pZCA0IGNhbm5vdCB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSguLilgIGhlcmVcblx0UHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlUHJvdG90eXBlO1xuXG5cdC8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRidWlsdEluUHJvcChQcm9taXNlUHJvdG90eXBlLFwiX19OUE9fX1wiLDAsXG5cdFx0Lypjb25maWd1cmFibGU9Ki9mYWxzZVxuXHQpO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyZXNvbHZlXCIsZnVuY3Rpb24gUHJvbWlzZSRyZXNvbHZlKG1zZykge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdC8vIG5vdGU6IGJlc3QgXCJpc1Byb21pc2VcIiBjaGVjayB0aGF0J3MgcHJhY3RpY2FsIGZvciBub3dcblx0XHRpZiAobXNnICYmIHR5cGVvZiBtc2cgPT0gXCJvYmplY3RcIiAmJiBtc2cuX19OUE9fXyA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIG1zZztcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdHJlc29sdmUobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJlamVjdFwiLGZ1bmN0aW9uIFByb21pc2UkcmVqZWN0KG1zZykge1xuXHRcdHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWplY3QobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcImFsbFwiLGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdGlmIChUb1N0cmluZy5jYWxsKGFycikgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk7XG5cdFx0fVxuXHRcdGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVzb2x2ZShbXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aCwgbXNncyA9IEFycmF5KGxlbiksIGNvdW50ID0gMDtcblxuXHRcdFx0aXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKSB7XG5cdFx0XHRcdG1zZ3NbaWR4XSA9IG1zZztcblx0XHRcdFx0aWYgKCsrY291bnQgPT09IGxlbikge1xuXHRcdFx0XHRcdHJlc29sdmUobXNncyk7XG5cdFx0XHRcdH1cblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJhY2VcIixmdW5jdGlvbiBQcm9taXNlJHJhY2UoYXJyKSB7XG5cdFx0dmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuXHRcdC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG5cdFx0aWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0XHRcdHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZyl7XG5cdFx0XHRcdHJlc29sdmUobXNnKTtcblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0cmV0dXJuIFByb21pc2U7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSByZXR1cm4gb2JqO1xuICAgIFxuICAgIHZhciBjb3B5O1xuICAgIFxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICAgIGNvcHkgPSBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMob2JqKTtcbiAgICAgICAgY29weSA9IHt9O1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyohXG4gKiBTaWduYXR1cmUgUGFkIHYxLjYuMFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9zaWduYXR1cmVfcGFkXG4gKlxuICogQ29weXJpZ2h0IDIwMTcgU3p5bW9uIE5vd2FrXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqXG4gKiBUaGUgbWFpbiBpZGVhIGFuZCBzb21lIHBhcnRzIG9mIHRoZSBjb2RlIChlLmcuIGRyYXdpbmcgdmFyaWFibGUgd2lkdGggQsOpemllciBjdXJ2ZSkgYXJlIHRha2VuIGZyb206XG4gKiBodHRwOi8vY29ybmVyLnNxdWFyZXVwLmNvbS8yMDEyLzA3L3Ntb290aGVyLXNpZ25hdHVyZXMuaHRtbFxuICpcbiAqIEltcGxlbWVudGF0aW9uIG9mIGludGVycG9sYXRpb24gdXNpbmcgY3ViaWMgQsOpemllciBjdXJ2ZXMgaXMgdGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly9iZW5rbm93c2NvZGUud29yZHByZXNzLmNvbS8yMDEyLzA5LzE0L3BhdGgtaW50ZXJwb2xhdGlvbi11c2luZy1jdWJpYy1iZXppZXItYW5kLWNvbnRyb2wtcG9pbnQtZXN0aW1hdGlvbi1pbi1qYXZhc2NyaXB0XG4gKlxuICogQWxnb3JpdGhtIGZvciBhcHByb3hpbWF0ZWQgbGVuZ3RoIG9mIGEgQsOpemllciBjdXJ2ZSBpcyB0YWtlbiBmcm9tOlxuICogaHR0cDovL3d3dy5sZW1vZGEubmV0L21hdGhzL2Jlemllci1sZW5ndGgvaW5kZXguaHRtbFxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuU2lnbmF0dXJlUGFkID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBQb2ludCh4LCB5LCB0aW1lKSB7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMudGltZSA9IHRpbWUgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59XG5cblBvaW50LnByb3RvdHlwZS52ZWxvY2l0eUZyb20gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgcmV0dXJuIHRoaXMudGltZSAhPT0gc3RhcnQudGltZSA/IHRoaXMuZGlzdGFuY2VUbyhzdGFydCkgLyAodGhpcy50aW1lIC0gc3RhcnQudGltZSkgOiAxO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRpc3RhbmNlVG8gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSBzdGFydC54LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHN0YXJ0LnksIDIpKTtcbn07XG5cbmZ1bmN0aW9uIEJlemllcihzdGFydFBvaW50LCBjb250cm9sMSwgY29udHJvbDIsIGVuZFBvaW50KSB7XG4gIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gIHRoaXMuY29udHJvbDEgPSBjb250cm9sMTtcbiAgdGhpcy5jb250cm9sMiA9IGNvbnRyb2wyO1xuICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XG59XG5cbi8vIFJldHVybnMgYXBwcm94aW1hdGVkIGxlbmd0aC5cbkJlemllci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RlcHMgPSAxMDtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBweCA9IHZvaWQgMDtcbiAgdmFyIHB5ID0gdm9pZCAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHN0ZXBzOyBpICs9IDEpIHtcbiAgICB2YXIgdCA9IGkgLyBzdGVwcztcbiAgICB2YXIgY3ggPSB0aGlzLl9wb2ludCh0LCB0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5jb250cm9sMS54LCB0aGlzLmNvbnRyb2wyLngsIHRoaXMuZW5kUG9pbnQueCk7XG4gICAgdmFyIGN5ID0gdGhpcy5fcG9pbnQodCwgdGhpcy5zdGFydFBvaW50LnksIHRoaXMuY29udHJvbDEueSwgdGhpcy5jb250cm9sMi55LCB0aGlzLmVuZFBvaW50LnkpO1xuICAgIGlmIChpID4gMCkge1xuICAgICAgdmFyIHhkaWZmID0gY3ggLSBweDtcbiAgICAgIHZhciB5ZGlmZiA9IGN5IC0gcHk7XG4gICAgICBsZW5ndGggKz0gTWF0aC5zcXJ0KHhkaWZmICogeGRpZmYgKyB5ZGlmZiAqIHlkaWZmKTtcbiAgICB9XG4gICAgcHggPSBjeDtcbiAgICBweSA9IGN5O1xuICB9XG5cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcywgc3BhY2UtaW4tcGFyZW5zICovXG5CZXppZXIucHJvdG90eXBlLl9wb2ludCA9IGZ1bmN0aW9uICh0LCBzdGFydCwgYzEsIGMyLCBlbmQpIHtcbiAgcmV0dXJuIHN0YXJ0ICogKDEuMCAtIHQpICogKDEuMCAtIHQpICogKDEuMCAtIHQpICsgMy4wICogYzEgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgKiB0ICsgMy4wICogYzIgKiAoMS4wIC0gdCkgKiB0ICogdCArIGVuZCAqIHQgKiB0ICogdDtcbn07XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZVBhZChjYW52YXMsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCA9IG9wdHMudmVsb2NpdHlGaWx0ZXJXZWlnaHQgfHwgMC43O1xuICB0aGlzLm1pbldpZHRoID0gb3B0cy5taW5XaWR0aCB8fCAwLjU7XG4gIHRoaXMubWF4V2lkdGggPSBvcHRzLm1heFdpZHRoIHx8IDIuNTtcbiAgdGhpcy5kb3RTaXplID0gb3B0cy5kb3RTaXplIHx8IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMubWluV2lkdGggKyB0aGlzLm1heFdpZHRoKSAvIDI7XG4gIH07XG4gIHRoaXMucGVuQ29sb3IgPSBvcHRzLnBlbkNvbG9yIHx8ICdibGFjayc7XG4gIHRoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3JnYmEoMCwwLDAsMCknO1xuICB0aGlzLm9uQmVnaW4gPSBvcHRzLm9uQmVnaW47XG4gIHRoaXMub25FbmQgPSBvcHRzLm9uRW5kO1xuXG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIHRoaXMuY2xlYXIoKTtcblxuICAvLyBXZSBuZWVkIGFkZCB0aGVzZSBpbmxpbmUgc28gdGhleSBhcmUgYXZhaWxhYmxlIHRvIHVuYmluZCB3aGlsZSBzdGlsbCBoYXZpbmdcbiAgLy8gYWNjZXNzIHRvICdzZWxmJyB3ZSBjb3VsZCB1c2UgXy5iaW5kIGJ1dCBpdCdzIG5vdCB3b3J0aCBhZGRpbmcgYSBkZXBlbmRlbmN5LlxuICB0aGlzLl9oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEpIHtcbiAgICAgIHNlbGYuX21vdXNlQnV0dG9uRG93biA9IHRydWU7XG4gICAgICBzZWxmLl9zdHJva2VCZWdpbihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChzZWxmLl9tb3VzZUJ1dHRvbkRvd24pIHtcbiAgICAgIHNlbGYuX3N0cm9rZVVwZGF0ZShldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuX2hhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEgJiYgc2VsZi5fbW91c2VCdXR0b25Eb3duKSB7XG4gICAgICBzZWxmLl9tb3VzZUJ1dHRvbkRvd24gPSBmYWxzZTtcbiAgICAgIHNlbGYuX3N0cm9rZUVuZChldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgc2VsZi5fc3Ryb2tlQmVnaW4odG91Y2gpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLl9oYW5kbGVUb3VjaE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBQcmV2ZW50IHNjcm9sbGluZy5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIHRvdWNoID0gZXZlbnQudGFyZ2V0VG91Y2hlc1swXTtcbiAgICBzZWxmLl9zdHJva2VVcGRhdGUodG91Y2gpO1xuICB9O1xuXG4gIHRoaXMuX2hhbmRsZVRvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHdhc0NhbnZhc1RvdWNoZWQgPSBldmVudC50YXJnZXQgPT09IHNlbGYuX2NhbnZhcztcbiAgICBpZiAod2FzQ2FudmFzVG91Y2hlZCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbGYuX3N0cm9rZUVuZChldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuYWJsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnQgaGFuZGxlcnNcbiAgdGhpcy5vbigpO1xufVxuXG4vLyBQdWJsaWMgbWV0aG9kc1xuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgdGhpcy5fZGF0YSA9IFtdO1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLl9pc0VtcHR5ID0gdHJ1ZTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuZnJvbURhdGFVUkwgPSBmdW5jdGlvbiAoZGF0YVVybCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICB2YXIgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICB2YXIgd2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGggLyByYXRpbztcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgLyByYXRpbztcblxuICB0aGlzLl9yZXNldCgpO1xuICBpbWFnZS5zcmMgPSBkYXRhVXJsO1xuICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuX2N0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICB0aGlzLl9pc0VtcHR5ID0gZmFsc2U7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBfY2FudmFzO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2ltYWdlL3N2Zyt4bWwnOlxuICAgICAgcmV0dXJuIHRoaXMuX3RvU1ZHKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRpb25zID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBvcHRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfY2FudmFzID0gdGhpcy5fY2FudmFzKS50b0RhdGFVUkwuYXBwbHkoX2NhbnZhcywgW3R5cGVdLmNvbmNhdChvcHRpb25zKSk7XG4gIH1cbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnRzKCk7XG4gIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnRzKCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZU1vdXNlRG93bik7XG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VVcCk7XG5cbiAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVRvdWNoTW92ZSk7XG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZVRvdWNoRW5kKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzRW1wdHk7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZHNcblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZUJlZ2luID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHRoaXMuX2RhdGEucHVzaChbXSk7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuX3N0cm9rZVVwZGF0ZShldmVudCk7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLm9uQmVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uQmVnaW4oZXZlbnQpO1xuICB9XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9zdHJva2VVcGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHggPSBldmVudC5jbGllbnRYO1xuICB2YXIgeSA9IGV2ZW50LmNsaWVudFk7XG5cbiAgdmFyIHBvaW50ID0gdGhpcy5fY3JlYXRlUG9pbnQoeCwgeSk7XG5cbiAgdmFyIF9hZGRQb2ludCA9IHRoaXMuX2FkZFBvaW50KHBvaW50KSxcbiAgICAgIGN1cnZlID0gX2FkZFBvaW50LmN1cnZlLFxuICAgICAgd2lkdGhzID0gX2FkZFBvaW50LndpZHRocztcblxuICBpZiAoY3VydmUgJiYgd2lkdGhzKSB7XG4gICAgdGhpcy5fZHJhd0N1cnZlKGN1cnZlLCB3aWR0aHMuc3RhcnQsIHdpZHRocy5lbmQpO1xuICB9XG5cbiAgdGhpcy5fZGF0YVt0aGlzLl9kYXRhLmxlbmd0aCAtIDFdLnB1c2goe1xuICAgIHg6IHBvaW50LngsXG4gICAgeTogcG9pbnQueSxcbiAgICB0aW1lOiBwb2ludC50aW1lXG4gIH0pO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYW5EcmF3Q3VydmUgPSB0aGlzLnBvaW50cy5sZW5ndGggPiAyO1xuICB2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1swXTtcblxuICBpZiAoIWNhbkRyYXdDdXJ2ZSAmJiBwb2ludCkge1xuICAgIHRoaXMuX2RyYXdEb3QocG9pbnQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0aGlzLm9uRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vbkVuZChldmVudCk7XG4gIH1cbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2hhbmRsZU1vdXNlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9tb3VzZUJ1dHRvbkRvd24gPSBmYWxzZTtcblxuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlTW91c2VEb3duKTtcbiAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZVVwKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2hhbmRsZVRvdWNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAvLyBQYXNzIHRvdWNoIGV2ZW50cyB0byBjYW52YXMgZWxlbWVudCBvbiBtb2JpbGUgSUUxMSBhbmQgRWRnZS5cbiAgdGhpcy5fY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gIHRoaXMuX2NhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcblxuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQpO1xuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlVG91Y2hFbmQpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9pbnRzID0gW107XG4gIHRoaXMuX2xhc3RWZWxvY2l0eSA9IDA7XG4gIHRoaXMuX2xhc3RXaWR0aCA9ICh0aGlzLm1pbldpZHRoICsgdGhpcy5tYXhXaWR0aCkgLyAyO1xuICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5wZW5Db2xvcjtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2NyZWF0ZVBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHRpbWUpIHtcbiAgdmFyIHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgcmV0dXJuIG5ldyBQb2ludCh4IC0gcmVjdC5sZWZ0LCB5IC0gcmVjdC50b3AsIHRpbWUgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fYWRkUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICB2YXIgdG1wID0gdm9pZCAwO1xuXG4gIHBvaW50cy5wdXNoKHBvaW50KTtcblxuICBpZiAocG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAvLyBUbyByZWR1Y2UgdGhlIGluaXRpYWwgbGFnIG1ha2UgaXQgd29yayB3aXRoIDMgcG9pbnRzXG4gICAgLy8gYnkgY29weWluZyB0aGUgZmlyc3QgcG9pbnQgdG8gdGhlIGJlZ2lubmluZy5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMykgcG9pbnRzLnVuc2hpZnQocG9pbnRzWzBdKTtcblxuICAgIHRtcCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdKTtcbiAgICB2YXIgYzIgPSB0bXAuYzI7XG4gICAgdG1wID0gdGhpcy5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzKHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgIHZhciBjMyA9IHRtcC5jMTtcbiAgICB2YXIgY3VydmUgPSBuZXcgQmV6aWVyKHBvaW50c1sxXSwgYzIsIGMzLCBwb2ludHNbMl0pO1xuICAgIHZhciB3aWR0aHMgPSB0aGlzLl9jYWxjdWxhdGVDdXJ2ZVdpZHRocyhjdXJ2ZSk7XG5cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSB0aGUgbGlzdCxcbiAgICAvLyBzbyB0aGF0IHdlIGFsd2F5cyBoYXZlIG5vIG1vcmUgdGhhbiA0IHBvaW50cyBpbiBwb2ludHMgYXJyYXkuXG4gICAgcG9pbnRzLnNoaWZ0KCk7XG5cbiAgICByZXR1cm4geyBjdXJ2ZTogY3VydmUsIHdpZHRoczogd2lkdGhzIH07XG4gIH1cblxuICByZXR1cm4ge307XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9jYWxjdWxhdGVDdXJ2ZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoczEsIHMyLCBzMykge1xuICB2YXIgZHgxID0gczEueCAtIHMyLng7XG4gIHZhciBkeTEgPSBzMS55IC0gczIueTtcbiAgdmFyIGR4MiA9IHMyLnggLSBzMy54O1xuICB2YXIgZHkyID0gczIueSAtIHMzLnk7XG5cbiAgdmFyIG0xID0geyB4OiAoczEueCArIHMyLngpIC8gMi4wLCB5OiAoczEueSArIHMyLnkpIC8gMi4wIH07XG4gIHZhciBtMiA9IHsgeDogKHMyLnggKyBzMy54KSAvIDIuMCwgeTogKHMyLnkgKyBzMy55KSAvIDIuMCB9O1xuXG4gIHZhciBsMSA9IE1hdGguc3FydChkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICB2YXIgbDIgPSBNYXRoLnNxcnQoZHgyICogZHgyICsgZHkyICogZHkyKTtcblxuICB2YXIgZHhtID0gbTEueCAtIG0yLng7XG4gIHZhciBkeW0gPSBtMS55IC0gbTIueTtcblxuICB2YXIgayA9IGwyIC8gKGwxICsgbDIpO1xuICB2YXIgY20gPSB7IHg6IG0yLnggKyBkeG0gKiBrLCB5OiBtMi55ICsgZHltICogayB9O1xuXG4gIHZhciB0eCA9IHMyLnggLSBjbS54O1xuICB2YXIgdHkgPSBzMi55IC0gY20ueTtcblxuICByZXR1cm4ge1xuICAgIGMxOiBuZXcgUG9pbnQobTEueCArIHR4LCBtMS55ICsgdHkpLFxuICAgIGMyOiBuZXcgUG9pbnQobTIueCArIHR4LCBtMi55ICsgdHkpXG4gIH07XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9jYWxjdWxhdGVDdXJ2ZVdpZHRocyA9IGZ1bmN0aW9uIChjdXJ2ZSkge1xuICB2YXIgc3RhcnRQb2ludCA9IGN1cnZlLnN0YXJ0UG9pbnQ7XG4gIHZhciBlbmRQb2ludCA9IGN1cnZlLmVuZFBvaW50O1xuICB2YXIgd2lkdGhzID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XG5cbiAgdmFyIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCAqIGVuZFBvaW50LnZlbG9jaXR5RnJvbShzdGFydFBvaW50KSArICgxIC0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCkgKiB0aGlzLl9sYXN0VmVsb2NpdHk7XG5cbiAgdmFyIG5ld1dpZHRoID0gdGhpcy5fc3Ryb2tlV2lkdGgodmVsb2NpdHkpO1xuXG4gIHdpZHRocy5zdGFydCA9IHRoaXMuX2xhc3RXaWR0aDtcbiAgd2lkdGhzLmVuZCA9IG5ld1dpZHRoO1xuXG4gIHRoaXMuX2xhc3RWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICB0aGlzLl9sYXN0V2lkdGggPSBuZXdXaWR0aDtcblxuICByZXR1cm4gd2lkdGhzO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlV2lkdGggPSBmdW5jdGlvbiAodmVsb2NpdHkpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWF4V2lkdGggLyAodmVsb2NpdHkgKyAxKSwgdGhpcy5taW5XaWR0aCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9kcmF3UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgc2l6ZSkge1xuICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gIGN0eC5tb3ZlVG8oeCwgeSk7XG4gIGN0eC5hcmMoeCwgeSwgc2l6ZSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgdGhpcy5faXNFbXB0eSA9IGZhbHNlO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fZHJhd0N1cnZlID0gZnVuY3Rpb24gKGN1cnZlLCBzdGFydFdpZHRoLCBlbmRXaWR0aCkge1xuICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICB2YXIgd2lkdGhEZWx0YSA9IGVuZFdpZHRoIC0gc3RhcnRXaWR0aDtcbiAgdmFyIGRyYXdTdGVwcyA9IE1hdGguZmxvb3IoY3VydmUubGVuZ3RoKCkpO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYXdTdGVwczsgaSArPSAxKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBCZXppZXIgKHgsIHkpIGNvb3JkaW5hdGUgZm9yIHRoaXMgc3RlcC5cbiAgICB2YXIgdCA9IGkgLyBkcmF3U3RlcHM7XG4gICAgdmFyIHR0ID0gdCAqIHQ7XG4gICAgdmFyIHR0dCA9IHR0ICogdDtcbiAgICB2YXIgdSA9IDEgLSB0O1xuICAgIHZhciB1dSA9IHUgKiB1O1xuICAgIHZhciB1dXUgPSB1dSAqIHU7XG5cbiAgICB2YXIgeCA9IHV1dSAqIGN1cnZlLnN0YXJ0UG9pbnQueDtcbiAgICB4ICs9IDMgKiB1dSAqIHQgKiBjdXJ2ZS5jb250cm9sMS54O1xuICAgIHggKz0gMyAqIHUgKiB0dCAqIGN1cnZlLmNvbnRyb2wyLng7XG4gICAgeCArPSB0dHQgKiBjdXJ2ZS5lbmRQb2ludC54O1xuXG4gICAgdmFyIHkgPSB1dXUgKiBjdXJ2ZS5zdGFydFBvaW50Lnk7XG4gICAgeSArPSAzICogdXUgKiB0ICogY3VydmUuY29udHJvbDEueTtcbiAgICB5ICs9IDMgKiB1ICogdHQgKiBjdXJ2ZS5jb250cm9sMi55O1xuICAgIHkgKz0gdHR0ICogY3VydmUuZW5kUG9pbnQueTtcblxuICAgIHZhciB3aWR0aCA9IHN0YXJ0V2lkdGggKyB0dHQgKiB3aWR0aERlbHRhO1xuICAgIHRoaXMuX2RyYXdQb2ludCh4LCB5LCB3aWR0aCk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5maWxsKCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9kcmF3RG90ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gIHZhciB3aWR0aCA9IHR5cGVvZiB0aGlzLmRvdFNpemUgPT09ICdmdW5jdGlvbicgPyB0aGlzLmRvdFNpemUoKSA6IHRoaXMuZG90U2l6ZTtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHRoaXMuX2RyYXdQb2ludChwb2ludC54LCBwb2ludC55LCB3aWR0aCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2Zyb21EYXRhID0gZnVuY3Rpb24gKHBvaW50R3JvdXBzLCBkcmF3Q3VydmUsIGRyYXdEb3QpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludEdyb3Vwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBncm91cCA9IHBvaW50R3JvdXBzW2ldO1xuXG4gICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIHJhd1BvaW50ID0gZ3JvdXBbal07XG4gICAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludChyYXdQb2ludC54LCByYXdQb2ludC55LCByYXdQb2ludC50aW1lKTtcblxuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIC8vIEZpcnN0IHBvaW50IGluIGEgZ3JvdXAuIE5vdGhpbmcgdG8gZHJhdyB5ZXQuXG4gICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgICB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiAhPT0gZ3JvdXAubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIE1pZGRsZSBwb2ludCBpbiBhIGdyb3VwLlxuICAgICAgICAgIHZhciBfYWRkUG9pbnQyID0gdGhpcy5fYWRkUG9pbnQocG9pbnQpLFxuICAgICAgICAgICAgICBjdXJ2ZSA9IF9hZGRQb2ludDIuY3VydmUsXG4gICAgICAgICAgICAgIHdpZHRocyA9IF9hZGRQb2ludDIud2lkdGhzO1xuXG4gICAgICAgICAgaWYgKGN1cnZlICYmIHdpZHRocykge1xuICAgICAgICAgICAgZHJhd0N1cnZlKGN1cnZlLCB3aWR0aHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMYXN0IHBvaW50IGluIGEgZ3JvdXAuIERvIG5vdGhpbmcuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIHZhciBfcmF3UG9pbnQgPSBncm91cFswXTtcbiAgICAgIGRyYXdEb3QoX3Jhd1BvaW50KTtcbiAgICB9XG4gIH1cbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3RvU1ZHID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICB2YXIgcG9pbnRHcm91cHMgPSB0aGlzLl9kYXRhO1xuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICB2YXIgcmF0aW8gPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAxKTtcbiAgdmFyIG1pblggPSAwO1xuICB2YXIgbWluWSA9IDA7XG4gIHZhciBtYXhYID0gY2FudmFzLndpZHRoIC8gcmF0aW87XG4gIHZhciBtYXhZID0gY2FudmFzLmhlaWdodCAvIHJhdGlvO1xuICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcblxuICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgY2FudmFzLndpZHRoKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCBjYW52YXMuaGVpZ2h0KTtcblxuICB0aGlzLl9mcm9tRGF0YShwb2ludEdyb3VwcywgZnVuY3Rpb24gKGN1cnZlLCB3aWR0aHMpIHtcbiAgICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnKTtcblxuICAgIC8vIE5lZWQgdG8gY2hlY2sgY3VydmUgZm9yIE5hTiB2YWx1ZXMsIHRoZXNlIHBvcCB1cCB3aGVuIGRyYXdpbmdcbiAgICAvLyBsaW5lcyBvbiB0aGUgY2FudmFzIHRoYXQgYXJlIG5vdCBjb250aW51b3VzLiBFLmcuIFNoYXJwIGNvcm5lcnNcbiAgICAvLyBvciBzdG9wcGluZyBtaWQtc3Ryb2tlIGFuZCB0aGFuIGNvbnRpbnVpbmcgd2l0aG91dCBsaWZ0aW5nIG1vdXNlLlxuICAgIGlmICghaXNOYU4oY3VydmUuY29udHJvbDEueCkgJiYgIWlzTmFOKGN1cnZlLmNvbnRyb2wxLnkpICYmICFpc05hTihjdXJ2ZS5jb250cm9sMi54KSAmJiAhaXNOYU4oY3VydmUuY29udHJvbDIueSkpIHtcbiAgICAgIHZhciBhdHRyID0gJ00gJyArIGN1cnZlLnN0YXJ0UG9pbnQueC50b0ZpeGVkKDMpICsgJywnICsgY3VydmUuc3RhcnRQb2ludC55LnRvRml4ZWQoMykgKyAnICcgKyAoJ0MgJyArIGN1cnZlLmNvbnRyb2wxLngudG9GaXhlZCgzKSArICcsJyArIGN1cnZlLmNvbnRyb2wxLnkudG9GaXhlZCgzKSArICcgJykgKyAoY3VydmUuY29udHJvbDIueC50b0ZpeGVkKDMpICsgJywnICsgY3VydmUuY29udHJvbDIueS50b0ZpeGVkKDMpICsgJyAnKSArIChjdXJ2ZS5lbmRQb2ludC54LnRvRml4ZWQoMykgKyAnLCcgKyBjdXJ2ZS5lbmRQb2ludC55LnRvRml4ZWQoMykpO1xuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIGF0dHIpO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICh3aWR0aHMuZW5kICogMi4yNSkudG9GaXhlZCgzKSk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgX3RoaXMyLnBlbkNvbG9yKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpO1xuXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAocmF3UG9pbnQpIHtcbiAgICB2YXIgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2lyY2xlJyk7XG4gICAgdmFyIGRvdFNpemUgPSB0eXBlb2YgX3RoaXMyLmRvdFNpemUgPT09ICdmdW5jdGlvbicgPyBfdGhpczIuZG90U2l6ZSgpIDogX3RoaXMyLmRvdFNpemU7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgncicsIGRvdFNpemUpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N4JywgcmF3UG9pbnQueCk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3knLCByYXdQb2ludC55KTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdmaWxsJywgX3RoaXMyLnBlbkNvbG9yKTtcblxuICAgIHN2Zy5hcHBlbmRDaGlsZChjaXJjbGUpO1xuICB9KTtcblxuICB2YXIgcHJlZml4ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJztcbiAgdmFyIGhlYWRlciA9ICc8c3ZnJyArICcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJyArICcgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCInICsgKCcgdmlld0JveD1cIicgKyBtaW5YICsgJyAnICsgbWluWSArICcgJyArIG1heFggKyAnICcgKyBtYXhZICsgJ1wiJykgKyAoJyB3aWR0aD1cIicgKyBtYXhYICsgJ1wiJykgKyAoJyBoZWlnaHQ9XCInICsgbWF4WSArICdcIicpICsgJz4nO1xuICB2YXIgYm9keSA9IHN2Zy5pbm5lckhUTUw7XG5cbiAgLy8gSUUgaGFjayBmb3IgbWlzc2luZyBpbm5lckhUTUwgcHJvcGVydHkgb24gU1ZHRWxlbWVudFxuICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZHVtbXknKTtcbiAgICB2YXIgbm9kZXMgPSBzdmcuY2hpbGROb2RlcztcbiAgICBkdW1teS5pbm5lckhUTUwgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGR1bW15LmFwcGVuZENoaWxkKG5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfVxuXG4gICAgYm9keSA9IGR1bW15LmlubmVySFRNTDtcbiAgfVxuXG4gIHZhciBmb290ZXIgPSAnPC9zdmc+JztcbiAgdmFyIGRhdGEgPSBoZWFkZXIgKyBib2R5ICsgZm9vdGVyO1xuXG4gIHJldHVybiBwcmVmaXggKyBidG9hKGRhdGEpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIChwb2ludEdyb3Vwcykge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICB0aGlzLmNsZWFyKCk7XG5cbiAgdGhpcy5fZnJvbURhdGEocG9pbnRHcm91cHMsIGZ1bmN0aW9uIChjdXJ2ZSwgd2lkdGhzKSB7XG4gICAgcmV0dXJuIF90aGlzMy5fZHJhd0N1cnZlKGN1cnZlLCB3aWR0aHMuc3RhcnQsIHdpZHRocy5lbmQpO1xuICB9LCBmdW5jdGlvbiAocmF3UG9pbnQpIHtcbiAgICByZXR1cm4gX3RoaXMzLl9kcmF3RG90KHJhd1BvaW50KTtcbiAgfSk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLnRvRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RhdGE7XG59O1xuXG5yZXR1cm4gU2lnbmF0dXJlUGFkO1xuXG59KSkpO1xuIiwiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF1cblxuICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVyYXRvclxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUrJywnK3ZhbHVlIDogdmFsdWVcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0J1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAgIHJhd0hlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICAgIHRoaXMuc3RhdHVzID0gJ3N0YXR1cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzIDogMjAwXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJ1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH1cblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH1cblxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzXG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3RcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlXG5cbiAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKVxuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICAgIH0pXG4gIH1cbiAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xuICAvKmpzaGludCBjYW1lbGNhc2U6IGZhbHNlICovXG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdhZGRyZXNzJywge1xuICAgICAgICB0aXRsZTogJ0FkZHJlc3MnLFxuICAgICAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgcmV0dXJuICRzY29wZS5jb21wb25lbnQubXVsdGlwbGUgPyAnZm9ybWlvL2NvbXBvbmVudHMvYWRkcmVzcy1tdWx0aXBsZS5odG1sJyA6ICdmb3JtaW8vY29tcG9uZW50cy9hZGRyZXNzLmh0bWwnO1xuICAgICAgICB9LFxuICAgICAgICBjb250cm9sbGVyOiBbJyRzY29wZScsICckaHR0cCcsIGZ1bmN0aW9uKCRzY29wZSwgJGh0dHApIHtcbiAgICAgICAgICBpZiAoJHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcbiAgICAgICAgICAkc2NvcGUuYWRkcmVzcyA9IHt9O1xuICAgICAgICAgICRzY29wZS5hZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgICAkc2NvcGUucmVmcmVzaEFkZHJlc3MgPSBmdW5jdGlvbihhZGRyZXNzKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgICBzZW5zb3I6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50Lm1hcCAmJiAkc2NvcGUuY29tcG9uZW50Lm1hcC5yZWdpb24pIHtcbiAgICAgICAgICAgICAgcGFyYW1zLnJlZ2lvbiA9ICRzY29wZS5jb21wb25lbnQubWFwLnJlZ2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50Lm1hcCAmJiAkc2NvcGUuY29tcG9uZW50Lm1hcC5rZXkpIHtcbiAgICAgICAgICAgICAgcGFyYW1zLmtleSA9ICRzY29wZS5jb21wb25lbnQubWFwLmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQoXG4gICAgICAgICAgICAgICdodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvZ2VvY29kZS9qc29uJyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpc2FibGVKV1Q6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgUHJhZ21hOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICRzY29wZS5hZGRyZXNzZXMgPSByZXNwb25zZS5kYXRhLnJlc3VsdHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XSxcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhLmZvcm1hdHRlZF9hZGRyZXNzIDogJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGlucHV0OiB0cnVlLFxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAga2V5OiAnYWRkcmVzc0ZpZWxkJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXG4gICAgICAgICAgdW5pcXVlOiBmYWxzZSxcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICByZWdpb246ICcnLFxuICAgICAgICAgICAga2V5OiAnJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9hZGRyZXNzLmh0bWwnLFxuICAgICAgICBcIjxsYWJlbCBuZy1pZj1cXFwiY29tcG9uZW50LmxhYmVsICYmICFjb21wb25lbnQuaGlkZUxhYmVsXFxcIiBmb3I9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIiBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGlzUmVxdWlyZWQoY29tcG9uZW50KX1cXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2xhYmVsPlxcbjxzcGFuIG5nLWlmPVxcXCIhY29tcG9uZW50LmxhYmVsICYmIGlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tYXN0ZXJpc2sgZm9ybS1jb250cm9sLWZlZWRiYWNrIGZpZWxkLXJlcXVpcmVkLWlubGluZVxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvc3Bhbj5cXG48dWktc2VsZWN0IG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIiBzYWZlLW11bHRpcGxlLXRvLXNpbmdsZSBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiIG5nLXJlcXVpcmVkPVxcXCJpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCIgdGhlbWU9XFxcImJvb3RzdHJhcFxcXCI+XFxuICA8dWktc2VsZWN0LW1hdGNoIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eyBjb21wb25lbnQucGxhY2Vob2xkZXIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19XFxcIj57eyRpdGVtLmZvcm1hdHRlZF9hZGRyZXNzIHx8ICRzZWxlY3Quc2VsZWN0ZWQuZm9ybWF0dGVkX2FkZHJlc3N9fTwvdWktc2VsZWN0LW1hdGNoPlxcbiAgPHVpLXNlbGVjdC1jaG9pY2VzIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlc1xcXCIgcmVwZWF0PVxcXCJhZGRyZXNzIGluIGFkZHJlc3Nlc1xcXCIgcmVmcmVzaD1cXFwicmVmcmVzaEFkZHJlc3MoJHNlbGVjdC5zZWFyY2gpXFxcIiByZWZyZXNoLWRlbGF5PVxcXCI1MDBcXFwiPlxcbiAgICA8ZGl2IG5nLWJpbmQtaHRtbD1cXFwiYWRkcmVzcy5mb3JtYXR0ZWRfYWRkcmVzcyB8IGhpZ2hsaWdodDogJHNlbGVjdC5zZWFyY2hcXFwiPjwvZGl2PlxcbiAgPC91aS1zZWxlY3QtY2hvaWNlcz5cXG48L3VpLXNlbGVjdD5cXG48Zm9ybWlvLWVycm9ycyBuZy1pZj1cXFwiOjohYnVpbGRlclxcXCI+PC9mb3JtaW8tZXJyb3JzPlxcblwiXG4gICAgICApO1xuXG4gICAgICAvLyBDaGFuZ2UgdGhlIHVpLXNlbGVjdCB0byB1aS1zZWxlY3QgbXVsdGlwbGUuXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2FkZHJlc3MtbXVsdGlwbGUuaHRtbCcsXG4gICAgICAgICR0ZW1wbGF0ZUNhY2hlLmdldCgnZm9ybWlvL2NvbXBvbmVudHMvYWRkcmVzcy5odG1sJykucmVwbGFjZSgnPHVpLXNlbGVjdCcsICc8dWktc2VsZWN0IG11bHRpcGxlJylcbiAgICAgICk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2J1dHRvbicsIHtcbiAgICAgICAgdGl0bGU6ICdCdXR0b24nLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2J1dHRvbi5odG1sJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDogJ1N1Ym1pdCcsXG4gICAgICAgICAgdGFibGVWaWV3OiBmYWxzZSxcbiAgICAgICAgICBrZXk6ICdzdWJtaXQnLFxuICAgICAgICAgIHNpemU6ICdtZCcsXG4gICAgICAgICAgbGVmdEljb246ICcnLFxuICAgICAgICAgIHJpZ2h0SWNvbjogJycsXG4gICAgICAgICAgYmxvY2s6IGZhbHNlLFxuICAgICAgICAgIGFjdGlvbjogJ3N1Ym1pdCcsXG4gICAgICAgICAgZGlzYWJsZU9uSW52YWxpZDogZmFsc2UsXG4gICAgICAgICAgdGhlbWU6ICdwcmltYXJ5J1xuICAgICAgICB9LFxuICAgICAgICBjb250cm9sbGVyOiBbJyRzY29wZScsIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xuICAgICAgICAgIHZhciBzZXR0aW5ncyA9ICRzY29wZS5jb21wb25lbnQ7XG4gICAgICAgICAgJHNjb3BlLmdldEJ1dHRvblR5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuYWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdzdWJtaXQnO1xuICAgICAgICAgICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZXNldCc7XG4gICAgICAgICAgICAgIGNhc2UgJ2V2ZW50JzpcbiAgICAgICAgICAgICAgY2FzZSAnb2F1dGgnOlxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnYnV0dG9uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuYWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBjYXNlICdldmVudCc6XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCRzY29wZS5jb21wb25lbnQuZXZlbnQsICRzY29wZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAncmVzZXQnOlxuICAgICAgICAgICAgICAgICRzY29wZS5yZXNldEZvcm0oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnb2F1dGgnOlxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub2F1dGgpIHtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdZb3UgbXVzdCBhc3NpZ24gdGhpcyBidXR0b24gdG8gYW4gT0F1dGggYWN0aW9uIGJlZm9yZSBpdCB3aWxsIHdvcmsuJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9hdXRoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuc2hvd0FsZXJ0cyh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzZXR0aW5ncy5vYXV0aC5lcnJvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLm9wZW5PQXV0aChzZXR0aW5ncy5vYXV0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgICRzY29wZS4kb24oJ2J1dHRvbkNsaWNrJywgZnVuY3Rpb24oZXZlbnQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY29tcG9uZW50SWQncyBtYXRjaCAoZXZlbiB0aG91Z2ggdGhleSBhbHdheXMgc2hvdWxkKS5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnRJZCAhPT0gJHNjb3BlLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ2xpY2soKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgICRzY29wZS5vcGVuT0F1dGggPSBmdW5jdGlvbihzZXR0aW5ncykge1xuICAgICAgICAgICAgLyplc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlX3R5cGU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgY2xpZW50X2lkOiBzZXR0aW5ncy5jbGllbnRJZCxcbiAgICAgICAgICAgICAgcmVkaXJlY3RfdXJpOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luIHx8IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW5kb3cubG9jYXRpb24uaG9zdCxcbiAgICAgICAgICAgICAgc3RhdGU6IHNldHRpbmdzLnN0YXRlLFxuICAgICAgICAgICAgICBzY29wZTogc2V0dGluZ3Muc2NvcGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKmVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5cbiAgICAgICAgICAgIC8vIE1ha2UgZGlzcGxheSBvcHRpb25hbC5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kaXNwbGF5KSB7XG4gICAgICAgICAgICAgIHBhcmFtcy5kaXNwbGF5ID0gc2V0dGluZ3MuZGlzcGxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmFtcykubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4ga2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKTtcbiAgICAgICAgICAgIH0pLmpvaW4oJyYnKTtcblxuICAgICAgICAgICAgdmFyIHVybCA9IHNldHRpbmdzLmF1dGhVUkkgKyAnPycgKyBwYXJhbXM7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2Ugd2luZG93IG9wdGlvbnMgZnJvbSBvYXV0aCBzZXR0aW5ncywgaGF2ZSBiZXR0ZXIgZGVmYXVsdHNcbiAgICAgICAgICAgIHZhciBwb3B1cCA9IHdpbmRvdy5vcGVuKHVybCwgc2V0dGluZ3MucHJvdmlkZXIsICd3aWR0aD0xMDIwLGhlaWdodD02MTgnKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBwb3B1cEhvc3QgPSBwb3B1cC5sb2NhdGlvbi5ob3N0O1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgICAgICAgICAgICAgIGlmIChwb3B1cCAmJiAhcG9wdXAuY2xvc2VkICYmIHBvcHVwSG9zdCA9PT0gY3VycmVudEhvc3QgJiYgcG9wdXAubG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICBwb3B1cC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHBvcHVwLmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24ocGFyYW1zLCBwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBwYXJhbS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbc3BsaXRbMF1dID0gc3BsaXRbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGFuZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcGFyYW1zLmVycm9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBjaGVjayBmb3IgZXJyb3IgcmVzcG9uc2UgaGVyZVxuICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0YXRlICE9PSBwYXJhbXMuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dBbGVydHMoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdPQXV0aCBzdGF0ZSBkb2VzIG5vdCBtYXRjaC4gUGxlYXNlIHRyeSBsb2dnaW5nIGluIGFnYWluLidcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBzdWJtaXNzaW9uID0ge2RhdGE6IHt9LCBvYXV0aDoge319O1xuICAgICAgICAgICAgICAgICAgc3VibWlzc2lvbi5vYXV0aFtzZXR0aW5ncy5wcm92aWRlcl0gPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uLm9hdXRoW3NldHRpbmdzLnByb3ZpZGVyXS5yZWRpcmVjdFVSSSA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHwgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1pb0Zvcm0uc3VibWl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZm9ybWlvLnNhdmVTdWJtaXNzaW9uKHN1Ym1pc3Npb24pXG4gICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihzdWJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtU3VibWlzc2lvbicsIHN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2hvd0FsZXJ0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1pb0Zvcm0uc3VibWl0dGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lICE9PSAnU2VjdXJpdHlFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXBvcHVwIHx8IHBvcHVwLmNsb3NlZCB8fCBwb3B1cC5jbG9zZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1dLFxuICAgICAgICB2aWV3VGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50c1ZpZXcvYnV0dG9uLmh0bWwnXG4gICAgICB9KTtcbiAgICB9XG4gIF0pO1xuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2J1dHRvbi5odG1sJyxcbiAgICAgICAgXCI8YnV0dG9uIG5nLWF0dHItdHlwZT1cXFwie3sgZ2V0QnV0dG9uVHlwZSgpIH19XFxcIlxcbiAgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcbiAgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxuICBuZy1jbGFzcz1cXFwieydidG4tYmxvY2snOiBjb21wb25lbnQuYmxvY2t9XFxcIlxcbiAgY2xhc3M9XFxcImJ0biBidG4te3sgY29tcG9uZW50LnRoZW1lIH19IGJ0bi17eyBjb21wb25lbnQuc2l6ZSB9fVxcXCJcXG4gIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seSB8fCBmb3JtaW9Gb3JtLnN1Ym1pdHRpbmcgfHwgKGNvbXBvbmVudC5kaXNhYmxlT25JbnZhbGlkICYmIGZvcm1pb0Zvcm0uJGludmFsaWQpXFxcIlxcbiAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcbiAgbmctY2xpY2s9XFxcIiRlbWl0KCdidXR0b25DbGljaycsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpXFxcIj5cXG4gIDxzcGFuIG5nLWlmPVxcXCJjb21wb25lbnQubGVmdEljb25cXFwiIGNsYXNzPVxcXCJ7eyBjb21wb25lbnQubGVmdEljb24gfX1cXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L3NwYW4+XFxuICA8c3BhbiBuZy1pZj1cXFwiY29tcG9uZW50LmxlZnRJY29uICYmIGNvbXBvbmVudC5sYWJlbFxcXCI+Jm5ic3A7PC9zcGFuPnt7IGNvbXBvbmVudC5sYWJlbCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08c3BhbiBuZy1pZj1cXFwiY29tcG9uZW50LnJpZ2h0SWNvbiAmJiBjb21wb25lbnQubGFiZWxcXFwiPiZuYnNwOzwvc3Bhbj5cXG4gIDxzcGFuIG5nLWlmPVxcXCJjb21wb25lbnQucmlnaHRJY29uXFxcIiBjbGFzcz1cXFwie3sgY29tcG9uZW50LnJpZ2h0SWNvbiB9fVxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvc3Bhbj5cXG4gICA8aSBuZy1pZj1cXFwiY29tcG9uZW50LmFjdGlvbiA9PSAnc3VibWl0JyAmJiBmb3JtaW9Gb3JtLnN1Ym1pdHRpbmdcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXJlZnJlc2ggZ2x5cGhpY29uLXNwaW5cXFwiPjwvaT5cXG48L2J1dHRvbj5cXG5cIlxuICAgICAgKTtcblxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50c1ZpZXcvYnV0dG9uLmh0bWwnLFxuICAgICAgICBcIlwiXG4gICAgICApO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdjaGVja2JveCcsIHtcbiAgICAgICAgdGl0bGU6ICdDaGVjayBCb3gnLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NoZWNrYm94Lmh0bWwnLFxuICAgICAgICB0YWJsZVZpZXc6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YSA/ICdZZXMnIDogJ05vJztcbiAgICAgICAgfSxcbiAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbigkc2NvcGUsICR0aW1lb3V0KSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgICAgdmFyIGJvb2xlYW4gPSB7XG4gICAgICAgICAgICB0cnVlOiB0cnVlLFxuICAgICAgICAgICAgZmFsc2U6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gJHNjb3BlLmNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJylcbiAgICAgICAgICAgID8gYm9vbGVhblskc2NvcGUuY29tcG9uZW50LmRlZmF1bHRWYWx1ZV0gfHwgZmFsc2VcbiAgICAgICAgICAgIDogZmFsc2U7XG5cbiAgICAgICAgICAvLyBGT1ItNDQwIC0gT25seSB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgaWYgdGhlIGRhdGEgaXNuJ3QgZGVmaW5lZC5cbiAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgbG9hZCwgYXR0ZW1wdCB0byBzZXQgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gJHNjb3BlLmRhdGEuaGFzT3duUHJvcGVydHkoJHNjb3BlLmNvbXBvbmVudC5rZXkpICYmIGJvb2xlYW4uaGFzT3duUHJvcGVydHkoJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldKVxuICAgICAgICAgICAgPyBib29sZWFuWyRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XV1cbiAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgLy8gRkEtODUwIC0gRW5zdXJlIHRoZSBjaGVja2VkIHZhbHVlIGlzIGFsd2F5cyBhIGJvb2xlYW4gb2JqZWN0IHdoZW4gbG9hZGVkLCB0aGVuIHVuYmluZCB0aGUgd2F0Y2guXG4gICAgICAgICAgaWYgKCRzY29wZS5jb21wb25lbnQuaW5wdXRUeXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdkYXRhLicgKyAkc2NvcGUuY29tcG9uZW50LmtleSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICghJHNjb3BlLmRhdGEgfHwgISRzY29wZS5jb21wb25lbnQua2V5KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbXBvbmVudCBpcyByZXF1aXJlZCwgYW5kIGl0cyBjdXJyZW50IHZhbHVlIGlzIGZhbHNlLCBkZWxldGUgdGhlIGVudHJ5LlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZVxuICAgICAgICAgICAgICAgICYmICRzY29wZS5jb21wb25lbnQudmFsaWRhdGUucmVxdWlyZWRcbiAgICAgICAgICAgICAgICAmJiAoYm9vbGVhblskc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV1dIHx8IGZhbHNlKSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGlucHV0OiB0cnVlLFxuICAgICAgICAgIGlucHV0VHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXG4gICAgICAgICAgLy8gVGhpcyBoaWRlcyB0aGUgZGVmYXVsdCBsYWJlbCBsYXlvdXQgc28gd2UgY2FuIHVzZSBhIHNwZWNpYWwgaW5saW5lIGxhYmVsXG4gICAgICAgICAgaGlkZUxhYmVsOiB0cnVlLFxuICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICBkYXRhZ3JpZExhYmVsOiB0cnVlLFxuICAgICAgICAgIGtleTogJ2NoZWNrYm94RmllbGQnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxuICAgICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgXSk7XG4gIGFwcC5ydW4oW1xuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvY2hlY2tib3guaHRtbCcsXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwiY2hlY2tib3hcXFwiPlxcbiAgPGxhYmVsIGZvcj1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+XFxuICAgIDxpbnB1dFxcbiAgICAgIG5nLWlmPVxcXCJjb21wb25lbnQubmFtZVxcXCJcXG4gICAgICB0eXBlPVxcXCJ7eyBjb21wb25lbnQuaW5wdXRUeXBlIH19XFxcIlxcbiAgICAgIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXG4gICAgICBuYW1lPVxcXCJ7eyBjb21wb25lbnQubmFtZSB9fVxcXCJcXG4gICAgICB2YWx1ZT1cXFwie3sgY29tcG9uZW50LnZhbHVlIH19XFxcIlxcbiAgICAgIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXG4gICAgICBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiXFxuICAgICAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50Lm5hbWVdXFxcIlxcbiAgICAgIG5nLXJlcXVpcmVkPVxcXCJjb21wb25lbnQudmFsaWRhdGUucmVxdWlyZWRcXFwiXFxuICAgID5cXG4gICAgPGlucHV0XFxuICAgICAgbmctaWY9XFxcIiFjb21wb25lbnQubmFtZVxcXCJcXG4gICAgICB0eXBlPVxcXCJ7eyBjb21wb25lbnQuaW5wdXRUeXBlIH19XFxcIlxcbiAgICAgIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXG4gICAgICB0YWJpbmRleD1cXFwie3sgY29tcG9uZW50LnRhYmluZGV4IHx8IDAgfX1cXFwiXFxuICAgICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcbiAgICAgIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIlxcbiAgICAgIG5nLXJlcXVpcmVkPVxcXCJpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiXFxuICAgICAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXG4gICAgPlxcbiAgICA8c3BhbiBuZy1pZj1cXFwiIShjb21wb25lbnQuaGlkZUxhYmVsICYmIGNvbXBvbmVudC5kYXRhZ3JpZExhYmVsID09PSBmYWxzZSlcXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L3NwYW4+XFxuICA8L2xhYmVsPlxcbjwvZGl2PlxcbjxkaXYgbmctaWY9XFxcIiEhY29tcG9uZW50LmRlc2NyaXB0aW9uXFxcIiBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCI+XFxuICA8c3Bhbj57eyBjb21wb25lbnQuZGVzY3JpcHRpb24gfX08L3NwYW4+XFxuPC9kaXY+XFxuXCJcbiAgICAgICk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2NvbHVtbnMnLCB7XG4gICAgICAgIHRpdGxlOiAnQ29sdW1ucycsXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29sdW1ucy5odG1sJyxcbiAgICAgICAgZ3JvdXA6ICdsYXlvdXQnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGlucHV0OiBmYWxzZSxcbiAgICAgICAgICBrZXk6ICdjb2x1bW5zJyxcbiAgICAgICAgICBjb2x1bW5zOiBbe2NvbXBvbmVudHM6IFtdfSwge2NvbXBvbmVudHM6IFtdfV1cbiAgICAgICAgfSxcbiAgICAgICAgdmlld1RlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHNWaWV3L2NvbHVtbnMuaHRtbCdcbiAgICAgIH0pO1xuICAgIH1cbiAgXSk7XG4gIGFwcC5ydW4oW1xuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvY29sdW1ucy5odG1sJyxcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTZcXFwiIG5nLXJlcGVhdD1cXFwiY29sdW1uIGluIGNvbXBvbmVudC5jb2x1bW5zIHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxuICAgIDxmb3JtaW8tY29tcG9uZW50XFxuICAgICAgbmctcmVwZWF0PVxcXCJfY29tcG9uZW50IGluIGNvbHVtbi5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCJcXG4gICAgICBjb21wb25lbnQ9XFxcIl9jb21wb25lbnRcXFwiXFxuICAgICAgZGF0YT1cXFwiZGF0YVxcXCJcXG4gICAgICBmb3JtaW89XFxcImZvcm1pb1xcXCJcXG4gICAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcbiAgICAgIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiXFxuICAgICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShfY29tcG9uZW50LCBkYXRhKVxcXCJcXG4gICAgICBmb3JtaW8tZm9ybT1cXFwiZm9ybWlvRm9ybVxcXCJcXG4gICAgICByZWFkLW9ubHk9XFxcImlzRGlzYWJsZWQoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxuICAgICAgZ3JpZC1yb3c9XFxcImdyaWRSb3dcXFwiXFxuICAgICAgZ3JpZC1jb2w9XFxcImdyaWRDb2xcXFwiXFxuICAgICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXG4gICAgPjwvZm9ybWlvLWNvbXBvbmVudD5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiXG4gICAgICApO1xuXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzVmlldy9jb2x1bW5zLmh0bWwnLFxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNlxcXCIgbmctcmVwZWF0PVxcXCJjb2x1bW4gaW4gY29tcG9uZW50LmNvbHVtbnMgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG4gICAgPGZvcm1pby1jb21wb25lbnQtdmlld1xcbiAgICAgIG5nLXJlcGVhdD1cXFwiX2NvbXBvbmVudCBpbiBjb2x1bW4uY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiXFxuICAgICAgY29tcG9uZW50PVxcXCJfY29tcG9uZW50XFxcIlxcbiAgICAgIGRhdGE9XFxcImRhdGFcXFwiXFxuICAgICAgZm9ybT1cXFwiZm9ybVxcXCJcXG4gICAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcbiAgICAgIGlnbm9yZT1cXFwiaWdub3JlXFxcIlxcbiAgICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxuICAgICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXG4gICAgPjwvZm9ybWlvLWNvbXBvbmVudC12aWV3PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCJcbiAgICAgICk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5wcm92aWRlcignZm9ybWlvQ29tcG9uZW50cycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb21wb25lbnRzID0ge307XG4gICAgdmFyIGdyb3VwcyA9IHtcbiAgICAgIF9fY29tcG9uZW50OiB7XG4gICAgICAgIHRpdGxlOiAnQmFzaWMgQ29tcG9uZW50cydcbiAgICAgIH0sXG4gICAgICBhZHZhbmNlZDoge1xuICAgICAgICB0aXRsZTogJ1NwZWNpYWwgQ29tcG9uZW50cydcbiAgICAgIH0sXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgdGl0bGU6ICdMYXlvdXQgQ29tcG9uZW50cydcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBhZGRHcm91cDogZnVuY3Rpb24obmFtZSwgZ3JvdXApIHtcbiAgICAgICAgZ3JvdXBzW25hbWVdID0gZ3JvdXA7XG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHR5cGUsIGNvbXBvbmVudCwgZ3JvdXApIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnRzW3R5cGVdKSB7XG4gICAgICAgICAgY29tcG9uZW50c1t0eXBlXSA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhbmd1bGFyLmV4dGVuZChjb21wb25lbnRzW3R5cGVdLCBjb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSB0eXBlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgaWYgKCFjb21wb25lbnRzW3R5cGVdLmdyb3VwKSB7XG4gICAgICAgICAgY29tcG9uZW50c1t0eXBlXS5ncm91cCA9IGdyb3VwIHx8ICdfX2NvbXBvbmVudCc7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50c1t0eXBlXS5zZXR0aW5ncy50eXBlID0gdHlwZTtcbiAgICAgIH0sXG4gICAgICAkZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgICAgIGdyb3VwczogZ3JvdXBzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgYXBwLmRpcmVjdGl2ZSgnc2FmZU11bHRpcGxlVG9TaW5nbGUnLCBbZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsIGVsLCBhdHRycywgbmdNb2RlbCkge1xuICAgICAgICBuZ01vZGVsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24obW9kZWxWYWx1ZSkge1xuICAgICAgICAgIGlmICghJHNjb3BlLmNvbXBvbmVudC5tdWx0aXBsZSAmJiBBcnJheS5pc0FycmF5KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxWYWx1ZVswXSB8fCAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbW9kZWxWYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdjb250YWluZXInLCB7XG4gICAgICAgIHRpdGxlOiAnQ29udGFpbmVyJyxcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb250YWluZXIuaHRtbCcsXG4gICAgICAgIHZpZXdUZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzVmlldy9jb250YWluZXIuaHRtbCcsXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxuICAgICAgICBpY29uOiAnZmEgZmEtZm9sZGVyLW9wZW4nLFxuICAgICAgICB0YWJsZVZpZXc6IGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCwgJGludGVycG9sYXRlLCBjb21wb25lbnRJbmZvKSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSAnPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZFwiPjx0aGVhZD48dHI+JztcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29tcG9uZW50LmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmlldyArPSAnPHRoPicgKyBjb21wb25lbnQubGFiZWwgKyAnPC90aD4nO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZpZXcgKz0gJzwvdHI+PC90aGVhZD4nO1xuICAgICAgICAgIHZpZXcgKz0gJzx0Ym9keT4nO1xuICAgICAgICAgIHZpZXcgKz0gJzx0cj4nO1xuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wb25lbnQuY29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGNvbXBvbmVudEluZm8uY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnQudHlwZSkgPyBjb21wb25lbnRJbmZvLmNvbXBvbmVudHNbY29tcG9uZW50LnR5cGVdIDoge307XG4gICAgICAgICAgICBpZiAoaW5mby50YWJsZVZpZXcpIHtcbiAgICAgICAgICAgICAgdmlldyArPSAnPHRkPicgK1xuICAgICAgICAgICAgICAgIGluZm8udGFibGVWaWV3KFxuICAgICAgICAgICAgICAgICAgZGF0YSAmJiBjb21wb25lbnQua2V5ICYmIGRhdGEuaGFzT3duUHJvcGVydHkoY29tcG9uZW50LmtleSkgPyBkYXRhW2NvbXBvbmVudC5rZXldIDogJycsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAkaW50ZXJwb2xhdGUsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRJbmZvXG4gICAgICAgICAgICAgICAgKSArICc8L3RkPic7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlldyArPSAnPHRkPic7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnByZWZpeCkge1xuICAgICAgICAgICAgICB2aWV3ICs9IGNvbXBvbmVudC5wcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3ICs9IGRhdGEgJiYgY29tcG9uZW50LmtleSAmJiBkYXRhLmhhc093blByb3BlcnR5KGNvbXBvbmVudC5rZXkpID8gZGF0YVtjb21wb25lbnQua2V5XSA6ICcnO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5zdWZmaXgpIHtcbiAgICAgICAgICAgICAgdmlldyArPSAnICcgKyBjb21wb25lbnQuc3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldyArPSAnPC90ZD4nO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZpZXcgKz0gJzwvdHI+JztcbiAgICAgICAgICB2aWV3ICs9ICc8L3Rib2R5PjwvdGFibGU+JztcbiAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcbiAgICAgICAgICB0cmVlOiB0cnVlLFxuICAgICAgICAgIGNvbXBvbmVudHM6IFtdLFxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAga2V5OiAnY29udGFpbmVyJyxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLmNvbnRyb2xsZXIoJ2Zvcm1pb0NvbnRhaW5lckNvbXBvbmVudCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSB8fCB7fTtcbiAgICAgICRzY29wZS5wYXJlbnRLZXkgPSAkc2NvcGUuY29tcG9uZW50LmtleTtcbiAgICB9XG4gIF0pO1xuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgICdGb3JtaW9VdGlscycsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUsIEZvcm1pb1V0aWxzKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2NvbnRhaW5lci5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxuICAgICAgICBcIjxkaXYgbmctY29udHJvbGxlcj1cXFwiZm9ybWlvQ29udGFpbmVyQ29tcG9uZW50XFxcIiBjbGFzcz1cXFwiZm9ybWlvLWNvbnRhaW5lci1jb21wb25lbnRcXFwiPlxcbiAgPGZvcm1pby1jb21wb25lbnRcXG4gICAgbmctcmVwZWF0PVxcXCJfY29tcG9uZW50IGluIGNvbXBvbmVudC5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCJcXG4gICAgY29tcG9uZW50PVxcXCJfY29tcG9uZW50XFxcIlxcbiAgICBkYXRhPVxcXCJkYXRhW3BhcmVudEtleV1cXFwiXFxuICAgIGZvcm1pbz1cXFwiZm9ybWlvXFxcIlxcbiAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcbiAgICBoaWRlLWNvbXBvbmVudHM9XFxcImhpZGVDb21wb25lbnRzXFxcIlxcbiAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogaXNWaXNpYmxlKF9jb21wb25lbnQsIGRhdGFbcGFyZW50S2V5XSlcXFwiXFxuICAgIGZvcm1pby1mb3JtPVxcXCJmb3JtaW9Gb3JtXFxcIlxcbiAgICByZWFkLW9ubHk9XFxcImlzRGlzYWJsZWQoX2NvbXBvbmVudCwgZGF0YVtwYXJlbnRLZXldKVxcXCJcXG4gICAgZ3JpZC1yb3c9XFxcImdyaWRSb3dcXFwiXFxuICAgIGdyaWQtY29sPVxcXCJncmlkQ29sXFxcIlxcbiAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcbiAgPjwvZm9ybWlvLWNvbXBvbmVudD5cXG48L2Rpdj5cXG5cIlxuICAgICAgKSk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2NvbnRlbnQnLCB7XG4gICAgICAgIHRpdGxlOiAnQ29udGVudCcsXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29udGVudC5odG1sJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBrZXk6ICdjb250ZW50JyxcbiAgICAgICAgICBpbnB1dDogZmFsc2UsXG4gICAgICAgICAgaHRtbDogJydcbiAgICAgICAgfSxcbiAgICAgICAgdmlld1RlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29udGVudC5odG1sJ1xuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9jb250ZW50Lmh0bWwnLFxuICAgICAgICBcIjxkaXYgbmctYmluZC1odG1sPVxcXCJjb21wb25lbnQuaHRtbCB8IHNhZmVodG1sIHwgZm9ybWlvVHJhbnNsYXRlOmNvbXBvbmVudC5rZXk6YnVpbGRlclxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPjwvZGl2PlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmRpcmVjdGl2ZSgnY3VycmVuY3lJbnB1dCcsIGZ1bmN0aW9uKCkge1xuICAgIC8vIE1heSBiZSBiZXR0ZXIgd2F5IHRoYW4gYWRkaW5nIHRvIHByb3RvdHlwZS5cbiAgICB2YXIgc3BsaWNlID0gZnVuY3Rpb24oc3RyaW5nLCBpZHgsIHJlbSwgcykge1xuICAgICAgcmV0dXJuIChzdHJpbmcuc2xpY2UoMCwgaWR4KSArIHMgKyBzdHJpbmcuc2xpY2UoaWR4ICsgTWF0aC5hYnMocmVtKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xuICAgICAgICBpZiAoc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xuICAgICAgICBlbGVtZW50LmJpbmQoJ2tleXVwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBzY29wZS5kYXRhW3Njb3BlLmNvbXBvbmVudC5rZXldO1xuXG4gICAgICAgICAgLy9jbGVhcmluZyBsZWZ0IHNpZGUgemVyb3NcbiAgICAgICAgICB3aGlsZSAoZGF0YS5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3Vic3RyKDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoL1teXFxkLlxcJywnXS9nLCAnJyk7XG5cbiAgICAgICAgICB2YXIgcG9pbnQgPSBkYXRhLmluZGV4T2YoJy4nKTtcbiAgICAgICAgICBpZiAocG9pbnQgPj0gMCkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgcG9pbnQgKyAzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGVjaW1hbFNwbGl0ID0gZGF0YS5zcGxpdCgnLicpO1xuICAgICAgICAgIHZhciBpbnRQYXJ0ID0gZGVjaW1hbFNwbGl0WzBdO1xuICAgICAgICAgIHZhciBkZWNQYXJ0ID0gZGVjaW1hbFNwbGl0WzFdO1xuXG4gICAgICAgICAgaW50UGFydCA9IGludFBhcnQucmVwbGFjZSgvW15cXGRdL2csICcnKTtcbiAgICAgICAgICBpZiAoaW50UGFydC5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICB2YXIgaW50RGl2ID0gTWF0aC5mbG9vcihpbnRQYXJ0Lmxlbmd0aCAvIDMpO1xuICAgICAgICAgICAgd2hpbGUgKGludERpdiA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGxhc3RDb21tYSA9IGludFBhcnQuaW5kZXhPZignLCcpO1xuICAgICAgICAgICAgICBpZiAobGFzdENvbW1hIDwgMCkge1xuICAgICAgICAgICAgICAgIGxhc3RDb21tYSA9IGludFBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGxhc3RDb21tYSAtIDMgPiAwKSB7XG4gICAgICAgICAgICAgICAgaW50UGFydCA9IHNwbGljZShpbnRQYXJ0LCBsYXN0Q29tbWEgLSAzLCAwLCAnLCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGludERpdi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkZWNQYXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlY1BhcnQgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWNQYXJ0ID0gJy4nICsgZGVjUGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlcyA9IGludFBhcnQgKyBkZWNQYXJ0O1xuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjb3BlLmRhdGFbc2NvcGUuY29tcG9uZW50LmtleV0gPSByZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBhcHAuY29uZmlnKFtcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignY3VycmVuY3knLCB7XG4gICAgICAgIHRpdGxlOiAnQ3VycmVuY3knLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2N1cnJlbmN5Lmh0bWwnLFxuICAgICAgICBncm91cDogJ2FkdmFuY2VkJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXG4gICAgICAgICAgaW5wdXRUeXBlOiAndGV4dCcsXG4gICAgICAgICAgaW5wdXRNYXNrOiAnJyxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAga2V5OiAnY3VycmVuY3lGaWVsZCcsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgICAgICAgIHByZWZpeDogJycsXG4gICAgICAgICAgc3VmZml4OiAnJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcnLFxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcbiAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxuICAgICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICBtdWx0aXBsZTogJycsXG4gICAgICAgICAgICBjdXN0b206ICcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25kaXRpb25hbDoge1xuICAgICAgICAgICAgc2hvdzogbnVsbCxcbiAgICAgICAgICAgIHdoZW46IG51bGwsXG4gICAgICAgICAgICBlcTogJydcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgXSk7XG5cbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICAnRm9ybWlvVXRpbHMnLFxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlLCBGb3JtaW9VdGlscykge1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9jdXJyZW5jeS5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxuICAgICAgICBcIjxpbnB1dFxcbiAgdHlwZT1cXFwie3sgY29tcG9uZW50LmlucHV0VHlwZSB9fVxcXCJcXG4gIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxuICBpZD1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxuICBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXG4gIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXG4gIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIlxcbiAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXG4gIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXG4gIHNhZmUtbXVsdGlwbGUtdG8tc2luZ2xlXFxuICBuZy1hdHRyLXBsYWNlaG9sZGVyPVxcXCJ7eyBjb21wb25lbnQucGxhY2Vob2xkZXIgfX1cXFwiXFxuICBjdXN0b20tdmFsaWRhdG9yPVxcXCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXFxcIlxcbiAgY3VycmVuY3ktaW5wdXRcXG4gIHVpLW1hc2stcGxhY2Vob2xkZXI9XFxcIlxcXCJcXG4gIHVpLW9wdGlvbnM9XFxcInVpTWFza09wdGlvbnNcXFwiXFxuPlxcblwiXG4gICAgICApKTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgR3JpZFV0aWxzID0gcmVxdWlyZSgnLi4vZmFjdG9yaWVzL0dyaWRVdGlscycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdjdXN0b20nLCB7XG4gICAgICAgIHRpdGxlOiAnQ3VzdG9tJyxcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jdXN0b20uaHRtbCcsXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxuICAgICAgICBzZXR0aW5nczoge30sXG4gICAgICAgIHRhYmxlVmlldzogR3JpZFV0aWxzLmdlbmVyaWNcbiAgICAgIH0pO1xuICAgIH1cbiAgXSk7XG4gIGFwcC5ydW4oW1xuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvY3VzdG9tLmh0bWwnLFxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWRlZmF1bHRcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keSB0ZXh0LW11dGVkIHRleHQtY2VudGVyXFxcIj5cXG4gICAgQ3VzdG9tIENvbXBvbmVudCAoe3sgY29tcG9uZW50LnR5cGUgfX0pXFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIlxuICAgICAgKTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xuICBhcHAuY29uZmlnKFtcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignZGF0YWdyaWQnLCB7XG4gICAgICAgIHRpdGxlOiAnRGF0YSBHcmlkJyxcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9kYXRhZ3JpZC5odG1sJyxcbiAgICAgICAgZ3JvdXA6ICdhZHZhbmNlZCcsXG4gICAgICAgIHRhYmxlVmlldzogZnVuY3Rpb24oZGF0YSwgY29tcG9uZW50LCAkaW50ZXJwb2xhdGUsIGNvbXBvbmVudEluZm8pIHtcbiAgICAgICAgICB2YXIgdmlldyA9ICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkXCI+PHRoZWFkPjx0cj4nO1xuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wb25lbnQuY29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2aWV3ICs9ICc8dGg+JyArIGNvbXBvbmVudC5sYWJlbCArICc8L3RoPic7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmlldyArPSAnPC90cj48L3RoZWFkPic7XG4gICAgICAgICAgdmlldyArPSAnPHRib2R5Pic7XG4gICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRhdGEsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgdmlldyArPSAnPHRyPic7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29tcG9uZW50LmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICB2YXIgaW5mbyA9IGNvbXBvbmVudEluZm8uY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnQudHlwZSkgPyBjb21wb25lbnRJbmZvLmNvbXBvbmVudHNbY29tcG9uZW50LnR5cGVdIDoge307XG4gICAgICAgICAgICAgIGlmIChpbmZvLnRhYmxlVmlldykge1xuICAgICAgICAgICAgICAgIHZpZXcgKz0gJzx0ZD4nICsgaW5mby50YWJsZVZpZXcocm93W2NvbXBvbmVudC5rZXldIHx8ICcnLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSwgY29tcG9uZW50SW5mbykgKyAnPC90ZD4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpZXcgKz0gJzx0ZD4nO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICB2aWV3ICs9IGNvbXBvbmVudC5wcmVmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXcgKz0gcm93W2NvbXBvbmVudC5rZXldIHx8ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICB2aWV3ICs9ICcgJyArIGNvbXBvbmVudC5zdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXcgKz0gJzwvdGQ+JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2aWV3ICs9ICc8L3RyPic7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmlldyArPSAnPC90Ym9keT48L3RhYmxlPic7XG4gICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgaW5wdXQ6IHRydWUsXG4gICAgICAgICAgdHJlZTogdHJ1ZSxcbiAgICAgICAgICBjb21wb25lbnRzOiBbXSxcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXG4gICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgIGtleTogJ2RhdGFncmlkJyxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIF0pO1xuICBhcHAuY29udHJvbGxlcignZm9ybWlvRGF0YUdyaWQnLCBbXG4gICAgJyRzY29wZScsXG4gICAgJ0Zvcm1pb1V0aWxzJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsIEZvcm1pb1V0aWxzKSB7XG4gICAgICBpZiAoJHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcbiAgICAgIC8vIEVuc3VyZSBlYWNoIGRhdGEgZ3JpZCBoYXMgYSB2YWxpZCBkYXRhIG1vZGVsLlxuICAgICAgJHNjb3BlLmRhdGEgPSAkc2NvcGUuZGF0YSB8fCB7fTtcbiAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSB8fCBbe31dO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgYW55IGNvbXBvbmVudCBpcyB2aXNpYmxlLlxuICAgICAgJHNjb3BlLmFueVZpc2libGUgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV07XG4gICAgICAgIHZhciB2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLCBmdW5jdGlvbihyb3dEYXRhKSB7XG4gICAgICAgICAgdmlzaWJsZSA9ICh2aXNpYmxlIHx8IEZvcm1pb1V0aWxzLmlzVmlzaWJsZShjb21wb25lbnQsIHJvd0RhdGEsICRzY29wZS5kYXRhLCAkc2NvcGUuaGlkZUNvbXBvbmVudHMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVsbCBvdXQgdGhlIHJvd3MgYW5kIGNvbHMgZm9yIGVhc3kgaXRlcmF0aW9uLlxuICAgICAgJHNjb3BlLnJvd3MgPSAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV07XG4gICAgICAvLyBJZiBsZXNzIHRoYW4gbWluTGVuZ3RoLCBhZGQgdGhhdCBtYW55IHJvd3MuXG4gICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZSAmJiAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLmhhc093blByb3BlcnR5KCdtaW5MZW5ndGgnKSAmJiAkc2NvcGUucm93cy5sZW5ndGggPCAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLm1pbkxlbmd0aCkge1xuICAgICAgICB2YXIgdG9BZGQgPSAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLm1pbkxlbmd0aCAtICRzY29wZS5yb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0FkZDsgaSsrKSB7XG4gICAgICAgICAgJHNjb3BlLnJvd3MucHVzaCh7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIElmIG1vcmUgdGhhbiBtYXhMZW5ndGgsIHJlbW92ZSBleHRyYSByb3dzLlxuICAgICAgaWYgKCRzY29wZS5jb21wb25lbnQudmFsaWRhdGUgJiYgJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZS5oYXNPd25Qcm9wZXJ0eSgnbWF4TGVuZ3RoJykgJiYgJHNjb3BlLnJvd3MubGVuZ3RoIDwgJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZS5tYXhMZW5ndGgpIHtcbiAgICAgICAgJHNjb3BlLnJvd3MgPSAkc2NvcGUucm93cy5zbGljZSgwLCAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLm1heExlbmd0aCk7XG4gICAgICB9XG4gICAgICAkc2NvcGUuY29scyA9ICRzY29wZS5jb21wb25lbnQuY29tcG9uZW50cztcbiAgICAgICRzY29wZS5sb2NhbEtleXMgPSAkc2NvcGUuY29tcG9uZW50LmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50LmtleTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgYSByb3cgdGhlIHRvIGdyaWQuXG4gICAgICAkc2NvcGUuYWRkUm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSgkc2NvcGUucm93cykpIHtcbiAgICAgICAgICAkc2NvcGUucm93cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5yb3dzLnB1c2goe30pO1xuICAgICAgfTtcblxuICAgICAgLy8gUmVtb3ZlIGEgcm93IGZyb20gdGhlIGdyaWQuXG4gICAgICAkc2NvcGUucmVtb3ZlUm93ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgJHNjb3BlLnJvd3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH07XG4gICAgfVxuICBdKTtcbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICAnRm9ybWlvVXRpbHMnLFxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlLCBGb3JtaW9VdGlscykge1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9kYXRhZ3JpZC5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcImZvcm1pby1kYXRhLWdyaWRcXFwiIG5nLWNvbnRyb2xsZXI9XFxcImZvcm1pb0RhdGFHcmlkXFxcIj5cXG4gIDx0YWJsZSBuZy1jbGFzcz1cXFwieyd0YWJsZS1zdHJpcGVkJzogY29tcG9uZW50LnN0cmlwZWQsICd0YWJsZS1ib3JkZXJlZCc6IGNvbXBvbmVudC5ib3JkZXJlZCwgJ3RhYmxlLWhvdmVyJzogY29tcG9uZW50LmhvdmVyLCAndGFibGUtY29uZGVuc2VkJzogY29tcG9uZW50LmNvbmRlbnNlZH1cXFwiIGNsYXNzPVxcXCJ0YWJsZSBkYXRhZ3JpZC10YWJsZVxcXCI+XFxuICAgIDx0cj5cXG4gICAgICA8dGhcXG4gICAgICAgIG5nLXJlcGVhdD1cXFwiY29sIGluIGNvbHMgdHJhY2sgYnkgJGluZGV4XFxcIlxcbiAgICAgICAgbmctY2xhc3M9XFxcInsnZmllbGQtcmVxdWlyZWQnOiBjb2wudmFsaWRhdGUucmVxdWlyZWR9XFxcIlxcbiAgICAgICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGFueVZpc2libGUoY29sKVxcXCJcXG4gICAgICA+e3sgY29sLmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvdGg+XFxuICAgIDwvdHI+XFxuICAgIDx0ciBuZy1yZXBlYXQ9XFxcInJvdyBpbiByb3dzIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctaW5pdD1cXFwicm93SW5kZXggPSAkaW5kZXhcXFwiPlxcbiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImNvbCBpbiBjb2xzIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctaW5pdD1cXFwiY29sLmhpZGVMYWJlbCA9IHRydWU7IGNvbEluZGV4ID0gJGluZGV4XFxcIiBjbGFzcz1cXFwiZm9ybWlvLWRhdGEtZ3JpZC1yb3dcXFwiIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBhbnlWaXNpYmxlKGNvbClcXFwiPlxcbiAgICAgICAgPGZvcm1pby1jb21wb25lbnRcXG4gICAgICAgICAgY29tcG9uZW50PVxcXCJjb2xcXFwiXFxuICAgICAgICAgIGRhdGE9XFxcInJvd3Nbcm93SW5kZXhdXFxcIlxcbiAgICAgICAgICBmb3JtaW8tZm9ybT1cXFwiZm9ybWlvRm9ybVxcXCJcXG4gICAgICAgICAgZm9ybWlvPVxcXCJmb3JtaW9cXFwiXFxuICAgICAgICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxuICAgICAgICAgIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiXFxuICAgICAgICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoY29sLCByb3cpXFxcIlxcbiAgICAgICAgICByZWFkLW9ubHk9XFxcImlzRGlzYWJsZWQoY29sLCByb3cpXFxcIlxcbiAgICAgICAgICBncmlkLXJvdz1cXFwicm93SW5kZXhcXFwiXFxuICAgICAgICAgIGdyaWQtY29sPVxcXCJjb2xJbmRleFxcXCJcXG4gICAgICAgICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXG4gICAgICAgID48L2Zvcm1pby1jb21wb25lbnQ+XFxuICAgICAgPC90ZD5cXG4gICAgICA8dGQgbmctaWY9XFxcIiFjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ3ZhbGlkYXRlJykgfHwgIWNvbXBvbmVudC52YWxpZGF0ZS5oYXNPd25Qcm9wZXJ0eSgnbWluTGVuZ3RoJykgfHwgcm93cy5sZW5ndGggPiBjb21wb25lbnQudmFsaWRhdGUubWluTGVuZ3RoXFxcIj5cXG4gICAgICAgIDxhIG5nLWNsaWNrPVxcXCJyZW1vdmVSb3cocm93SW5kZXgpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlLWNpcmNsZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9hPlxcbiAgICAgIDwvdGQ+XFxuICAgIDwvdHI+XFxuICA8L3RhYmxlPlxcbiAgPGRpdiBjbGFzcz1cXFwiZGF0YWdyaWQtYWRkXFxcIiBuZy1pZj1cXFwiIWNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgndmFsaWRhdGUnKSB8fCAhY29tcG9uZW50LnZhbGlkYXRlLmhhc093blByb3BlcnR5KCdtYXhMZW5ndGgnKSB8fCByb3dzLmxlbmd0aCA8IGNvbXBvbmVudC52YWxpZGF0ZS5tYXhMZW5ndGhcXFwiPlxcbiAgICA8YSBuZy1jbGljaz1cXFwiYWRkUm93KClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXBsdXNcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L3NwYW4+IHt7IGNvbXBvbmVudC5hZGRBbm90aGVyIHx8IFxcXCJBZGQgQW5vdGhlclxcXCIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19XFxuICAgIDwvYT5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiXG4gICAgICApKTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xuICBhcHAuY29uZmlnKFtcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignZGF0ZXRpbWUnLCB7XG4gICAgICAgIHRpdGxlOiAnRGF0ZSAvIFRpbWUnLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2RhdGV0aW1lLmh0bWwnLFxuICAgICAgICB0YWJsZVZpZXc6IGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCwgJGludGVycG9sYXRlKSB7XG4gICAgICAgICAgcmV0dXJuICRpbnRlcnBvbGF0ZSgnPHNwYW4+e3sgXCInICsgZGF0YSArICdcIiB8IGRhdGU6IFwiJyArIGNvbXBvbmVudC5mb3JtYXQgKyAnXCIgfX08L3NwYW4+JykoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ3JvdXA6ICdhZHZhbmNlZCcsXG4gICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgJyR0aW1lb3V0JywgZnVuY3Rpb24oJHNjb3BlLCAkdGltZW91dCkge1xuICAgICAgICAgIC8vIENsb3NlIGNhbGVuZGFyIHBvcCB1cCB3aGVuIHRhYmJpbmcgb2ZmIGJ1dHRvblxuICAgICAgICAgICRzY29wZS5vbktleURvd24gPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGUgPT09IDkgPyBmYWxzZSA6ICRzY29wZS5jYWxlbmRhck9wZW47XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBkYXRlVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkYXRlIGlzIHNldCwgdGhlbiByZXR1cm4gdGhlIHRydWUgZGF0ZSB2YWx1ZS5cbiAgICAgICAgICAgIGlmICgkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuICgkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gaW5zdGFuY2VvZiBEYXRlKSA/ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA6IG5ldyBEYXRlKCRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlZSBpZiBhIGRlZmF1bHQgZGF0ZSBpcyBzZXQuXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5kZWZhdWx0RGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgZGVmYXVsdERhdGUgPSBuZXcgRGF0ZSgkc2NvcGUuY29tcG9uZW50LmRlZmF1bHREYXRlKTtcbiAgICAgICAgICAgICAgaWYgKCFkZWZhdWx0RGF0ZSB8fCBpc05hTihkZWZhdWx0RGF0ZS5nZXREYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHREYXRlID0gbmV3IERhdGUoZXZhbCgkc2NvcGUuY29tcG9uZW50LmRlZmF1bHREYXRlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0RGF0ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkZWZhdWx0RGF0ZSAmJiAhaXNOYU4oZGVmYXVsdERhdGUuZ2V0RGF0ZSgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RGF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGVtcHR5LlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBFbnN1cmUgdGhlIGRhdGUgdmFsdWUgaXMgYWx3YXlzIGEgZGF0ZSBvYmplY3Qgd2hlbiBsb2FkZWQsIHRoZW4gdW5iaW5kIHRoZSB3YXRjaC5cbiAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdkYXRhLicgKyAkc2NvcGUuY29tcG9uZW50LmtleSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFdhdGNoIGZvciBjaGFuZ2VzIHRvIHRoZSBtZXJpZGlhbiBzZXR0aW5ncyB0byBzeW5jaHJvbml6ZSB0aGUgc3VibWlzc2lvbkdyaWQgYW5kIGNvbXBvbmVudCB2aWV3LlxuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2NvbXBvbmVudC50aW1lUGlja2VyLnNob3dNZXJpZGlhbicsIGZ1bmN0aW9uKHVwZGF0ZSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBtZXJpZGlhbiByZWZlcmVuY2UsIGJlY2F1c2Ugd2VyZSBub3QgaW4gMTIgaHIuXG4gICAgICAgICAgICBpZiAoISRzY29wZS5jb21wb25lbnQuZW5hYmxlVGltZSB8fCAhdXBkYXRlKSB7XG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuZm9ybWF0ID0gJHNjb3BlLmNvbXBvbmVudC5mb3JtYXQucmVwbGFjZSgvIGEvLCAnJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbWlzc2luZyB0aGUgbWVyaWRpYW4gc3RyaW5nIGFuZCB3ZXJlIGluIDEyIGhyLCBhZGQgaXQuXG4gICAgICAgICAgICBpZiAodXBkYXRlICYmICRzY29wZS5jb21wb25lbnQuZm9ybWF0LmluZGV4T2YoJyBhJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuZm9ybWF0ICs9ICcgYSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoISRzY29wZS5jb21wb25lbnQuZGF0ZVBpY2tlci5tYXhEYXRlKSB7XG4gICAgICAgICAgICBkZWxldGUgJHNjb3BlLmNvbXBvbmVudC5kYXRlUGlja2VyLm1heERhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1heERhdGUgPSBuZXcgRGF0ZSgkc2NvcGUuY29tcG9uZW50LmRhdGVQaWNrZXIubWF4RGF0ZSk7XG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmRhdGVQaWNrZXIubWF4RGF0ZSA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICBtYXhEYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICAgIG1heERhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgbWF4RGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICAgIDIzLFxuICAgICAgICAgICAgICA1OSxcbiAgICAgICAgICAgICAgNTksXG4gICAgICAgICAgICAgIDk5OVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoISRzY29wZS5jb21wb25lbnQuZGF0ZVBpY2tlci5taW5EYXRlKSB7XG4gICAgICAgICAgICBkZWxldGUgJHNjb3BlLmNvbXBvbmVudC5kYXRlUGlja2VyLm1pbkRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1pbkRhdGUgPSBuZXcgRGF0ZSgkc2NvcGUuY29tcG9uZW50LmRhdGVQaWNrZXIubWluRGF0ZSk7XG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmRhdGVQaWNrZXIubWluRGF0ZSA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICBtaW5EYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICAgIG1pbkRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgbWluRGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJHNjb3BlLmF1dG9PcGVuID0gdHJ1ZTtcbiAgICAgICAgICAkc2NvcGUub25DbG9zZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS5hdXRvT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICRzY29wZS5hdXRvT3BlbiA9IHRydWU7XG4gICAgICAgICAgICB9LCAyNTApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1dLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGlucHV0OiB0cnVlLFxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAga2V5OiAnZGF0ZXRpbWVGaWVsZCcsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgICAgICAgIGZvcm1hdDogJ3l5eXktTU0tZGQgSEg6bW0gYScsXG4gICAgICAgICAgZW5hYmxlRGF0ZTogdHJ1ZSxcbiAgICAgICAgICBlbmFibGVUaW1lOiB0cnVlLFxuICAgICAgICAgIGRlZmF1bHREYXRlOiAnJyxcbiAgICAgICAgICBkYXRlcGlja2VyTW9kZTogJ2RheScsXG4gICAgICAgICAgZGF0ZVBpY2tlcjoge1xuICAgICAgICAgICAgc2hvd1dlZWtzOiB0cnVlLFxuICAgICAgICAgICAgc3RhcnRpbmdEYXk6IDAsXG4gICAgICAgICAgICBpbml0RGF0ZTogJycsXG4gICAgICAgICAgICBtaW5Nb2RlOiAnZGF5JyxcbiAgICAgICAgICAgIG1heE1vZGU6ICd5ZWFyJyxcbiAgICAgICAgICAgIHllYXJSb3dzOiA0LFxuICAgICAgICAgICAgeWVhckNvbHVtbnM6IDUsXG4gICAgICAgICAgICBtaW5EYXRlOiBudWxsLFxuICAgICAgICAgICAgbWF4RGF0ZTogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGltZVBpY2tlcjoge1xuICAgICAgICAgICAgaG91clN0ZXA6IDEsXG4gICAgICAgICAgICBtaW51dGVTdGVwOiAxLFxuICAgICAgICAgICAgc2hvd01lcmlkaWFuOiB0cnVlLFxuICAgICAgICAgICAgcmVhZG9ubHlJbnB1dDogZmFsc2UsXG4gICAgICAgICAgICBtb3VzZXdoZWVsOiB0cnVlLFxuICAgICAgICAgICAgYXJyb3drZXlzOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZSxcbiAgICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tOiAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICAnRm9ybWlvVXRpbHMnLFxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlLCBGb3JtaW9VdGlscykge1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9kYXRldGltZS5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIj5cXG4gIDxpbnB1dFxcbiAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIlxcbiAgICBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXG4gICAgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcbiAgICBuZy1mb2N1cz1cXFwiY2FsZW5kYXJPcGVuID0gYXV0b09wZW5cXFwiXFxuICAgIG5nLWNsaWNrPVxcXCJjYWxlbmRhck9wZW4gPSB0cnVlXFxcIlxcbiAgICBuZy1pbml0PVxcXCJjYWxlbmRhck9wZW4gPSBmYWxzZVxcXCJcXG4gICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcbiAgICBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIlxcbiAgICBpcy1vcGVuPVxcXCJjYWxlbmRhck9wZW5cXFwiXFxuICAgIGRhdGV0aW1lLXBpY2tlcj1cXFwie3sgY29tcG9uZW50LmZvcm1hdCB9fVxcXCJcXG4gICAgZGF0ZXBpY2tlci1tb2RlPVxcXCJjb21wb25lbnQuZGF0ZXBpY2tlck1vZGVcXFwiXFxuICAgIHdoZW4tY2xvc2VkPVxcXCJvbkNsb3NlZCgpXFxcIlxcbiAgICBjdXN0b20tdmFsaWRhdG9yPVxcXCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXFxcIlxcbiAgICBlbmFibGUtZGF0ZT1cXFwiY29tcG9uZW50LmVuYWJsZURhdGVcXFwiXFxuICAgIGVuYWJsZS10aW1lPVxcXCJjb21wb25lbnQuZW5hYmxlVGltZVxcXCJcXG4gICAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiXFxuICAgIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXG4gICAgbmctYXR0ci1wbGFjZWhvbGRlcj1cXFwie3sgY29tcG9uZW50LnBsYWNlaG9sZGVyIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcXCJcXG4gICAgZGF0ZXBpY2tlci1vcHRpb25zPVxcXCJjb21wb25lbnQuZGF0ZVBpY2tlclxcXCJcXG4gICAgdGltZXBpY2tlci1vcHRpb25zPVxcXCJjb21wb25lbnQudGltZVBpY2tlclxcXCJcXG4gIC8+XFxuICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuXFxcIj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctY2xpY2s9XFxcImNhbGVuZGFyT3BlbiA9IHRydWVcXFwiIG5nLWtleWRvd249XFxcImNhbGVuZGFyT3BlbiA9IG9uS2V5RG93bigkZXZlbnQpXFxcIj5cXG4gICAgICA8aSBuZy1pZj1cXFwiY29tcG9uZW50LmVuYWJsZURhdGVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNhbGVuZGFyXFxcIj48L2k+XFxuICAgICAgPGkgbmctaWY9XFxcIiFjb21wb25lbnQuZW5hYmxlRGF0ZVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tdGltZVxcXCI+PC9pPlxcbiAgICA8L2J1dHRvbj5cXG4gIDwvc3Bhbj5cXG48L2Rpdj5cXG5cIlxuICAgICAgKSk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmRpcmVjdGl2ZSgnZGF5UGFydCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRycywgbmdNb2RlbCkge1xuICAgICAgICBpZiAoc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xuICAgICAgICB2YXIgbGltaXRMZW5ndGggPSBhdHRycy5jaGFyYWN0ZXJzIHx8IDI7XG4gICAgICAgIHNjb3BlLiR3YXRjaChhdHRycy5uZ01vZGVsLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIW5nTW9kZWwuJHZpZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVuZGVyID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG5nTW9kZWwuJHZpZXdWYWx1ZS5sZW5ndGggPiBsaW1pdExlbmd0aCkge1xuICAgICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKG5nTW9kZWwuJHZpZXdWYWx1ZS5zdWJzdHJpbmcoMCwgbGltaXRMZW5ndGgpKTtcbiAgICAgICAgICAgIHJlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc05hTihuZ01vZGVsLiR2aWV3VmFsdWUpKSB7XG4gICAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUobmdNb2RlbC4kdmlld1ZhbHVlLnJlcGxhY2UoL1xcRC9nLCcnKSk7XG4gICAgICAgICAgICByZW5kZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwYXJzZUludChuZ01vZGVsLiR2aWV3VmFsdWUpIDwgcGFyc2VJbnQoYXR0cnMubWluKSB8fFxuICAgICAgICAgICAgcGFyc2VJbnQobmdNb2RlbC4kdmlld1ZhbHVlKSA+IHBhcnNlSW50KGF0dHJzLm1heClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShuZ01vZGVsLiR2aWV3VmFsdWUuc3Vic3RyaW5nKDAsIGxpbWl0TGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgcmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgbmdNb2RlbC4kcmVuZGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgYXBwLmRpcmVjdGl2ZSgnZGF5SW5wdXQnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgICBzY29wZToge1xuICAgICAgICBjb21wb25lbnQ6ICc9JyxcbiAgICAgICAgY29tcG9uZW50SWQ6ICc9JyxcbiAgICAgICAgcmVhZE9ubHk6ICc9JyxcbiAgICAgICAgbmdNb2RlbDogJz0nLFxuICAgICAgICBncmlkUm93OiAnPScsXG4gICAgICAgIGdyaWRDb2w6ICc9JyxcbiAgICAgICAgYnVpbGRlcjogJz0/J1xuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvL2NvbXBvbmVudHMvZGF5LWlucHV0Lmh0bWwnLFxuICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgICRzY29wZS5tb250aHMgPSBbXG4gICAgICAgICAge3ZhbHVlOiAnJywgbGFiZWw6ICRzY29wZS5jb21wb25lbnQuZmllbGRzLm1vbnRoLnBsYWNlaG9sZGVyfSxcbiAgICAgICAgICB7dmFsdWU6ICcwMScsIGxhYmVsOiAnSmFudWFyeSd9LFxuICAgICAgICAgIHt2YWx1ZTogJzAyJywgbGFiZWw6ICdGZWJydWFyeSd9LFxuICAgICAgICAgIHt2YWx1ZTogJzAzJywgbGFiZWw6ICdNYXJjaCd9LFxuICAgICAgICAgIHt2YWx1ZTogJzA0JywgbGFiZWw6ICdBcHJpbCd9LFxuICAgICAgICAgIHt2YWx1ZTogJzA1JywgbGFiZWw6ICdNYXknfSxcbiAgICAgICAgICB7dmFsdWU6ICcwNicsIGxhYmVsOiAnSnVuZSd9LFxuICAgICAgICAgIHt2YWx1ZTogJzA3JywgbGFiZWw6ICdKdWx5J30sXG4gICAgICAgICAge3ZhbHVlOiAnMDgnLCBsYWJlbDogJ0F1Z3VzdCd9LFxuICAgICAgICAgIHt2YWx1ZTogJzA5JywgbGFiZWw6ICdTZXB0ZW1iZXInfSxcbiAgICAgICAgICB7dmFsdWU6ICcxMCcsIGxhYmVsOiAnT2N0b2Jlcid9LFxuICAgICAgICAgIHt2YWx1ZTogJzExJywgbGFiZWw6ICdOb3ZlbWJlcid9LFxuICAgICAgICAgIHt2YWx1ZTogJzEyJywgbGFiZWw6ICdEZWNlbWJlcid9XG4gICAgICAgIF07XG5cbiAgICAgICAgJHNjb3BlLmRhdGUgPSB7XG4gICAgICAgICAgZGF5OiAnJyxcbiAgICAgICAgICBtb250aDogJycsXG4gICAgICAgICAgeWVhcjogJydcbiAgICAgICAgfTtcbiAgICAgIH1dLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW0sIGF0dHJzLCBuZ01vZGVsKSB7XG4gICAgICAgIGlmIChzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgIC8vIFNldCB0aGUgc2NvcGUgdmFsdWVzIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGVsLlxuICAgICAgICBzY29wZS4kd2F0Y2goJ25nTW9kZWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBvbiBsb2FkLlxuICAgICAgICAgIGlmIChuZ01vZGVsLiR2aWV3VmFsdWUgJiYgIW5nTW9kZWwuJGRpcnR5KSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSB0eXBlb2YgbmdNb2RlbC4kdmlld1ZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICA/IG5nTW9kZWwuJHZpZXdWYWx1ZS5zcGxpdCgnLycpXG4gICAgICAgICAgICAgIDogbmdNb2RlbC4kdmlld1ZhbHVlO1xuICAgICAgICAgICAgaWYgKChwYXJ0cyBpbnN0YW5jZW9mIEFycmF5KSAmJiBwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgc2NvcGUuZGF0ZS5kYXkgPSBwYXJ0c1soc2NvcGUuY29tcG9uZW50LmRheUZpcnN0ID8gMCA6IDEpXTtcbiAgICAgICAgICAgICAgc2NvcGUuZGF0ZS5tb250aCA9IHBhcnRzWyhzY29wZS5jb21wb25lbnQuZGF5Rmlyc3QgPyAxIDogMCldO1xuICAgICAgICAgICAgICBzY29wZS5kYXRlLnllYXIgPSBwYXJ0c1syXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZnVuY3Rpb24gcGFkTGVmdChuciwgbiwgc3RyKSB7XG4gICAgICAgICAgbnIgPSBuci50b1N0cmluZygpO1xuICAgICAgICAgIGlmIChuci5sZW5ndGggPiBuKSB7XG4gICAgICAgICAgICByZXR1cm4gbnIuc3Vic3RyKDAsIG4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBBcnJheSgobiAtIG5yLmxlbmd0aCkgKyAxKS5qb2luKHN0ciB8fCAnMCcpICsgbnI7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NvcGUub25DaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZGF5ID0gcGFkTGVmdChzY29wZS5kYXRlLmRheSwgMik7XG4gICAgICAgICAgdmFyIG1vbnRoID0gcGFkTGVmdChzY29wZS5kYXRlLm1vbnRoLCAyKTtcbiAgICAgICAgICB2YXIgeWVhciA9IHBhZExlZnQoc2NvcGUuZGF0ZS55ZWFyLCA0KTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzY29wZS5jb21wb25lbnQuZGF5Rmlyc3QgPyBkYXkgOiBtb250aDtcbiAgICAgICAgICB2YWx1ZSArPSAnLyc7XG4gICAgICAgICAgdmFsdWUgKz0gc2NvcGUuY29tcG9uZW50LmRheUZpcnN0ID8gbW9udGggOiBkYXk7XG4gICAgICAgICAgdmFsdWUgKz0gJy8nICsgeWVhcjtcbiAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG5nTW9kZWwuJHZhbGlkYXRvcnMuZGF5ID0gZnVuY3Rpb24obW9kZWxWYWx1ZSwgdmlld1ZhbHVlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbW9kZWxWYWx1ZSB8fCB2aWV3VmFsdWU7XG4gICAgICAgICAgdmFyIHJlcXVpcmVkID0gc2NvcGUuY29tcG9uZW50LmZpZWxkcy5kYXkucmVxdWlyZWQgfHwgc2NvcGUuY29tcG9uZW50LmZpZWxkcy5tb250aC5yZXF1aXJlZCB8fCBzY29wZS5jb21wb25lbnQuZmllbGRzLnllYXIucmVxdWlyZWQ7XG5cbiAgICAgICAgICBpZiAoIXJlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZSAmJiByZXF1aXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGFydHMgPSB2YWx1ZS5zcGxpdCgnLycpO1xuICAgICAgICAgIGlmIChzY29wZS5jb21wb25lbnQuZmllbGRzLmRheS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgaWYgKHBhcnRzWyhzY29wZS5jb21wb25lbnQuZGF5Rmlyc3QgPyAwIDogMSldID09PSAnMDAnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjb3BlLmNvbXBvbmVudC5maWVsZHMubW9udGgucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1soc2NvcGUuY29tcG9uZW50LmRheUZpcnN0ID8gMSA6IDApXSA9PT0gJzAwJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzY29wZS5jb21wb25lbnQuZmllbGRzLnllYXIucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1syXSA9PT0gJzAwMDAnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdkYXknLCB7XG4gICAgICAgIHRpdGxlOiAnRGF5JyxcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9kYXkuaHRtbCcsXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGlucHV0OiB0cnVlLFxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAga2V5OiAnZGF5RmllbGQnLFxuICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgZGF5OiB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb250aDoge1xuICAgICAgICAgICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5ZWFyOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRheUZpcnN0OiBmYWxzZSxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZSxcbiAgICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgY3VzdG9tOiAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICAnRm9ybWlvVXRpbHMnLFxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlLCBGb3JtaW9VdGlscykge1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9kYXkuaHRtbCcsIEZvcm1pb1V0aWxzLmZpZWxkV3JhcChcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJkYXktaW5wdXRcXFwiPlxcbiAgPGRheS1pbnB1dFxcbiAgICBuYW1lPVxcXCJ7e2NvbXBvbmVudElkfX1cXFwiXFxuICAgIGNvbXBvbmVudC1pZD1cXFwiY29tcG9uZW50SWRcXFwiXFxuICAgIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChjb21wb25lbnQsIGRhdGEpXFxcIlxcbiAgICBjb21wb25lbnQ9XFxcImNvbXBvbmVudFxcXCJcXG4gICAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXG4gICAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXG4gICAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiXFxuICAgIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXG4gICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXG4gID48L2RheS1pbnB1dD5cXG48L2Rpdj5cXG5cIlxuICAgICAgKSk7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2RheS1pbnB1dC5odG1sJyxcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJkYXlTZWxlY3QgZm9ybSByb3dcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBjb2wteHMtM1xcXCIgbmctaWY9XFxcImNvbXBvbmVudC5kYXlGaXJzdCAmJiAhY29tcG9uZW50LmZpZWxkcy5kYXkuaGlkZVxcXCI+XFxuICAgIDxsYWJlbCBmb3I9XFxcInt7Y29tcG9uZW50SWR9fS1kYXlcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogY29tcG9uZW50LmZpZWxkcy5kYXkucmVxdWlyZWR9XFxcIj57eyBcXFwiRGF5XFxcIiB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2xhYmVsPlxcbiAgICA8aW5wdXRcXG4gICAgICBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIlxcbiAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgaWQ9XFxcInt7Y29tcG9uZW50SWR9fS1kYXlcXFwiXFxuICAgICAgbmctbW9kZWw9XFxcImRhdGUuZGF5XFxcIlxcbiAgICAgIG5nLWNoYW5nZT1cXFwib25DaGFuZ2UoKVxcXCJcXG4gICAgICBzdHlsZT1cXFwicGFkZGluZy1yaWdodDogMTBweDtcXFwiXFxuICAgICAgbmctYXR0ci1wbGFjZWhvbGRlcj1cXFwie3tjb21wb25lbnQuZmllbGRzLmRheS5wbGFjZWhvbGRlcn19XFxcIlxcbiAgICAgIGRheS1wYXJ0XFxuICAgICAgY2hhcmFjdGVycz1cXFwiMlxcXCJcXG4gICAgICBtaW49XFxcIjBcXFwiXFxuICAgICAgbWF4PVxcXCIzMVxcXCJcXG4gICAgICBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiXFxuICAgIC8+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgY29sLXhzLTRcXFwiIG5nLWlmPVxcXCIhY29tcG9uZW50LmZpZWxkcy5tb250aC5oaWRlXFxcIj5cXG4gICAgPGxhYmVsIGZvcj1cXFwie3tjb21wb25lbnRJZH19LW1vbnRoXFxcIiBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGNvbXBvbmVudC5maWVsZHMubW9udGgucmVxdWlyZWR9XFxcIj57eyBcXFwiTW9udGhcXFwiIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxuICAgIDxzZWxlY3RcXG4gICAgICBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIlxcbiAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgaWQ9XFxcInt7Y29tcG9uZW50SWR9fS1tb250aFxcXCJcXG4gICAgICBuZy1tb2RlbD1cXFwiZGF0ZS5tb250aFxcXCJcXG4gICAgICBuZy1jaGFuZ2U9XFxcIm9uQ2hhbmdlKClcXFwiXFxuICAgICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcbiAgICAgIG5nLW9wdGlvbnM9XFxcIm1vbnRoLnZhbHVlIGFzIG1vbnRoLmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciBmb3IgbW9udGggaW4gbW9udGhzXFxcIlxcbiAgICA+PC9zZWxlY3Q+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgY29sLXhzLTNcXFwiIG5nLWlmPVxcXCIhY29tcG9uZW50LmRheUZpcnN0ICYmICFjb21wb25lbnQuZmllbGRzLmRheS5oaWRlXFxcIj5cXG4gICAgPGxhYmVsIGZvcj1cXFwie3tjb21wb25lbnRJZH19LWRheVxcXCIgbmctY2xhc3M9XFxcInsnZmllbGQtcmVxdWlyZWQnOiBjb21wb25lbnQuZmllbGRzLmRheS5yZXF1aXJlZH1cXFwiPnt7IFxcXCJEYXlcXFwiIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxuICAgIDxpbnB1dFxcbiAgICAgIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxuICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICBpZD1cXFwie3tjb21wb25lbnRJZH19LWRheTFcXFwiXFxuICAgICAgbmctbW9kZWw9XFxcImRhdGUuZGF5XFxcIlxcbiAgICAgIG5nLWNoYW5nZT1cXFwib25DaGFuZ2UoKVxcXCJcXG4gICAgICBzdHlsZT1cXFwicGFkZGluZy1yaWdodDogMTBweDtcXFwiXFxuICAgICAgbmctYXR0ci1wbGFjZWhvbGRlcj1cXFwie3tjb21wb25lbnQuZmllbGRzLmRheS5wbGFjZWhvbGRlcn19XFxcIlxcbiAgICAgIGRheS1wYXJ0XFxuICAgICAgY2hhcmFjdGVycz1cXFwiMlxcXCJcXG4gICAgICBtaW49XFxcIjBcXFwiXFxuICAgICAgbWF4PVxcXCIzMVxcXCJcXG4gICAgICBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiXFxuICAgIC8+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgY29sLXhzLTVcXFwiIG5nLWlmPVxcXCIhY29tcG9uZW50LmZpZWxkcy55ZWFyLmhpZGVcXFwiPlxcbiAgICA8bGFiZWwgZm9yPVxcXCJ7e2NvbXBvbmVudElkfX0teWVhclxcXCIgbmctY2xhc3M9XFxcInsnZmllbGQtcmVxdWlyZWQnOiBjb21wb25lbnQuZmllbGRzLnllYXIucmVxdWlyZWR9XFxcIj57eyBcXFwiWWVhclxcXCIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9sYWJlbD5cXG4gICAgPGlucHV0XFxuICAgICAgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCJcXG4gICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgIGlkPVxcXCJ7e2NvbXBvbmVudElkfX0teWVhclxcXCJcXG4gICAgICBuZy1tb2RlbD1cXFwiZGF0ZS55ZWFyXFxcIlxcbiAgICAgIG5nLWNoYW5nZT1cXFwib25DaGFuZ2UoKVxcXCJcXG4gICAgICBzdHlsZT1cXFwicGFkZGluZy1yaWdodDogMTBweDtcXFwiXFxuICAgICAgbmctYXR0ci1wbGFjZWhvbGRlcj1cXFwie3tjb21wb25lbnQuZmllbGRzLnllYXIucGxhY2Vob2xkZXJ9fVxcXCJcXG4gICAgICBjaGFyYWN0ZXJzPVxcXCI0XFxcIlxcbiAgICAgIG1pbj1cXFwiMFxcXCJcXG4gICAgICBtYXg9XFxcIjIxMDBcXFwiXFxuICAgICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcbiAgICAvPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCJcbiAgICAgICk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdlbWFpbCcsIHtcbiAgICAgICAgdGl0bGU6ICdFbWFpbCcsXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvdGV4dGZpZWxkLmh0bWwnLFxuICAgICAgICBncm91cDogJ2FkdmFuY2VkJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXG4gICAgICAgICAgaW5wdXRUeXBlOiAnZW1haWwnLFxuICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICBrZXk6ICdlbWFpbEZpZWxkJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgICAgcHJlZml4OiAnJyxcbiAgICAgICAgICBzdWZmaXg6ICcnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJycsXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICB1bmlxdWU6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZSxcbiAgICAgICAgICBraWNrYm94OiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2ZpZWxkc2V0Jywge1xuICAgICAgICB0aXRsZTogJ0ZpZWxkIFNldCcsXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvZmllbGRzZXQuaHRtbCcsXG4gICAgICAgIGdyb3VwOiAnbGF5b3V0JyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBrZXk6ICdmaWVsZHNldCcsXG4gICAgICAgICAgaW5wdXQ6IGZhbHNlLFxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcbiAgICAgICAgICBsZWdlbmQ6ICcnLFxuICAgICAgICAgIGNvbXBvbmVudHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdUZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzVmlldy9maWVsZHNldC5odG1sJ1xuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9maWVsZHNldC5odG1sJyxcbiAgICAgICAgXCI8ZmllbGRzZXQgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPlxcbiAgPGxlZ2VuZCBuZy1pZj1cXFwiY29tcG9uZW50LmxlZ2VuZFxcXCI+e3sgY29tcG9uZW50LmxlZ2VuZCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2xlZ2VuZD5cXG4gIDxmb3JtaW8tY29tcG9uZW50XFxuICAgIG5nLXJlcGVhdD1cXFwiX2NvbXBvbmVudCBpbiBjb21wb25lbnQuY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiXFxuICAgIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXG4gICAgZGF0YT1cXFwiZGF0YVxcXCJcXG4gICAgZm9ybWlvPVxcXCJmb3JtaW9cXFwiXFxuICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxuICAgIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiXFxuICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxuICAgIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChfY29tcG9uZW50LCBkYXRhKVxcXCJcXG4gICAgZm9ybWlvLWZvcm09XFxcImZvcm1pb0Zvcm1cXFwiXFxuICAgIGdyaWQtcm93PVxcXCJncmlkUm93XFxcIlxcbiAgICBncmlkLWNvbD1cXFwiZ3JpZENvbFxcXCJcXG4gICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXG4gID48L2Zvcm1pby1jb21wb25lbnQ+XFxuPC9maWVsZHNldD5cXG5cIlxuICAgICAgKTtcblxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50c1ZpZXcvZmllbGRzZXQuaHRtbCcsXG4gICAgICAgIFwiPGZpZWxkc2V0IGlkPVxcXCJ7eyBjb21wb25lbnQua2V5IH19XFxcIj5cXG4gIDxsZWdlbmQgbmctaWY9XFxcImNvbXBvbmVudC5sZWdlbmRcXFwiPnt7IGNvbXBvbmVudC5sZWdlbmQgfX08L2xlZ2VuZD5cXG4gIDxmb3JtaW8tY29tcG9uZW50LXZpZXdcXG4gICAgbmctcmVwZWF0PVxcXCJfY29tcG9uZW50IGluIGNvbXBvbmVudC5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCJcXG4gICAgY29tcG9uZW50PVxcXCJfY29tcG9uZW50XFxcIlxcbiAgICBkYXRhPVxcXCJkYXRhXFxcIlxcbiAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcbiAgICBmb3JtPVxcXCJmb3JtXFxcIlxcbiAgICBpZ25vcmU9XFxcImlnbm9yZVxcXCJcXG4gICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShfY29tcG9uZW50LCBkYXRhKVxcXCJcXG4gICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXG4gID48L2Zvcm1pby1jb21wb25lbnQtdmlldz5cXG48L2ZpZWxkc2V0PlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdmaWxlJywge1xuICAgICAgICB0aXRsZTogJ0ZpbGUnLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2ZpbGUuaHRtbCcsXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGlucHV0OiB0cnVlLFxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAga2V5OiAnZmlsZScsXG4gICAgICAgICAgaW1hZ2U6IGZhbHNlLFxuICAgICAgICAgIGltYWdlU2l6ZTogJzIwMCcsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcnLFxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcbiAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdUZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzVmlldy9maWxlLmh0bWwnXG4gICAgICB9KTtcbiAgICB9XG4gIF0pO1xuXG4gIGFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0ZpbGVMaXN0JywgW2Z1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGZpbGVzOiAnPScsXG4gICAgICAgIGZvcm06ICc9JyxcbiAgICAgICAgcmVhZE9ubHk6ICc9J1xuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvL2NvbXBvbmVudHMvZm9ybWlvLWZpbGUtbGlzdC5odG1sJyxcbiAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgJyRzY29wZScsXG4gICAgICAgIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xuICAgICAgICAgICRzY29wZS5yZW1vdmVGaWxlID0gZnVuY3Rpb24oZXZlbnQsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gJHNjb3BlLiRwYXJlbnQuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5zdG9yYWdlID09PSAndXJsJykge1xuICAgICAgICAgICAgICAkc2NvcGUuJHBhcmVudC5mb3JtaW8ubWFrZVJlcXVlc3QoJycsIGNvbXBvbmVudC51cmwgKyAnLycgKyAkc2NvcGUuZmlsZXNbaW5kZXhdLm5hbWUsICdkZWxldGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAkc2NvcGUuZmlsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgJHNjb3BlLmZpbGVTaXplID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIChiID0gTWF0aCwgYyA9IGIubG9nLCBkID0gMTAyNCwgZSA9IGMoYSkgLyBjKGQpIHwgMCwgYSAvIGIucG93KGQsIGUpKS50b0ZpeGVkKDIpICsgJyAnICsgKGUgPyAna01HVFBFWlknWy0tZV0gKyAnQicgOiAnQnl0ZXMnKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfV0pO1xuXG4gIGFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0ltYWdlTGlzdCcsIFtmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY29wZToge1xuICAgICAgICBmaWxlczogJz0nLFxuICAgICAgICBmb3JtOiAnPScsXG4gICAgICAgIHdpZHRoOiAnPScsXG4gICAgICAgIHJlYWRPbmx5OiAnPSdcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9jb21wb25lbnRzL2Zvcm1pby1pbWFnZS1saXN0Lmh0bWwnLFxuICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAnJHNjb3BlJyxcbiAgICAgICAgZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgICAgJHNjb3BlLnJlbW92ZUZpbGUgPSBmdW5jdGlvbihldmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSAkc2NvcGUuJHBhcmVudC5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnN0b3JhZ2UgPT09ICd1cmwnKSB7XG4gICAgICAgICAgICAgICRzY29wZS4kcGFyZW50LmZvcm1pby5tYWtlUmVxdWVzdCgnJywgY29tcG9uZW50LnVybCArICcvJyArICRzY29wZS5maWxlc1tpbmRleF0ubmFtZSwgJ2RlbGV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICRzY29wZS5maWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XSk7XG5cbiAgYXBwLmRpcmVjdGl2ZSgnZm9ybWlvRmlsZScsIFtmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY29wZToge1xuICAgICAgICBmaWxlOiAnPScsXG4gICAgICAgIGZvcm06ICc9J1xuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlOiAnPGEgaHJlZj1cInt7IGZpbGUudXJsIH19XCIgbmctY2xpY2s9XCJnZXRGaWxlKCRldmVudClcIiB0YXJnZXQ9XCJfYmxhbmtcIj57eyBmaWxlLm5hbWUgfX08L2E+JyxcbiAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgJyR3aW5kb3cnLFxuICAgICAgICAnJHJvb3RTY29wZScsXG4gICAgICAgICckc2NvcGUnLFxuICAgICAgICAnRm9ybWlvJyxcbiAgICAgICAgZnVuY3Rpb24oXG4gICAgICAgICAgJHdpbmRvdyxcbiAgICAgICAgICAkcm9vdFNjb3BlLFxuICAgICAgICAgICRzY29wZSxcbiAgICAgICAgICBGb3JtaW9cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgICAgJHNjb3BlLmdldEZpbGUgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgJHNjb3BlLmZvcm0gPSAkc2NvcGUuZm9ybSB8fCAkcm9vdFNjb3BlLmZpbGVQYXRoO1xuICAgICAgICAgICAgdmFyIGZvcm1pbyA9IG5ldyBGb3JtaW8oJHNjb3BlLmZvcm0pO1xuICAgICAgICAgICAgZm9ybWlvXG4gICAgICAgICAgICAgIC5kb3dubG9hZEZpbGUoJHNjb3BlLmZpbGUpLnRoZW4oZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAkd2luZG93Lm9wZW4oZmlsZS51cmwsICdfYmxhbmsnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIC8vIElzIGFsZXJ0IHRoZSBiZXN0IHdheSB0byBkbyB0aGlzP1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgaXMgZXhwZWN0aW5nIGFuIGltbWVkaWF0ZSBub3RpZmljYXRpb24gZHVlIHRvIGF0dGVtcHRpbmcgdG8gZG93bmxvYWQgYSBmaWxlLlxuICAgICAgICAgICAgICAgIGFsZXJ0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1dKTtcblxuICBhcHAuZGlyZWN0aXZlKCdmb3JtaW9JbWFnZScsIFtmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY29wZToge1xuICAgICAgICBmaWxlOiAnPScsXG4gICAgICAgIGZvcm06ICc9JyxcbiAgICAgICAgd2lkdGg6ICc9J1xuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlOiAnPGltZyBuZy1zcmM9XCJ7eyBmaWxlLmltYWdlU3JjIH19XCIgYWx0PVwie3sgZmlsZS5uYW1lIH19XCIgbmctc3R5bGU9XCJ7d2lkdGg6IHdpZHRofVwiIC8+JyxcbiAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgJyRyb290U2NvcGUnLFxuICAgICAgICAnJHNjb3BlJyxcbiAgICAgICAgJ0Zvcm1pbycsXG4gICAgICAgIGZ1bmN0aW9uKFxuICAgICAgICAgICRyb290U2NvcGUsXG4gICAgICAgICAgJHNjb3BlLFxuICAgICAgICAgIEZvcm1pb1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoJHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcbiAgICAgICAgICAkc2NvcGUuZm9ybSA9ICRzY29wZS5mb3JtIHx8ICRyb290U2NvcGUuZmlsZVBhdGg7XG4gICAgICAgICAgdmFyIGZvcm1pbyA9IG5ldyBGb3JtaW8oJHNjb3BlLmZvcm0pO1xuICAgICAgICAgIGZvcm1pby5kb3dubG9hZEZpbGUoJHNjb3BlLmZpbGUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmZpbGUuaW1hZ2VTcmMgPSByZXN1bHQudXJsO1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1dKTtcblxuICBhcHAuY29udHJvbGxlcignZm9ybWlvRmlsZVVwbG9hZCcsIFtcbiAgICAnJHNjb3BlJyxcbiAgICAnRm9ybWlvVXRpbHMnLFxuICAgIGZ1bmN0aW9uKFxuICAgICAgJHNjb3BlLFxuICAgICAgRm9ybWlvVXRpbHNcbiAgICApIHtcbiAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xuICAgICAgJHNjb3BlLmZpbGVVcGxvYWRzID0ge307XG4gICAgICAkc2NvcGUucmVtb3ZlVXBsb2FkID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgZGVsZXRlICRzY29wZS5maWxlVXBsb2Fkc1tpbmRleF07XG4gICAgICB9O1xuXG4gICAgICAvLyBUaGlzIGZpeGVzIG5ldyBmaWVsZHMgaGF2aW5nIGFuIGVtcHR5IHNwYWNlIGluIHRoZSBhcnJheS5cbiAgICAgIGlmICgkc2NvcGUuZGF0YSAmJiAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPT09ICcnKSB7XG4gICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCRzY29wZS5kYXRhICYmICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCRzY29wZS5kYXRhICYmICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSAmJiAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV1bMF0gPT09ICcnKSB7XG4gICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XS5zcGxpY2UoMCwgMSk7XG4gICAgICB9XG5cbiAgICAgICRzY29wZS51cGxvYWQgPSBmdW5jdGlvbihmaWxlcykge1xuICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5zdG9yYWdlICYmIGZpbGVzICYmIGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmaWxlcywgZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgLy8gR2V0IGEgdW5pcXVlIG5hbWUgZm9yIHRoaXMgZmlsZSB0byBrZWVwIGZpbGUgY29sbGlzaW9ucyBmcm9tIG9jY3VycmluZy5cbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IEZvcm1pb1V0aWxzLnVuaXF1ZU5hbWUoZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICRzY29wZS5maWxlVXBsb2Fkc1tmaWxlTmFtZV0gPSB7XG4gICAgICAgICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgIHN0YXR1czogJ2luZm8nLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnU3RhcnRpbmcgdXBsb2FkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkaXIgPSAkc2NvcGUuY29tcG9uZW50LmRpciB8fCAnJztcbiAgICAgICAgICAgIHZhciBmb3JtaW8gPSBudWxsO1xuICAgICAgICAgICAgaWYgKCRzY29wZS5mb3JtaW8pIHtcbiAgICAgICAgICAgICAgZm9ybWlvID0gJHNjb3BlLmZvcm1pbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAkc2NvcGUuZmlsZVVwbG9hZHNbZmlsZU5hbWVdLnN0YXR1cyA9ICdlcnJvcic7XG4gICAgICAgICAgICAgICRzY29wZS5maWxlVXBsb2Fkc1tmaWxlTmFtZV0ubWVzc2FnZSA9ICdGaWxlIFVwbG9hZCBVUkwgbm90IHByb3ZpZGVkLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JtaW8pIHtcbiAgICAgICAgICAgICAgZm9ybWlvLnVwbG9hZEZpbGUoJHNjb3BlLmNvbXBvbmVudC5zdG9yYWdlLCBmaWxlLCBmaWxlTmFtZSwgZGlyLCBmdW5jdGlvbiBwcm9jZXNzTm90aWZ5KGV2dCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5maWxlVXBsb2Fkc1tmaWxlTmFtZV0uc3RhdHVzID0gJ3Byb2dyZXNzJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuZmlsZVVwbG9hZHNbZmlsZU5hbWVdLnByb2dyZXNzID0gcGFyc2VJbnQoMTAwLjAgKiBldnQubG9hZGVkIC8gZXZ0LnRvdGFsKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmZpbGVVcGxvYWRzW2ZpbGVOYW1lXS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgfSwgJHNjb3BlLmNvbXBvbmVudC51cmwpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZmlsZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSAkc2NvcGUuZmlsZVVwbG9hZHNbZmlsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZpbGUgY29tcG9uZW50IGlzIGFuIGFycmF5LlxuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldIHx8XG4gICAgICAgICAgICAgICAgICAgICEoJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gW107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0ucHVzaChmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5maWxlVXBsb2Fkc1tmaWxlTmFtZV0uc3RhdHVzID0gJ2Vycm9yJztcbiAgICAgICAgICAgICAgICAgICRzY29wZS5maWxlVXBsb2Fkc1tmaWxlTmFtZV0ubWVzc2FnZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmZpbGVVcGxvYWRzW2ZpbGVOYW1lXS5wcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIF0pO1xuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgIGZ1bmN0aW9uKFxuICAgICAgJHRlbXBsYXRlQ2FjaGVcbiAgICApIHtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvZm9ybWlvLWltYWdlLWxpc3QuaHRtbCcsXG4gICAgICAgIFwiPGRpdj5cXG4gIDxzcGFuIG5nLXJlcGVhdD1cXFwiZmlsZSBpbiBmaWxlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWlmPVxcXCJmaWxlXFxcIj5cXG4gICAgPGZvcm1pby1pbWFnZSBmaWxlPVxcXCJmaWxlXFxcIiBmb3JtPVxcXCJmb3JtXFxcIiB3aWR0aD1cXFwid2lkdGhcXFwiPjwvZm9ybWlvLWltYWdlPlxcbiAgICA8c3BhbiBuZy1pZj1cXFwiIXJlYWRPbmx5XFxcIiBzdHlsZT1cXFwid2lkdGg6MSU7d2hpdGUtc3BhY2U6bm93cmFwO1xcXCI+XFxuICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgbmctY2xpY2s9XFxcInJlbW92ZUZpbGUoJGV2ZW50LCAkaW5kZXgpXFxcIiBzdHlsZT1cXFwicGFkZGluZzogMnB4IDRweDtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0XFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcXFwiPjwvc3Bhbj48L2E+XFxuICAgIDwvc3Bhbj5cXG4gIDwvc3Bhbj5cXG48L2Rpdj5cXG5cIlxuICAgICAgKTtcblxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9mb3JtaW8tZmlsZS1saXN0Lmh0bWwnLFxuICAgICAgICBcIjx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZFxcXCI+XFxuICA8dGhlYWQ+XFxuICAgIDx0cj5cXG4gICAgICA8dGQgbmctaWY9XFxcIiFyZWFkT25seVxcXCIgc3R5bGU9XFxcIndpZHRoOjElO3doaXRlLXNwYWNlOm5vd3JhcDtcXFwiPjwvdGQ+XFxuICAgICAgPHRoPkZpbGUgTmFtZTwvdGg+XFxuICAgICAgPHRoPlNpemU8L3RoPlxcbiAgICA8L3RyPlxcbiAgPC90aGVhZD5cXG4gIDx0Ym9keT5cXG4gICAgPHRyIG5nLXJlcGVhdD1cXFwiZmlsZSBpbiBmaWxlcyB0cmFjayBieSAkaW5kZXhcXFwiPlxcbiAgICAgIDx0ZCBuZy1pZj1cXFwiIXJlYWRPbmx5XFxcIiBzdHlsZT1cXFwid2lkdGg6MSU7d2hpdGUtc3BhY2U6bm93cmFwO1xcXCI+PGEgbmctaWY9XFxcIiFyZWFkT25seVxcXCIgaHJlZj1cXFwiI1xcXCIgbmctY2xpY2s9XFxcInJlbW92ZUZpbGUoJGV2ZW50LCAkaW5kZXgpXFxcIiBzdHlsZT1cXFwicGFkZGluZzogMnB4IDRweDtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0XFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG4gICAgICA8dGQ+PGZvcm1pby1maWxlIGZpbGU9XFxcImZpbGVcXFwiIGZvcm09XFxcImZvcm1cXFwiPjwvZm9ybWlvLWZpbGU+PC90ZD5cXG4gICAgICA8dGQ+e3sgZmlsZVNpemUoZmlsZS5zaXplKSB9fTwvdGQ+XFxuICAgIDwvdHI+XFxuICA8L3Rib2R5PlxcbjwvdGFibGU+XFxuXCJcbiAgICAgICk7XG5cbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvZmlsZS5odG1sJyxcbiAgICAgICAgXCI8bGFiZWwgbmctaWY9XFxcImNvbXBvbmVudC5sYWJlbCAmJiAhY29tcG9uZW50LmhpZGVMYWJlbFxcXCIgZm9yPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxuPHNwYW4gbmctaWY9XFxcIiFjb21wb25lbnQubGFiZWwgJiYgaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1hc3RlcmlzayBmb3JtLWNvbnRyb2wtZmVlZGJhY2sgZmllbGQtcmVxdWlyZWQtaW5saW5lXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9zcGFuPlxcbjxkaXYgbmctY29udHJvbGxlcj1cXFwiZm9ybWlvRmlsZVVwbG9hZFxcXCI+XFxuICA8Zm9ybWlvLWZpbGUtbGlzdCBmaWxlcz1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCIgZm9ybT1cXFwiZm9ybWlvLmZvcm1VcmxcXFwiIG5nLWlmPVxcXCIhY29tcG9uZW50LmltYWdlXFxcIj48L2Zvcm1pby1maWxlLWxpc3Q+XFxuICA8Zm9ybWlvLWltYWdlLWxpc3QgZmlsZXM9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiIGZvcm09XFxcImZvcm1pby5mb3JtVXJsXFxcIiB3aWR0aD1cXFwiY29tcG9uZW50LmltYWdlU2l6ZVxcXCIgbmctaWY9XFxcImNvbXBvbmVudC5pbWFnZVxcXCI+PC9mb3JtaW8taW1hZ2UtbGlzdD5cXG4gIDxkaXYgbmctaWY9XFxcIiFyZWFkT25seSAmJiAoY29tcG9uZW50Lm11bHRpcGxlIHx8ICghY29tcG9uZW50Lm11bHRpcGxlICYmICFkYXRhW2NvbXBvbmVudC5rZXldLmxlbmd0aCkpXFxcIj5cXG4gICAgPGRpdiBuZ2YtZHJvcD1cXFwidXBsb2FkKCRmaWxlcylcXFwiIGNsYXNzPVxcXCJmaWxlU2VsZWN0b3JcXFwiIG5nZi1kcmFnLW92ZXItY2xhc3M9XFxcIidmaWxlRHJhZ092ZXInXFxcIiBuZ2YtbXVsdGlwbGU9XFxcImNvbXBvbmVudC5tdWx0aXBsZVxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIiBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2xvdWQtdXBsb2FkXFxcIj48L3NwYW4+RHJvcCBmaWxlcyB0byBhdHRhY2gsIG9yIDxhIHN0eWxlPVxcXCJjdXJzb3I6IHBvaW50ZXI7XFxcIiBuZ2Ytc2VsZWN0PVxcXCJ1cGxvYWQoJGZpbGVzKVxcXCIgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIiBuZ2YtbXVsdGlwbGU9XFxcImNvbXBvbmVudC5tdWx0aXBsZVxcXCI+YnJvd3NlPC9hPi48L2Rpdj5cXG4gICAgPGRpdiBuZy1pZj1cXFwiIWNvbXBvbmVudC5zdG9yYWdlXFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtd2FybmluZ1xcXCI+Tm8gc3RvcmFnZSBoYXMgYmVlbiBzZXQgZm9yIHRoaXMgZmllbGQuIEZpbGUgdXBsb2FkcyBhcmUgZGlzYWJsZWQgdW50aWwgc3RvcmFnZSBpcyBzZXQgdXAuPC9kaXY+XFxuICAgIDxkaXYgbmdmLW5vLWZpbGUtZHJvcD5GaWxlIERyYWcvRHJvcCBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGJyb3dzZXI8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBuZy1yZXBlYXQ9XFxcImZpbGVVcGxvYWQgaW4gZmlsZVVwbG9hZHMgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1jbGFzcz1cXFwieydoYXMtZXJyb3InOiBmaWxlVXBsb2FkLnN0YXR1cyA9PT0gJ2Vycm9yJ31cXFwiIGNsYXNzPVxcXCJmaWxlXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmaWxlTmFtZSBjb250cm9sLWxhYmVsIGNvbC1zbS0xMFxcXCI+e3sgZmlsZVVwbG9hZC5uYW1lIH19IDxzcGFuIG5nLWNsaWNrPVxcXCJyZW1vdmVVcGxvYWQoZmlsZVVwbG9hZC5uYW1lKVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlXFxcIj48L3NwYW4+PC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZmlsZVNpemUgY29udHJvbC1sYWJlbCBjb2wtc20tMiB0ZXh0LXJpZ2h0XFxcIj57eyBmaWxlU2l6ZShmaWxlVXBsb2FkLnNpemUpIH19PC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMlxcXCI+XFxuICAgICAgICA8c3BhbiBuZy1pZj1cXFwiZmlsZVVwbG9hZC5zdGF0dXMgPT09ICdwcm9ncmVzcydcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3MtYmFyXFxcIiByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgYXJpYS12YWx1ZW5vdz1cXFwie3tmaWxlVXBsb2FkLnByb2dyZXNzfX1cXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcIjEwMFxcXCIgc3R5bGU9XFxcIndpZHRoOnt7ZmlsZVVwbG9hZC5wcm9ncmVzc319JVxcXCI+XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+e3tmaWxlVXBsb2FkLnByb2dyZXNzfX0lIENvbXBsZXRlPC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDxkaXYgbmctaWY9XFxcIiFmaWxlVXBsb2FkLnN0YXR1cyAhPT0gJ3Byb2dyZXNzJ1xcXCIgY2xhc3M9XFxcImJnLXt7IGZpbGVVcGxvYWQuc3RhdHVzIH19IGNvbnRyb2wtbGFiZWxcXFwiPnt7IGZpbGVVcGxvYWQubWVzc2FnZSB9fTwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiXG4gICAgICApO1xuXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzVmlldy9maWxlLmh0bWwnLFxuICAgICAgICBcIjxsYWJlbCBuZy1pZj1cXFwiY29tcG9uZW50LmxhYmVsICYmICFjb21wb25lbnQuaGlkZUxhYmVsXFxcIiBmb3I9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGNvbXBvbmVudC52YWxpZGF0ZS5yZXF1aXJlZH1cXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2xhYmVsPlxcbjxkaXYgbmctY29udHJvbGxlcj1cXFwiZm9ybWlvRmlsZVVwbG9hZFxcXCI+XFxuICA8Zm9ybWlvLWZpbGUtbGlzdCBmaWxlcz1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCIgZm9ybT1cXFwiZm9ybVVybFxcXCIgcmVhZC1vbmx5PVxcXCJ0cnVlXFxcIiBuZy1pZj1cXFwiIWNvbXBvbmVudC5pbWFnZVxcXCI+PC9mb3JtaW8tZmlsZS1saXN0PlxcbiAgPGZvcm1pby1pbWFnZS1saXN0IGZpbGVzPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIiBmb3JtPVxcXCJmb3JtVXJsXFxcIiByZWFkLW9ubHk9XFxcInRydWVcXFwiIHdpZHRoPVxcXCJjb21wb25lbnQuaW1hZ2VTaXplXFxcIiBuZy1pZj1cXFwiY29tcG9uZW50LmltYWdlXFxcIj48L2Zvcm1pby1pbWFnZS1saXN0PlxcbjwvZGl2PlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBHcmlkVXRpbHMgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvR3JpZFV0aWxzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2hpZGRlbicsIHtcbiAgICAgICAgdGl0bGU6ICdIaWRkZW4nLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2hpZGRlbi5odG1sJyxcbiAgICAgICAgZ3JvdXA6ICdhZHZhbmNlZCcsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgaW5wdXQ6IHRydWUsXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxuICAgICAgICAgIGtleTogJ2hpZGRlbkZpZWxkJyxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICB1bmlxdWU6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgdGFibGVWaWV3OiBHcmlkVXRpbHMuZ2VuZXJpY1xuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9oaWRkZW4uaHRtbCcsXG4gICAgICAgIFwiPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIiBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiPlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmRpcmVjdGl2ZSgnZm9ybWlvSHRtbEVsZW1lbnQnLCBbXG4gICAgJyRzYW5pdGl6ZScsXG4gICAgJyRmaWx0ZXInLFxuICAgIGZ1bmN0aW9uKCRzYW5pdGl6ZSwgJGZpbHRlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICBjb21wb25lbnQ6ICc9J1xuICAgICAgICB9LFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9jb21wb25lbnRzL2h0bWxlbGVtZW50LWRpcmVjdGl2ZS5odG1sJyxcbiAgICAgICAgbGluazogZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgICAgdmFyIGRpc3BsYXlFcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgICAgJHNjb3BlLnBhcnNlRXJyb3IgPSAnSW52YWxpZCBIVE1MOiAnICsgbXNnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2NvbXBvbmVudCcsIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgICAgICAgICBpZiAoISRzY29wZS5jb21wb25lbnQudGFnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkaXNwbGF5RXJyb3IoJ05vIHRhZyBnaXZlbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGFuZ3VsYXIuZWxlbWVudCgnPCcgKyAkc2NvcGUuY29tcG9uZW50LnRhZyArICc+JyArICc8LycgKyAkc2NvcGUuY29tcG9uZW50LnRhZyArICc+Jyk7XG4gICAgICAgICAgICBlbGVtZW50Lmh0bWwoJGZpbHRlcignZm9ybWlvVHJhbnNsYXRlJykoJHNjb3BlLmNvbXBvbmVudC5jb250ZW50KSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgY3NzIGNsYXNzZXMgaWYgc3VwcGxpZWQuXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdjbGFzcycsICRzY29wZS5jb21wb25lbnQuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5jb21wb25lbnQuYXR0cnMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgICAgaWYgKCFhdHRyLmF0dHIpIHJldHVybjtcbiAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKGF0dHIuYXR0ciwgYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgJHNjb3BlLmh0bWwgPSAkc2FuaXRpemUoZWxlbWVudC5wcm9wKCdvdXRlckhUTUwnKSk7XG4gICAgICAgICAgICAgICRzY29wZS5wYXJzZUVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAvLyBJZiB0aGUgc2FuaXRpemVkIGh0bWwgaXMgZW1wdHksIGl0IHdhcyBpbnZhbGlkOyBDcmVhdGUgYSB2aXNpYmxlIGVycm9yIHNvIHdlIHN0aWxsIHJlbmRlciBzb21ldGhpbmcuXG4gICAgICAgICAgICAgIGlmICghJHNjb3BlLmh0bWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzcGxheUVycm9yKGVsZW1lbnQucHJvcCgnb3V0ZXJIVE1MJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIC8vIElzb2xhdGUgdGhlIG1lc3NhZ2UgYW5kIHN0b3JlIGl0LlxuICAgICAgICAgICAgICAkc2NvcGUucGFyc2VFcnJvciA9IGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVswXVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdbJHNhbml0aXplOmJhZHBhcnNlXScsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgfV0pO1xuXG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdodG1sZWxlbWVudCcsIHtcbiAgICAgICAgdGl0bGU6ICdIVE1MIEVsZW1lbnQnLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2h0bWxlbGVtZW50Lmh0bWwnLFxuICAgICAgICB2aWV3VGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9odG1sZWxlbWVudC5odG1sJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBrZXk6ICdodG1sJyxcbiAgICAgICAgICBpbnB1dDogZmFsc2UsXG4gICAgICAgICAgdGFnOiAncCcsXG4gICAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICAgIGNsYXNzTmFtZTogJycsXG4gICAgICAgICAgY29udGVudDogJydcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcblxuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2h0bWxlbGVtZW50Lmh0bWwnLFxuICAgICAgICAnPGZvcm1pby1odG1sLWVsZW1lbnQgY29tcG9uZW50PVwiY29tcG9uZW50XCI+PC9kaXY+J1xuICAgICAgKTtcblxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9odG1sZWxlbWVudC1kaXJlY3RpdmUuaHRtbCcsXG4gICAgICAgIFwiPGRpdiBpZD1cXFwie3sgY29tcG9uZW50LmtleSB9fVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC13YXJuaW5nXFxcIiBuZy1pZj1cXFwicGFyc2VFcnJvclxcXCI+e3sgcGFyc2VFcnJvciB9fTwvZGl2PlxcbiAgPGRpdiBuZy1iaW5kLWh0bWw9XFxcImh0bWxcXFwiPjwvZGl2PlxcbjwvZGl2PlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2Zvcm1pbycpO1xuXG4vLyBCYXNpY1xucmVxdWlyZSgnLi9jb21wb25lbnRzJykoYXBwKTtcbnJlcXVpcmUoJy4vdGV4dGZpZWxkJykoYXBwKTtcbnJlcXVpcmUoJy4vbnVtYmVyJykoYXBwKTtcbnJlcXVpcmUoJy4vcGFzc3dvcmQnKShhcHApO1xucmVxdWlyZSgnLi90ZXh0YXJlYScpKGFwcCk7XG5yZXF1aXJlKCcuL2NoZWNrYm94JykoYXBwKTtcbnJlcXVpcmUoJy4vc2VsZWN0Ym94ZXMnKShhcHApO1xucmVxdWlyZSgnLi9zZWxlY3QnKShhcHApO1xucmVxdWlyZSgnLi9yYWRpbycpKGFwcCk7XG5yZXF1aXJlKCcuL2h0bWxlbGVtZW50JykoYXBwKTtcbnJlcXVpcmUoJy4vY29udGVudCcpKGFwcCk7XG5yZXF1aXJlKCcuL2J1dHRvbicpKGFwcCk7XG5cbi8vIFNwZWNpYWxcbnJlcXVpcmUoJy4vZW1haWwnKShhcHApO1xucmVxdWlyZSgnLi9waG9uZW51bWJlcicpKGFwcCk7XG5yZXF1aXJlKCcuL2FkZHJlc3MnKShhcHApO1xucmVxdWlyZSgnLi9kYXRldGltZScpKGFwcCk7XG5yZXF1aXJlKCcuL2RheScpKGFwcCk7XG5yZXF1aXJlKCcuL2N1cnJlbmN5JykoYXBwKTtcbnJlcXVpcmUoJy4vaGlkZGVuJykoYXBwKTtcbnJlcXVpcmUoJy4vcmVzb3VyY2UnKShhcHApO1xucmVxdWlyZSgnLi9maWxlJykoYXBwKTtcbnJlcXVpcmUoJy4vc2lnbmF0dXJlJykoYXBwKTtcbnJlcXVpcmUoJy4vY3VzdG9tJykoYXBwKTtcbnJlcXVpcmUoJy4vY29udGFpbmVyJykoYXBwKTtcbnJlcXVpcmUoJy4vZGF0YWdyaWQnKShhcHApO1xucmVxdWlyZSgnLi9zdXJ2ZXknKShhcHApO1xuXG4vLyBMYXlvdXRcbnJlcXVpcmUoJy4vY29sdW1ucycpKGFwcCk7XG5yZXF1aXJlKCcuL2ZpZWxkc2V0JykoYXBwKTtcbnJlcXVpcmUoJy4vcGFnZScpKGFwcCk7XG5yZXF1aXJlKCcuL3BhbmVsJykoYXBwKTtcbnJlcXVpcmUoJy4vdGFibGUnKShhcHApO1xucmVxdWlyZSgnLi93ZWxsJykoYXBwKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgdmFyIGlzTnVtZXJpYyA9IGZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gICAgICB9O1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdudW1iZXInLCB7XG4gICAgICAgIHRpdGxlOiAnTnVtYmVyJyxcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9udW1iZXIuaHRtbCcsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgaW5wdXQ6IHRydWUsXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxuICAgICAgICAgIGlucHV0VHlwZTogJ251bWJlcicsXG4gICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgIGtleTogJ251bWJlckZpZWxkJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgICAgcHJlZml4OiAnJyxcbiAgICAgICAgICBzdWZmaXg6ICcnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJycsXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXG4gICAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbjogJycsXG4gICAgICAgICAgICBtYXg6ICcnLFxuICAgICAgICAgICAgc3RlcDogJ2FueScsXG4gICAgICAgICAgICBpbnRlZ2VyOiAnJyxcbiAgICAgICAgICAgIG11bHRpcGxlOiAnJyxcbiAgICAgICAgICAgIGN1c3RvbTogJydcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47IC8vIEZPUi03MSAtIFNraXAgcGFyc2luZyBpbnB1dCBkYXRhLlxuXG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdmFsdWVzIGFyZSBudW1iZXJzLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICRzY29wZS5kYXRhICYmXG4gICAgICAgICAgICAkc2NvcGUuZGF0YS5oYXNPd25Qcm9wZXJ0eSgkc2NvcGUuY29tcG9uZW50LmtleSkgJiZcbiAgICAgICAgICAgIGlzTnVtZXJpYygkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSBwYXJzZUZsb2F0KCRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcblxuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgICdGb3JtaW9VdGlscycsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUsIEZvcm1pb1V0aWxzKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL251bWJlci5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxuICAgICAgICBcIjxpbnB1dFxcbiAgdHlwZT1cXFwie3sgY29tcG9uZW50LmlucHV0VHlwZSB9fVxcXCJcXG4gIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxuICBpZD1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxuICBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXG4gIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXG4gIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIlxcbiAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXG4gIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXG4gIHNhZmUtbXVsdGlwbGUtdG8tc2luZ2xlXFxuICBtaW49XFxcInt7IGNvbXBvbmVudC52YWxpZGF0ZS5taW4gfX1cXFwiXFxuICBtYXg9XFxcInt7IGNvbXBvbmVudC52YWxpZGF0ZS5tYXggfX1cXFwiXFxuICBzdGVwPVxcXCJ7eyBjb21wb25lbnQudmFsaWRhdGUuc3RlcCB9fVxcXCJcXG4gIG5nLWF0dHItcGxhY2Vob2xkZXI9XFxcInt7IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXFwiXFxuICBjdXN0b20tdmFsaWRhdG9yPVxcXCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXFxcIlxcbiAgdWktbWFzaz1cXFwie3sgY29tcG9uZW50LmlucHV0TWFzayB9fVxcXCJcXG4gIHVpLW1hc2stcGxhY2Vob2xkZXI9XFxcIlxcXCJcXG4gIHVpLW9wdGlvbnM9XFxcInVpTWFza09wdGlvbnNcXFwiXFxuPlxcblwiXG4gICAgICApKTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xuICBhcHAuY29uZmlnKFtcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcigncGFnZScsIHtcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9wYWdlLmh0bWwnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGtleTogJ3BhZ2UnLFxuICAgICAgICAgIGlucHV0OiBmYWxzZSxcbiAgICAgICAgICBjb21wb25lbnRzOiBbXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIF0pO1xuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3BhZ2UuaHRtbCcsXG4gICAgICAgIFwiPGZvcm1pby1jb21wb25lbnRcXG4gIG5nLXJlcGVhdD1cXFwiX2NvbXBvbmVudCBpbiBjb21wb25lbnQuY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiXFxuICBjb21wb25lbnQ9XFxcIl9jb21wb25lbnRcXFwiXFxuICBkYXRhPVxcXCJkYXRhXFxcIlxcbiAgZm9ybWlvPVxcXCJmb3JtaW9cXFwiXFxuICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcbiAgaGlkZS1jb21wb25lbnRzPVxcXCJoaWRlQ29tcG9uZW50c1xcXCJcXG4gIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxuICByZWFkLW9ubHk9XFxcImlzRGlzYWJsZWQoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxuICBmb3JtaW8tZm9ybT1cXFwiZm9ybWlvRm9ybVxcXCJcXG4gIGdyaWQtcm93PVxcXCJncmlkUm93XFxcIlxcbiAgZ3JpZC1jb2w9XFxcImdyaWRDb2xcXFwiXFxuICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcbj48L2Zvcm1pby1jb21wb25lbnQ+XFxuXCJcbiAgICAgICk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3BhbmVsJywge1xuICAgICAgICB0aXRsZTogJ1BhbmVsJyxcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9wYW5lbC5odG1sJyxcbiAgICAgICAgZ3JvdXA6ICdsYXlvdXQnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGtleTogJ3BhbmVsJyxcbiAgICAgICAgICBpbnB1dDogZmFsc2UsXG4gICAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICAgIHRoZW1lOiAnZGVmYXVsdCcsXG4gICAgICAgICAgY29tcG9uZW50czogW11cbiAgICAgICAgfSxcbiAgICAgICAgdmlld1RlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHNWaWV3L3BhbmVsLmh0bWwnXG4gICAgICB9KTtcbiAgICB9XG4gIF0pO1xuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3BhbmVsLmh0bWwnLFxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLXt7IGNvbXBvbmVudC50aGVtZSB9fVxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPlxcbiAgPGRpdiBuZy1pZj1cXFwiY29tcG9uZW50LnRpdGxlXFxcIiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuICAgIDxoMyBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPnt7IGNvbXBvbmVudC50aXRsZSB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2gzPlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgPGZvcm1pby1jb21wb25lbnRcXG4gICAgICBuZy1yZXBlYXQ9XFxcIl9jb21wb25lbnQgaW4gY29tcG9uZW50LmNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIlxcbiAgICAgIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXG4gICAgICBkYXRhPVxcXCJkYXRhXFxcIlxcbiAgICAgIGZvcm1pbz1cXFwiZm9ybWlvXFxcIlxcbiAgICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxuICAgICAgaGlkZS1jb21wb25lbnRzPVxcXCJoaWRlQ29tcG9uZW50c1xcXCJcXG4gICAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogaXNWaXNpYmxlKF9jb21wb25lbnQsIGRhdGEpXFxcIlxcbiAgICAgIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChfY29tcG9uZW50LCBkYXRhKVxcXCJcXG4gICAgICBmb3JtaW8tZm9ybT1cXFwiZm9ybWlvRm9ybVxcXCJcXG4gICAgICBncmlkLXJvdz1cXFwiZ3JpZFJvd1xcXCJcXG4gICAgICBncmlkLWNvbD1cXFwiZ3JpZENvbFxcXCJcXG4gICAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcbiAgICA+PC9mb3JtaW8tY29tcG9uZW50PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCJcbiAgICAgICk7XG5cbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHNWaWV3L3BhbmVsLmh0bWwnLFxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLXt7IGNvbXBvbmVudC50aGVtZSB9fVxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPlxcbiAgPGRpdiBuZy1pZj1cXFwiY29tcG9uZW50LnRpdGxlXFxcIiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuICAgIDxoMyBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPnt7IGNvbXBvbmVudC50aXRsZSB9fTwvaDM+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcbiAgICA8Zm9ybWlvLWNvbXBvbmVudC12aWV3XFxuICAgICAgbmctcmVwZWF0PVxcXCJfY29tcG9uZW50IGluIGNvbXBvbmVudC5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCJcXG4gICAgICBjb21wb25lbnQ9XFxcIl9jb21wb25lbnRcXFwiXFxuICAgICAgZGF0YT1cXFwiZGF0YVxcXCJcXG4gICAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcbiAgICAgIGZvcm09XFxcImZvcm1cXFwiXFxuICAgICAgaWdub3JlPVxcXCJpZ25vcmVcXFwiXFxuICAgICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShfY29tcG9uZW50LCBkYXRhKVxcXCJcXG4gICAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcbiAgICA+PC9mb3JtaW8tY29tcG9uZW50LXZpZXc+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIlxuICAgICAgKTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3Bhc3N3b3JkJywge1xuICAgICAgICB0aXRsZTogJ1Bhc3N3b3JkJyxcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy90ZXh0ZmllbGQuaHRtbCcsXG4gICAgICAgIHRhYmxlVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICctLS0gUFJPVEVDVEVEIC0tLSc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgaW5wdXQ6IHRydWUsXG4gICAgICAgICAgdGFibGVWaWV3OiBmYWxzZSxcbiAgICAgICAgICBpbnB1dFR5cGU6ICdwYXNzd29yZCcsXG4gICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgIGtleTogJ3Bhc3N3b3JkRmllbGQnLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnJyxcbiAgICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICAgIHN1ZmZpeDogJycsXG4gICAgICAgICAgcHJvdGVjdGVkOiB0cnVlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3Bob25lTnVtYmVyJywge1xuICAgICAgICB0aXRsZTogJ1Bob25lIE51bWJlcicsXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvdGV4dGZpZWxkLmh0bWwnLFxuICAgICAgICBncm91cDogJ2FkdmFuY2VkJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXG4gICAgICAgICAgaW5wdXRNYXNrOiAnKDk5OSkgOTk5LTk5OTknLFxuICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICBrZXk6ICdwaG9uZW51bWJlckZpZWxkJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgICAgcHJlZml4OiAnJyxcbiAgICAgICAgICBzdWZmaXg6ICcnLFxuICAgICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHVuaXF1ZTogZmFsc2UsXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcbiAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJycsXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXG4gICAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xuICBhcHAuY29uZmlnKFtcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcigncmFkaW8nLCB7XG4gICAgICAgIHRpdGxlOiAnUmFkaW8nLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3JhZGlvLmh0bWwnLFxuICAgICAgICB0YWJsZVZpZXc6IGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCkge1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gY29tcG9uZW50LnZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC52YWx1ZXNbaV0udmFsdWUgPT09IGRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC52YWx1ZXNbaV0ubGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGlucHV0OiB0cnVlLFxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcbiAgICAgICAgICBpbnB1dFR5cGU6ICdyYWRpbycsXG4gICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgIGtleTogJ3JhZGlvRmllbGQnLFxuICAgICAgICAgIHZhbHVlczogW10sXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnJyxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZSxcbiAgICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tOiAnJyxcbiAgICAgICAgICAgIGN1c3RvbVByaXZhdGU6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIF0pO1xuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgICdGb3JtaW9VdGlscycsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUsIEZvcm1pb1V0aWxzKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3JhZGlvLmh0bWwnLCBGb3JtaW9VdGlscy5maWVsZFdyYXAoXG4gICAgICAgIFwiPG5nLWZvcm0gbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIiBjdXN0b20tdmFsaWRhdG9yPVxcXCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXFxcIj5cXG4gIDxkaXYgbmctY2xhc3M9XFxcImNvbXBvbmVudC5pbmxpbmUgPyAncmFkaW8taW5saW5lJyA6ICdyYWRpbydcXFwiIG5nLXJlcGVhdD1cXFwidiBpbiBjb21wb25lbnQudmFsdWVzIHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxuICAgIDxsYWJlbCBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCIgZm9yPVxcXCJ7eyBjb21wb25lbnRJZCB9fS17eyB2LnZhbHVlIH19XFxcIj5cXG4gICAgICA8aW5wdXRcXG4gICAgICAgIHR5cGU9XFxcInt7IGNvbXBvbmVudC5pbnB1dFR5cGUgfX1cXFwiXFxuICAgICAgICBpZD1cXFwie3sgY29tcG9uZW50SWQgfX0te3sgdi52YWx1ZSB9fVxcXCJcXG4gICAgICAgIHZhbHVlPVxcXCJ7eyB2LnZhbHVlIH19XFxcIlxcbiAgICAgICAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcbiAgICAgICAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiXFxuICAgICAgICBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIlxcbiAgICAgICAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXG4gICAgICAgIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXG4gICAgICA+XFxuICAgICAge3sgdi5sYWJlbCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXG4gICAgPC9sYWJlbD5cXG4gIDwvZGl2PlxcbjwvbmctZm9ybT5cXG5cIlxuICAgICAgKSk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3Jlc291cmNlJywge1xuICAgICAgICB0aXRsZTogJ1Jlc291cmNlJyxcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSkge1xuICAgICAgICAgIGlmICgkaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAkaW50ZXJwb2xhdGUoY29tcG9uZW50LnRlbXBsYXRlKSh7aXRlbTogZGF0YX0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkYXRhID8gZGF0YS5faWQgOiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgIHJldHVybiAkc2NvcGUuY29tcG9uZW50Lm11bHRpcGxlID8gJ2Zvcm1pby9jb21wb25lbnRzL3Jlc291cmNlLW11bHRpcGxlLmh0bWwnIDogJ2Zvcm1pby9jb21wb25lbnRzL3Jlc291cmNlLmh0bWwnO1xuICAgICAgICB9LFxuICAgICAgICBjb250cm9sbGVyOiBbJyRzY29wZScsICdGb3JtaW8nLCAnbmdEaWFsb2cnLCBmdW5jdGlvbigkc2NvcGUsIEZvcm1pbywgbmdEaWFsb2cpIHtcbiAgICAgICAgICBpZiAoJHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcbiAgICAgICAgICB2YXIgc2V0dGluZ3MgPSAkc2NvcGUuY29tcG9uZW50O1xuICAgICAgICAgIHZhciBwYXJhbXMgPSBzZXR0aW5ncy5wYXJhbXMgfHwge307XG4gICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gW107XG4gICAgICAgICAgJHNjb3BlLmhhc05leHRQYWdlID0gZmFsc2U7XG4gICAgICAgICAgJHNjb3BlLnJlc291cmNlTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHBhcmFtcy5saW1pdCA9IDEwMDtcbiAgICAgICAgICBwYXJhbXMuc2tpcCA9IDA7XG4gICAgICAgICAgaWYgKHNldHRpbmdzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWZhdWx0VmFsdWUgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNldHRpbmdzLnJlc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gJyc7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MucHJvamVjdCkge1xuICAgICAgICAgICAgICB1cmwgKz0gJy9wcm9qZWN0LycgKyBzZXR0aW5ncy5wcm9qZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJHNjb3BlLmZvcm1pbyAmJiAkc2NvcGUuZm9ybWlvLnByb2plY3RVcmwpIHtcbiAgICAgICAgICAgICAgdXJsICs9ICRzY29wZS5mb3JtaW8ucHJvamVjdFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybCArPSAnL2Zvcm0vJyArIHNldHRpbmdzLnJlc291cmNlO1xuICAgICAgICAgICAgdmFyIGZvcm1pbyA9IG5ldyBGb3JtaW8odXJsKTtcblxuICAgICAgICAgICAgLy8gUmVmcmVzaCB0aGUgaXRlbXMuXG4gICAgICAgICAgICAkc2NvcGUucmVmcmVzaFN1Ym1pc3Npb25zID0gZnVuY3Rpb24oaW5wdXQsIGFwcGVuZCkge1xuICAgICAgICAgICAgICBpZiAoJHNjb3BlLnJlc291cmNlTG9hZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkc2NvcGUucmVzb3VyY2VMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gSWYgdGhleSB3aXNoIHRvIHJldHVybiBvbmx5IHNvbWUgZmllbGRzLlxuICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2VsZWN0RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnNlbGVjdCA9IHNldHRpbmdzLnNlbGVjdEZpZWxkcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2VhcmNoRmllbGRzICYmIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNldHRpbmdzLnNlYXJjaEZpZWxkcywgZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmFtc1tmaWVsZF0gPSBpbnB1dDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIExvYWQgdGhlIHN1Ym1pc3Npb25zLlxuICAgICAgICAgICAgICBmb3JtaW8ubG9hZFN1Ym1pc3Npb25zKHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHN1Ym1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgc3VibWlzc2lvbnMgPSBzdWJtaXNzaW9ucyB8fCBbXTtcbiAgICAgICAgICAgICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZWN0SXRlbXMgPSAkc2NvcGUuc2VsZWN0SXRlbXMuY29uY2F0KHN1Ym1pc3Npb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZWN0SXRlbXMgPSBzdWJtaXNzaW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmhhc05leHRQYWdlID0gKHN1Ym1pc3Npb25zLmxlbmd0aCA+PSBwYXJhbXMubGltaXQpICYmICgkc2NvcGUuc2VsZWN0SXRlbXMubGVuZ3RoIDwgc3VibWlzc2lvbnMuc2VydmVyQ291bnQpO1xuICAgICAgICAgICAgICB9KVsnZmluYWxseSddKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5yZXNvdXJjZUxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBMb2FkIG1vcmUgaXRlbXMuXG4gICAgICAgICAgICAkc2NvcGUubG9hZE1vcmVJdGVtcyA9IGZ1bmN0aW9uKCRzZWxlY3QsICRldmVudCkge1xuICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBwYXJhbXMuc2tpcCArPSBwYXJhbXMubGltaXQ7XG4gICAgICAgICAgICAgICRzY29wZS5yZWZyZXNoU3VibWlzc2lvbnMobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkc2NvcGUucmVmcmVzaFN1Ym1pc3Npb25zKCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIG5ldyByZXNvdXJjZS5cbiAgICAgICAgICAgICRzY29wZS5uZXdSZXNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgID0gJzxicj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicm93XCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY29sLXNtLTEyXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJwYW5lbCBwYW5lbC1kZWZhdWx0XCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBhbmVsLWhlYWRpbmdcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxoMyBjbGFzcz1cInBhbmVsLXRpdGxlXCI+e3sgY29tcG9uZW50LmFkZFJlc291cmNlTGFiZWwgfHwgXCJBZGQgUmVzb3VyY2VcIiB8IGZvcm1pb1RyYW5zbGF0ZX19PC9oMz4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGZvcm1pbyBzcmM9XCJmb3JtVXJsXCI+PC9mb3JtaW8+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JztcblxuICAgICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgcGxhaW46IHRydWUsXG4gICAgICAgICAgICAgICAgc2NvcGU6ICRzY29wZSxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBbJyRzY29wZScsIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1VcmwgPSAkc2NvcGUuZm9ybWlvLmZvcm1zVXJsICsgJy8nICsgJHNjb3BlLmNvbXBvbmVudC5yZXNvdXJjZTtcblxuICAgICAgICAgICAgICAgICAgLy8gQmluZCB3aGVuIHRoZSBmb3JtIGlzIGxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJ2Zvcm1Mb2FkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIERvbid0IGNvbmZ1c2UgYXBwXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgLy8gQmluZCB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJ2Zvcm1TdWJtaXNzaW9uJywgZnVuY3Rpb24oZXZlbnQsIHN1Ym1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9ICRzY29wZS5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhICAgICAgPSAkc2NvcGUuZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YVtjb21wb25lbnQua2V5XS5wdXNoKHN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGFbY29tcG9uZW50LmtleV0gPSBzdWJtaXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hTdWJtaXNzaW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUaGlzRGlhbG9nKHN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfSkuY2xvc2VQcm9taXNlLnRoZW4oZnVuY3Rpb24oLyplKi8pIHtcbiAgICAgICAgICAgICAgLy92YXIgY2FuY2VsbGVkID0gZS52YWx1ZSA9PT0gZmFsc2UgfHwgZS52YWx1ZSA9PT0gJyRjbG9zZUJ1dHRvbicgfHwgZS52YWx1ZSA9PT0gJyRkb2N1bWVudCc7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ2xvc2UgYWxsIG9wZW4gZGlhbG9ncyBvbiBzdGF0ZSBjaGFuZ2UgKHVzaW5nIFVJLVJvdXRlcikuXG4gICAgICAgICAgICAkc2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBuZ0RpYWxvZy5jbG9zZUFsbChmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2xvc2UgYWxsIG9wZW4gZGlhbG9ncyBvbiByb3V0ZSBjaGFuZ2UgKHVzaW5nIG5nUm91dGUpLlxuICAgICAgICAgICAgJHNjb3BlLiRvbignJHJvdXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgbmdEaWFsb2cuY2xvc2VBbGwoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgZ3JvdXA6ICdhZHZhbmNlZCcsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgaW5wdXQ6IHRydWUsXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxuICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICBrZXk6ICdyZXNvdXJjZUZpZWxkJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgICAgcmVzb3VyY2U6ICcnLFxuICAgICAgICAgIHByb2plY3Q6ICcnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJycsXG4gICAgICAgICAgdGVtcGxhdGU6ICc8c3Bhbj57eyBpdGVtLmRhdGEgfX08L3NwYW4+JyxcbiAgICAgICAgICBzZWxlY3RGaWVsZHM6ICcnLFxuICAgICAgICAgIHNlYXJjaEZpZWxkczogJycsXG4gICAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcbiAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxuICAgICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHRQZXJtaXNzaW9uOiAnJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIF0pO1xuXG4gIGFwcC5ydW4oW1xuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvcmVzb3VyY2UuaHRtbCcsXG4gICAgICAgIFwiPGRpdiBuZy1pZj1cXFwiIWNvbXBvbmVudC5hZGRSZXNvdXJjZVxcXCI+XFxuICA8bGFiZWwgbmctaWY9XFxcImNvbXBvbmVudC5sYWJlbCAmJiAhY29tcG9uZW50LmhpZGVMYWJlbFxcXCIgZm9yPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxuICA8c3BhbiBuZy1pZj1cXFwiIWNvbXBvbmVudC5sYWJlbCAmJiBpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWFzdGVyaXNrIGZvcm0tY29udHJvbC1mZWVkYmFjayBmaWVsZC1yZXF1aXJlZC1pbmxpbmVcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L3NwYW4+XFxuICA8dWktc2VsZWN0IHVpLXNlbGVjdC1yZXF1aXJlZCBzYWZlLW11bHRpcGxlLXRvLXNpbmdsZSB1aS1zZWxlY3Qtb3Blbi1vbi1mb2N1cyBuZy1tb2RlbD1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCIgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIiBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIiBpZD1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIG5hbWU9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIiB0aGVtZT1cXFwiYm9vdHN0cmFwXFxcIiB0YWJpbmRleD1cXFwie3sgY29tcG9uZW50LnRhYmluZGV4IHx8IDAgfX1cXFwiPlxcbiAgICA8dWktc2VsZWN0LW1hdGNoIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eyBjb21wb25lbnQucGxhY2Vob2xkZXIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19XFxcIj5cXG4gICAgICA8Zm9ybWlvLXNlbGVjdC1pdGVtIHRlbXBsYXRlPVxcXCJjb21wb25lbnQudGVtcGxhdGVcXFwiIGl0ZW09XFxcIiRpdGVtIHx8ICRzZWxlY3Quc2VsZWN0ZWRcXFwiIHNlbGVjdD1cXFwiJHNlbGVjdFxcXCI+PC9mb3JtaW8tc2VsZWN0LWl0ZW0+XFxuICAgIDwvdWktc2VsZWN0LW1hdGNoPlxcbiAgICA8dWktc2VsZWN0LWNob2ljZXMgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzXFxcIiByZXBlYXQ9XFxcIml0ZW0gaW4gc2VsZWN0SXRlbXMgfCBmaWx0ZXI6ICRzZWxlY3Quc2VhcmNoXFxcIiByZWZyZXNoPVxcXCJyZWZyZXNoU3VibWlzc2lvbnMoJHNlbGVjdC5zZWFyY2gpXFxcIiByZWZyZXNoLWRlbGF5PVxcXCIyNTBcXFwiPlxcbiAgICAgIDxmb3JtaW8tc2VsZWN0LWl0ZW0gdGVtcGxhdGU9XFxcImNvbXBvbmVudC50ZW1wbGF0ZVxcXCIgaXRlbT1cXFwiaXRlbVxcXCIgc2VsZWN0PVxcXCIkc2VsZWN0XFxcIj48L2Zvcm1pby1zZWxlY3QtaXRlbT5cXG4gICAgICA8YnV0dG9uIG5nLWlmPVxcXCJoYXNOZXh0UGFnZSAmJiAoJGluZGV4ID09ICRzZWxlY3QuaXRlbXMubGVuZ3RoLTEpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zdWNjZXNzIGJ0bi1ibG9ja1xcXCIgbmctY2xpY2s9XFxcImxvYWRNb3JlSXRlbXMoJHNlbGVjdCwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcInJlc291cmNlTG9hZGluZ1xcXCI+TG9hZCBtb3JlLi4uPC9idXR0b24+XFxuICAgIDwvdWktc2VsZWN0LWNob2ljZXM+XFxuICA8L3VpLXNlbGVjdD5cXG4gIDxmb3JtaW8tZXJyb3JzIG5nLWlmPVxcXCI6OiFidWlsZGVyXFxcIj48L2Zvcm1pby1lcnJvcnM+XFxuPC9kaXY+XFxuPGRpdiBuZy1pZj1cXFwiY29tcG9uZW50LmFkZFJlc291cmNlXFxcIj5cXG4gIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtYm9yZGVyZWRcXFwiPlxcbiAgICA8bGFiZWwgbmctaWY9XFxcImNvbXBvbmVudC5sYWJlbCAmJiAhY29tcG9uZW50LmhpZGVMYWJlbFxcXCIgZm9yPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxuICAgIDxzcGFuIG5nLWlmPVxcXCIhY29tcG9uZW50LmxhYmVsICYmIGlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tYXN0ZXJpc2sgZm9ybS1jb250cm9sLWZlZWRiYWNrIGZpZWxkLXJlcXVpcmVkLWlubGluZVxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvc3Bhbj5cXG4gICAgPHRyPlxcbiAgICAgIDx0ZD5cXG4gICAgICAgIDx1aS1zZWxlY3QgdWktc2VsZWN0LXJlcXVpcmVkIHNhZmUtbXVsdGlwbGUtdG8tc2luZ2xlIHVpLXNlbGVjdC1vcGVuLW9uLWZvY3VzIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIiBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiIG5nLXJlcXVpcmVkPVxcXCJpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIHRoZW1lPVxcXCJib290c3RyYXBcXFwiIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCI+XFxuICAgICAgICAgIDx1aS1zZWxlY3QtbWF0Y2ggY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXFwiPlxcbiAgICAgICAgICAgIDxmb3JtaW8tc2VsZWN0LWl0ZW0gdGVtcGxhdGU9XFxcImNvbXBvbmVudC50ZW1wbGF0ZVxcXCIgaXRlbT1cXFwiJGl0ZW0gfHwgJHNlbGVjdC5zZWxlY3RlZFxcXCIgc2VsZWN0PVxcXCIkc2VsZWN0XFxcIj48L2Zvcm1pby1zZWxlY3QtaXRlbT5cXG4gICAgICAgICAgPC91aS1zZWxlY3QtbWF0Y2g+XFxuICAgICAgICAgIDx1aS1zZWxlY3QtY2hvaWNlcyBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXNcXFwiIHJlcGVhdD1cXFwiaXRlbSBpbiBzZWxlY3RJdGVtcyB8IGZpbHRlcjogJHNlbGVjdC5zZWFyY2hcXFwiIHJlZnJlc2g9XFxcInJlZnJlc2hTdWJtaXNzaW9ucygkc2VsZWN0LnNlYXJjaClcXFwiIHJlZnJlc2gtZGVsYXk9XFxcIjI1MFxcXCI+XFxuICAgICAgICAgICAgPGZvcm1pby1zZWxlY3QtaXRlbSB0ZW1wbGF0ZT1cXFwiY29tcG9uZW50LnRlbXBsYXRlXFxcIiBpdGVtPVxcXCJpdGVtXFxcIiBzZWxlY3Q9XFxcIiRzZWxlY3RcXFwiPjwvZm9ybWlvLXNlbGVjdC1pdGVtPlxcbiAgICAgICAgICAgIDxidXR0b24gbmctaWY9XFxcImhhc05leHRQYWdlICYmICgkaW5kZXggPT0gJHNlbGVjdC5pdGVtcy5sZW5ndGgtMSlcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3MgYnRuLWJsb2NrXFxcIiBuZy1jbGljaz1cXFwibG9hZE1vcmVJdGVtcygkc2VsZWN0LCAkZXZlbnQpXFxcIiBuZy1kaXNhYmxlZD1cXFwicmVzb3VyY2VMb2FkaW5nXFxcIj5Mb2FkIG1vcmUuLi48L2J1dHRvbj5cXG4gICAgICAgICAgPC91aS1zZWxlY3QtY2hvaWNlcz5cXG4gICAgICAgIDwvdWktc2VsZWN0PlxcbiAgICAgICAgPGZvcm1pby1lcnJvcnMgbmctaWY9XFxcIjo6IWJ1aWxkZXJcXFwiPjwvZm9ybWlvLWVycm9ycz5cXG4gICAgICA8L3RkPlxcbiAgICA8L3RyPlxcbiAgICA8dHI+XFxuICAgICAgPHRkPlxcbiAgICAgICAgPGEgbmctY2xpY2s9XFxcIm5ld1Jlc291cmNlKClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9zcGFuPiB7eyBjb21wb25lbnQuYWRkUmVzb3VyY2VMYWJlbCB8fCBcXFwiQWRkIFJlc291cmNlXFxcIiB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXJ9fVxcbiAgICAgICAgPC9hPlxcbiAgICAgIDwvdGQ+XFxuICAgIDwvdHI+XFxuICA8L3RhYmxlPlxcbjwvZGl2PlxcblwiXG4gICAgICApO1xuXG4gICAgICAvLyBDaGFuZ2UgdGhlIHVpLXNlbGVjdCB0byB1aS1zZWxlY3QgbXVsdGlwbGUuXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3Jlc291cmNlLW11bHRpcGxlLmh0bWwnLFxuICAgICAgICAkdGVtcGxhdGVDYWNoZS5nZXQoJ2Zvcm1pby9jb21wb25lbnRzL3Jlc291cmNlLmh0bWwnKS5yZXBsYWNlKC88dWktc2VsZWN0XFxzL2csICc8dWktc2VsZWN0IG11bHRpcGxlICcpXG4gICAgICApO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKmVzbGludCBtYXgtZGVwdGg6IFtcImVycm9yXCIsIDZdKi9cblxudmFyIF9nZXQgPSByZXF1aXJlKCdsb2Rhc2gvZ2V0Jyk7XG52YXIgX2lzRXF1YWwgPSByZXF1aXJlKCdsb2Rhc2gvaXNFcXVhbCcpO1xudmFyIF9zZXQgPSByZXF1aXJlKCdsb2Rhc2gvc2V0Jyk7XG52YXIgX2Nsb25lRGVlcCA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZURlZXAnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5kaXJlY3RpdmUoJ2Zvcm1pb1NlbGVjdEl0ZW0nLCBbXG4gICAgJyRjb21waWxlJyxcbiAgICBmdW5jdGlvbigkY29tcGlsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICB0ZW1wbGF0ZTogJz0nLFxuICAgICAgICAgIGl0ZW06ICc9JyxcbiAgICAgICAgICBzZWxlY3Q6ICc9J1xuICAgICAgICB9LFxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xuICAgICAgICAgIGlmIChzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgICAgaWYgKHNjb3BlLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZCgkY29tcGlsZShhbmd1bGFyLmVsZW1lbnQoc2NvcGUudGVtcGxhdGUpKShzY29wZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIF0pO1xuXG4gIGFwcC5kaXJlY3RpdmUoJ3VpU2VsZWN0UmVxdWlyZWQnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XG4gICAgICAgIGlmIChzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgIHZhciBvbGRJc0VtcHR5ID0gbmdNb2RlbC4kaXNFbXB0eTtcbiAgICAgICAgbmdNb2RlbC4kaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHx8IG9sZElzRW1wdHkodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIEEgZGlyZWN0aXZlIHRvIGhhdmUgdWktc2VsZWN0IG9wZW4gb24gZm9jdXNcbiAgYXBwLmRpcmVjdGl2ZSgndWlTZWxlY3RPcGVuT25Gb2N1cycsIFtmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZTogJ3VpU2VsZWN0JyxcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsIGVsLCBhdHRycywgdWlTZWxlY3QpIHtcbiAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgIHZhciBmb2N1c2NvdW50ID0gLTE7XG5cbiAgICAgICAgYW5ndWxhci5lbGVtZW50KHVpU2VsZWN0LmZvY3Vzc2VyKS5vbignZm9jdXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoZm9jdXNjb3VudC0tIDwgMCkge1xuICAgICAgICAgICAgdWlTZWxlY3QuYWN0aXZhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERpc2FibGUgdGhlIGF1dG8gb3BlbiB3aGVuIHRoaXMgc2VsZWN0IGVsZW1lbnQgaGFzIGJlZW4gYWN0aXZhdGVkLlxuICAgICAgICAkc2NvcGUuJG9uKCd1aXM6YWN0aXZhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb2N1c2NvdW50ID0gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmUtZW5hYmxlIHRoZSBhdXRvIG9wZW4gYWZ0ZXIgdGhlIHNlbGVjdCBlbGVtZW50IGhhcyBiZWVuIGNsb3NlZFxuICAgICAgICAkc2NvcGUuJG9uKCd1aXM6Y2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb2N1c2NvdW50ID0gMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xuXG4gIC8vIENvbmZpZ3VyZSB0aGUgU2VsZWN0IGNvbXBvbmVudC5cbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3NlbGVjdCcsIHtcbiAgICAgICAgdGl0bGU6ICdTZWxlY3QnLFxuICAgICAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgcmV0dXJuICRzY29wZS5jb21wb25lbnQubXVsdGlwbGUgPyAnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0LW11bHRpcGxlLmh0bWwnIDogJ2Zvcm1pby9jb21wb25lbnRzL3NlbGVjdC5odG1sJztcbiAgICAgICAgfSxcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSkge1xuICAgICAgICAgIHZhciBnZXRJdGVtID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgc3dpdGNoIChjb21wb25lbnQuZGF0YVNyYykge1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZXMnOlxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5kYXRhLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnZhbHVlID09PSBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LnZhbHVlUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RJdGVtcztcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zID0gYW5ndWxhci5mcm9tSnNvbihjb21wb25lbnQuZGF0YS5qc29uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2VsZWN0SXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtW2NvbXBvbmVudC52YWx1ZVByb3BlcnR5XSA9PT0gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCB1cmwgYW5kIHJlc291cmNlIHZpZXcuXG4gICAgICAgICAgICAgIGNhc2UgJ3VybCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3Jlc291cmNlJzpcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChjb21wb25lbnQubXVsdGlwbGUgJiYgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGdldEl0ZW0pLnJlZHVjZShmdW5jdGlvbihwcmV2LCBpdGVtKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJGludGVycG9sYXRlKGNvbXBvbmVudC50ZW1wbGF0ZSkoe2l0ZW06IGl0ZW19KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIChwcmV2ID09PSAnJyA/ICcnIDogJywgJykgKyB2YWx1ZTtcbiAgICAgICAgICAgIH0sICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEl0ZW0oZGF0YSk7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gJGludGVycG9sYXRlKGNvbXBvbmVudC50ZW1wbGF0ZSkoe2l0ZW06IGl0ZW19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb250cm9sbGVyOiBbXG4gICAgICAgICAgJyRyb290U2NvcGUnLFxuICAgICAgICAgICckc2NvcGUnLFxuICAgICAgICAgICckaHR0cCcsXG4gICAgICAgICAgJ0Zvcm1pbycsXG4gICAgICAgICAgJyRpbnRlcnBvbGF0ZScsXG4gICAgICAgICAgJyRxJyxcbiAgICAgICAgICAnJHRpbWVvdXQnLFxuICAgICAgICAgIGZ1bmN0aW9uKFxuICAgICAgICAgICAgJHJvb3RTY29wZSxcbiAgICAgICAgICAgICRzY29wZSxcbiAgICAgICAgICAgICRodHRwLFxuICAgICAgICAgICAgRm9ybWlvLFxuICAgICAgICAgICAgJGludGVycG9sYXRlLFxuICAgICAgICAgICAgJHEsXG4gICAgICAgICAgICAkdGltZW91dFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gRk9SLTcxIC0gU2tpcCBmdW5jdGlvbmFsaXR5IGluIHRoZSBidWlsZGVyIHZpZXcuXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9ICRzY29wZS5jb21wb25lbnQ7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgJHNjb3BlLm5vd3JhcCA9IHRydWU7XG4gICAgICAgICAgICAkc2NvcGUuaGFzTmV4dFBhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICRzY29wZS5zZWxlY3RJdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ3NlbGVjdExvYWRlZCcsICRzY29wZS5jb21wb25lbnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RWYWx1ZXMgPSAkc2NvcGUuY29tcG9uZW50LnNlbGVjdFZhbHVlcztcbiAgICAgICAgICAgIHZhciB2YWx1ZVByb3AgPSAkc2NvcGUuY29tcG9uZW50LnZhbHVlUHJvcGVydHk7XG4gICAgICAgICAgICAkc2NvcGUuZ2V0U2VsZWN0SXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kYXRhU3JjID09PSAndmFsdWVzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpdGVtIHZhbHVlLlxuICAgICAgICAgICAgICB2YXIgaXRlbVZhbHVlID0gdmFsdWVQcm9wID8gX2dldChpdGVtLCB2YWx1ZVByb3ApIDogaXRlbTtcbiAgICAgICAgICAgICAgaWYgKGl0ZW1WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IGZpbmQgdmFsdWUgcHJvcGVydHkgd2l0aGluIHNlbGVjdDogJyArIHZhbHVlUHJvcCk7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1WYWx1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICRzY29wZS5yZWZyZXNoSXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICRxLnJlc29sdmUoW10pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICRzY29wZS4kb24oJ3JlZnJlc2hMaXN0JywgZnVuY3Rpb24oZXZlbnQsIHVybCwgaW5wdXQpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hJdGVtcyhpbnB1dCwgdXJsKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcmVmcmVzaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJlZnJlc2hWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAocmVmcmVzaGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWZyZXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIHRlbXBEYXRhID0gJHNjb3BlLmRhdGFbc2V0dGluZ3Mua2V5XTtcbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbc2V0dGluZ3Mua2V5XSA9IHNldHRpbmdzLm11bHRpcGxlID8gW10gOiAnJztcbiAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5jbGVhck9uUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbc2V0dGluZ3Mua2V5XSA9IHRlbXBEYXRhO1xuICAgICAgICAgICAgICAgICAgcmVmcmVzaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzZWxlY3RMb2FkZWQnLCAkc2NvcGUuY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzZWxlY3RMb2FkZWQnLCAkc2NvcGUuY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gRW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyB3aXRoaW4gdGhlIHNlbGVjdCBpdGVtcy5cbiAgICAgICAgICAgIHZhciBlbnN1cmVWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAkc2NvcGUuZGF0YVtzZXR0aW5ncy5rZXldO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiBpdGVtcyBhbmQgc2VlIGlmIG91ciB2YWx1ZSBleGlzdHMuLi5cbiAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8ICRzY29wZS5zZWxlY3RJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gJHNjb3BlLnNlbGVjdEl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RJdGVtID0gJHNjb3BlLmdldFNlbGVjdEl0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKF9pc0VxdWFsKHNlbGVjdEl0ZW0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGl0ZW0gaXMgbm90IGZvdW5kIGluIHRoZSBzZWxlY3QgaXRlbXMgYXJyYXksIHRoZW4gYWRkIGl0IG1hbnVhbGx5LlxuICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1WYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVByb3ApIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW1WYWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgX3NldChpdGVtVmFsdWUsIHZhbHVlUHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZWN0SXRlbXMucHVzaChpdGVtVmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBSZWZyZXNoIHRoZSBpdGVtcyB3aGVuIHJlYWR5LlxuICAgICAgICAgICAgdmFyIHJlZnJlc2hJdGVtc1doZW5SZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpbml0aWFsaXplZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZnJlc2hQcm9taXNlID0gJHNjb3BlLnJlZnJlc2hJdGVtcyh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgIHJlZnJlc2hQcm9taXNlLnRoZW4ocmVmcmVzaFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZWZyZXNoVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQWRkIGEgd2F0Y2ggaWYgdGhleSB3aXNoIHRvIHJlZnJlc2ggb24gc2VsZWN0aW9uIG9mIGFub3RoZXIgZmllbGQuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MucmVmcmVzaE9uKSB7XG4gICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5yZWZyZXNoT24gPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2RhdGEnLCByZWZyZXNoSXRlbXNXaGVuUmVhZHksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2RhdGEuJyArIHNldHRpbmdzLnJlZnJlc2hPbiwgcmVmcmVzaEl0ZW1zV2hlblJlYWR5KTtcbiAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaCgnc3VibWlzc2lvbi5kYXRhLicgKyBzZXR0aW5ncy5yZWZyZXNoT24sIHJlZnJlc2hJdGVtc1doZW5SZWFkeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2F0Y2ggZm9yIHRoZSBkYXRhIHRvIGJlIHNldCwgYW5kIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IHByb3Blcmx5LlxuICAgICAgICAgICAgICB2YXIgZGF0YVdhdGNoID0gJHNjb3BlLiR3YXRjaCgnZGF0YS4nICsgc2V0dGluZ3Mua2V5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhV2F0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmRhdGFTcmMpIHtcbiAgICAgICAgICAgICAgY2FzZSAndmFsdWVzJzpcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZWN0SXRlbXMgPSBzZXR0aW5ncy5kYXRhLnZhbHVlcztcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgIHZhciBpdGVtcztcblxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgbmV3IHJlc3VsdC5cbiAgICAgICAgICAgICAgICB2YXIgc2V0UmVzdWx0ID0gZnVuY3Rpb24oZGF0YSwgYXBwZW5kKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjb2VyY2UgdGhlIGRhdGEgaW50byBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgb3B0aW9ucy5wYXJhbXMubGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmhhc05leHRQYWdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zZWxlY3RJdGVtcyA9ICRzY29wZS5zZWxlY3RJdGVtcy5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgJHNjb3BlLmNvbXBvbmVudC5kYXRhLmpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gYW5ndWxhci5mcm9tSnNvbigkc2NvcGUuY29tcG9uZW50LmRhdGEuanNvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgJHNjb3BlLmNvbXBvbmVudC5kYXRhLmpzb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gJHNjb3BlLmNvbXBvbmVudC5kYXRhLmpzb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBkb3Qgbm90YXRpb24gaW4gdGhlIHNlbGVjdFZhbHVlIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0VmFsdWVzLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBzZWxlY3RWYWx1ZXMuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ID0gaXRlbXM7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ID0gc2VsZWN0W3BhcnRzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBzZWxlY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBpdGVtc1tzZWxlY3RWYWx1ZXNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBwYXJzaW5nIEpTT04gaW4gJyArICRzY29wZS5jb21wb25lbnQua2V5LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgbGltaXQ6ICRzY29wZS5jb21wb25lbnQubGltaXQgfHwgMjAsXG4gICAgICAgICAgICAgICAgICBza2lwOiAwXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBsYXN0SW5wdXQ7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hJdGVtcyA9IGZ1bmN0aW9uKGlucHV0LCB1cmwsIGFwcGVuZCkge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgdGhleSB0eXBlZCBpbiBhIHNlYXJjaCwgcmVzZXQgc2tpcC5cbiAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5wdXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5za2lwID0gMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RJdGVtcyA9IGl0ZW1zO1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zID0gc2VsZWN0SXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHZpc2libGUgc3RyaW5nIGZyb20gdGhlIGludGVycG9sYXRlZCBpdGVtLlxuICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICRpbnRlcnBvbGF0ZSgkc2NvcGUuY29tcG9uZW50LnRlbXBsYXRlKSh7aXRlbTogaXRlbX0pLnJlcGxhY2UoLzwoPzoufFxcbikqPz4vZ20sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCRzY29wZS5jb21wb25lbnQuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihpbnB1dC50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250YWlucyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS5sYXN0SW5kZXhPZihpbnB1dC50b0xvd2VyQ2FzZSgpLCAwKSA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMuc2tpcCA9IHBhcnNlSW50KG9wdGlvbnMucGFyYW1zLnNraXAsIDEwKTtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLmxpbWl0ID0gcGFyc2VJbnQob3B0aW9ucy5wYXJhbXMubGltaXQsIDEwKTtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zID0gc2VsZWN0SXRlbXMuc2xpY2Uob3B0aW9ucy5wYXJhbXMuc2tpcCwgb3B0aW9ucy5wYXJhbXMuc2tpcCArIG9wdGlvbnMucGFyYW1zLmxpbWl0KTtcbiAgICAgICAgICAgICAgICAgIHNldFJlc3VsdChzZWxlY3RJdGVtcywgYXBwZW5kKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsaXplZC5yZXNvbHZlKCRzY29wZS5zZWxlY3RJdGVtcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVmcmVzaEl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfY2xvbmVEZWVwKCRzY29wZS5zdWJtaXNzaW9uLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gX2Nsb25lRGVlcCgkc2NvcGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gZXZhbCgnKGZ1bmN0aW9uKGRhdGEsIHJvdykgeyB2YXIgdmFsdWVzID0gW107JyArIHNldHRpbmdzLmRhdGEuY3VzdG9tLnRvU3RyaW5nKCkgKyAnOyByZXR1cm4gdmFsdWVzOyB9KShkYXRhLCByb3cpJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZWQucmVzb2x2ZSgkc2NvcGUuc2VsZWN0SXRlbXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hJdGVtcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICd1cmwnOlxuICAgICAgICAgICAgICBjYXNlICdyZXNvdXJjZSc6XG4gICAgICAgICAgICAgICAgdmFyIHVybCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kYXRhU3JjID09PSAndXJsJykge1xuICAgICAgICAgICAgICAgICAgdXJsID0gc2V0dGluZ3MuZGF0YS51cmw7XG4gICAgICAgICAgICAgICAgICBpZiAodXJsLnN1YnN0cigwLCAxKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IEZvcm1pby5nZXRCYXNlVXJsKCkgKyBzZXR0aW5ncy5kYXRhLnVybDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBhdXRoIGZvciBvdXRnb2luZyByZXF1ZXN0cy5cbiAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYXV0aGVudGljYXRlICYmIHVybC5pbmRleE9mKEZvcm1pby5nZXRCYXNlVXJsKCkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRpc2FibGVKV1QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMuUHJhZ21hID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0NhY2hlLUNvbnRyb2wnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB1cmwgPSBGb3JtaW8uZ2V0QmFzZVVybCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRhdGEucHJvamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gJy9wcm9qZWN0LycgKyBzZXR0aW5ncy5kYXRhLnByb2plY3Q7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB1cmwgKz0gJy9mb3JtLycgKyBzZXR0aW5ncy5kYXRhLnJlc291cmNlICsgJy9zdWJtaXNzaW9uJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgIGxpbWl0OiAkc2NvcGUuY29tcG9uZW50LmxpbWl0IHx8IDEwMCxcbiAgICAgICAgICAgICAgICAgIHNraXA6IDBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmxvYWRNb3JlSXRlbXMgPSBmdW5jdGlvbigkc2VsZWN0LCAkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMuc2tpcCA9IHBhcnNlSW50KG9wdGlvbnMucGFyYW1zLnNraXAsIDEwKTtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLnNraXAgKz0gcGFyc2VJbnQob3B0aW9ucy5wYXJhbXMubGltaXQsIDEwKTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5yZWZyZXNoSXRlbXModHJ1ZSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5oYXNOZXh0UGFnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUucmVmcmVzaEl0ZW1zID0gZnVuY3Rpb24oaW5wdXQsIG5ld1VybCwgYXBwZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBuZXdVcmwgPSBuZXdVcmwgfHwgdXJsO1xuICAgICAgICAgICAgICAgICAgICBuZXdVcmwgPSAkaW50ZXJwb2xhdGUobmV3VXJsKSh7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogJHNjb3BlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgZm9ybWlvQmFzZTogJHJvb3RTY29wZS5hcGlCYXNlIHx8ICdodHRwczovL2FwaS5mb3JtLmlvJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc2VhcmNoLCB0aGVuIGFkZCB0aGF0IHRvIHRoZSBmaWx0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5zZWFyY2hGaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIG5ld1VybCArPSAoKG5ld1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHNldHRpbmdzLnNlYXJjaEZpZWxkKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgb3RoZXIgZmlsdGVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9ICRpbnRlcnBvbGF0ZShzZXR0aW5ncy5maWx0ZXIpKHtkYXRhOiAkc2NvcGUuZGF0YX0pO1xuICAgICAgICAgICAgICAgICAgICAgIG5ld1VybCArPSAoKG5ld1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBmaWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IHdpc2ggdG8gcmV0dXJuIG9ubHkgc29tZSBmaWVsZHMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zZWxlY3RGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5zZWxlY3QgPSBzZXR0aW5ncy5zZWxlY3RGaWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIG5ldyByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXRSZXN1bHQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY29lcmNlIHRoZSBkYXRhIGludG8gYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCBvcHRpb25zLnBhcmFtcy5saW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmhhc05leHRQYWdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChhcHBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zZWxlY3RJdGVtcyA9ICRzY29wZS5zZWxlY3RJdGVtcy5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHZhbHVlIGlzIHNldCB0byB3aGF0IGl0IHNob3VsZCBiZSBzZXQgdG8uXG4gICAgICAgICAgICAgICAgICAgICAgZW5zdXJlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KG5ld1VybCwgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0VmFsdWUgcHJvcCBpcyBkZWZpbmVkLCB1c2UgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlc3VsdChfZ2V0KGRhdGEsIHNlbGVjdFZhbHVlcywgW10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZGVmYXVsdCB0byB0aGUgZm9ybWlvIHNldHRpbmdzIGZvciBhIHJlc291cmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlc3VsdChkYXRhLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnaXRlbXMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQoZGF0YS5pdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRhdGEgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlc3VsdChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzY29wZS5zZWxlY3RJdGVtcztcbiAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplZC5yZXNvbHZlKCRzY29wZS5zZWxlY3RJdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5yZWZyZXNoSXRlbXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuc3VyZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQucmVzb2x2ZSgkc2NvcGUuc2VsZWN0SXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXG4gICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgIGtleTogJ3NlbGVjdEZpZWxkJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGpzb246ICcnLFxuICAgICAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgICAgIHJlc291cmNlOiAnJyxcbiAgICAgICAgICAgIGN1c3RvbTogJydcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGFTcmM6ICd2YWx1ZXMnLFxuICAgICAgICAgIHZhbHVlUHJvcGVydHk6ICcnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJycsXG4gICAgICAgICAgcmVmcmVzaE9uOiAnJyxcbiAgICAgICAgICBmaWx0ZXI6ICcnLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogZmFsc2UsXG4gICAgICAgICAgdGVtcGxhdGU6ICc8c3Bhbj57eyBpdGVtLmxhYmVsIH19PC9zcGFuPicsXG4gICAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXG4gICAgICAgICAgdW5pcXVlOiBmYWxzZSxcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXG4gICAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9zZWxlY3QuaHRtbCcsXG4gICAgICAgIFwiPGxhYmVsIG5nLWlmPVxcXCJjb21wb25lbnQubGFiZWwgJiYgIWNvbXBvbmVudC5oaWRlTGFiZWxcXFwiICBmb3I9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCIgbmctY2xhc3M9XFxcInsnZmllbGQtcmVxdWlyZWQnOiBpc1JlcXVpcmVkKGNvbXBvbmVudCl9XFxcIj57eyBjb21wb25lbnQubGFiZWwgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9sYWJlbD5cXG48c3BhbiBuZy1pZj1cXFwiIWNvbXBvbmVudC5sYWJlbCAmJiBpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWFzdGVyaXNrIGZvcm0tY29udHJvbC1mZWVkYmFjayBmaWVsZC1yZXF1aXJlZC1pbmxpbmVcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L3NwYW4+XFxuPHVpLXNlbGVjdFxcbiAgdWktc2VsZWN0LXJlcXVpcmVkXFxuICB1aS1zZWxlY3Qtb3Blbi1vbi1mb2N1c1xcbiAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiXFxuICBzYWZlLW11bHRpcGxlLXRvLXNpbmdsZVxcbiAgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxuICBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiXFxuICBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIlxcbiAgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcbiAgdGhlbWU9XFxcImJvb3RzdHJhcFxcXCJcXG4gIGN1c3RvbS12YWxpZGF0b3I9XFxcImNvbXBvbmVudC52YWxpZGF0ZS5jdXN0b21cXFwiXFxuICB0YWJpbmRleD1cXFwie3sgY29tcG9uZW50LnRhYmluZGV4IHx8IDAgfX1cXFwiXFxuPlxcbiAgPHVpLXNlbGVjdC1tYXRjaCBjbGFzcz1cXFwidWktc2VsZWN0LW1hdGNoXFxcIiBwbGFjZWhvbGRlcj1cXFwie3sgY29tcG9uZW50LnBsYWNlaG9sZGVyIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcXCI+XFxuICAgIDxmb3JtaW8tc2VsZWN0LWl0ZW0gdGVtcGxhdGU9XFxcImNvbXBvbmVudC50ZW1wbGF0ZVxcXCIgaXRlbT1cXFwiJGl0ZW0gfHwgJHNlbGVjdC5zZWxlY3RlZFxcXCIgc2VsZWN0PVxcXCIkc2VsZWN0XFxcIj48L2Zvcm1pby1zZWxlY3QtaXRlbT5cXG4gIDwvdWktc2VsZWN0LW1hdGNoPlxcbiAgPHVpLXNlbGVjdC1jaG9pY2VzIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlc1xcXCIgcmVwZWF0PVxcXCJnZXRTZWxlY3RJdGVtKGl0ZW0pIGFzIGl0ZW0gaW4gc2VsZWN0SXRlbXMgfCBmaWx0ZXI6ICRzZWxlY3Quc2VhcmNoXFxcIiByZWZyZXNoPVxcXCJyZWZyZXNoSXRlbXMoJHNlbGVjdC5zZWFyY2gpXFxcIiByZWZyZXNoLWRlbGF5PVxcXCIyNTBcXFwiPlxcbiAgICA8Zm9ybWlvLXNlbGVjdC1pdGVtIHRlbXBsYXRlPVxcXCJjb21wb25lbnQudGVtcGxhdGVcXFwiIGl0ZW09XFxcIml0ZW1cXFwiIHNlbGVjdD1cXFwiJHNlbGVjdFxcXCI+PC9mb3JtaW8tc2VsZWN0LWl0ZW0+XFxuICAgIDxidXR0b24gbmctaWY9XFxcImhhc05leHRQYWdlICYmICgkaW5kZXggPT0gJHNlbGVjdC5pdGVtcy5sZW5ndGgtMSlcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3MgYnRuLWJsb2NrXFxcIiBuZy1jbGljaz1cXFwibG9hZE1vcmVJdGVtcygkc2VsZWN0LCAkZXZlbnQpXFxcIiBuZy1kaXNhYmxlZD1cXFwic2VsZWN0TG9hZGluZ1xcXCI+TG9hZCBtb3JlLi4uPC9idXR0b24+XFxuICA8L3VpLXNlbGVjdC1jaG9pY2VzPlxcbjwvdWktc2VsZWN0PlxcbjxkaXYgbmctaWY9XFxcIiEhY29tcG9uZW50LmRlc2NyaXB0aW9uXFxcIiBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCI+XFxuICA8c3Bhbj57eyBjb21wb25lbnQuZGVzY3JpcHRpb24gfX08L3NwYW4+XFxuPC9kaXY+XFxuPGZvcm1pby1lcnJvcnMgbmctaWY9XFxcIjo6IWJ1aWxkZXJcXFwiPjwvZm9ybWlvLWVycm9ycz5cXG5cIlxuICAgICAgKTtcblxuICAgICAgLy8gQ2hhbmdlIHRoZSB1aS1zZWxlY3QgdG8gdWktc2VsZWN0IG11bHRpcGxlLlxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9zZWxlY3QtbXVsdGlwbGUuaHRtbCcsXG4gICAgICAgICR0ZW1wbGF0ZUNhY2hlLmdldCgnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0Lmh0bWwnKS5yZXBsYWNlKCc8dWktc2VsZWN0JywgJzx1aS1zZWxlY3QgbXVsdGlwbGUnKVxuICAgICAgKTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5kaXJlY3RpdmUoJ2Zvcm1pb1NlbGVjdEJveGVzJywgW2Z1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGNvbXBvbmVudDogJz0nLFxuICAgICAgICBjb21wb25lbnRJZDogJz0nLFxuICAgICAgICByZWFkT25seTogJz0nLFxuICAgICAgICBtb2RlbDogJz1uZ01vZGVsJyxcbiAgICAgICAgZ3JpZFJvdzogJz0nLFxuICAgICAgICBncmlkQ29sOiAnPScsXG4gICAgICAgIGJ1aWxkZXI6ICc9PydcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9jb21wb25lbnRzL3NlbGVjdGJveGVzLWRpcmVjdGl2ZS5odG1sJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgZWwsIGF0dHJzLCBuZ01vZGVsKSB7XG4gICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xuICAgICAgICAvLyBJbml0aWFsaXplIG1vZGVsXG4gICAgICAgIHZhciBtb2RlbCA9IHt9O1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLmNvbXBvbmVudC52YWx1ZXMsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBtb2RlbFt2LnZhbHVlXSA9IG5nTW9kZWwuJHZpZXdWYWx1ZS5oYXNPd25Qcm9wZXJ0eSh2LnZhbHVlKVxuICAgICAgICAgICAgPyAhIW5nTW9kZWwuJHZpZXdWYWx1ZVt2LnZhbHVlXVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZBLTgzNSAtIFVwZGF0ZSB0aGUgdmlldyBtb2RlbCB3aXRoIG91ciBkZWZhdWx0cy5cbiAgICAgICAgLy8gRkEtOTIxIC0gQXR0ZW1wdCB0byBsb2FkIGEgY3VycmVudCBtb2RlbCwgaWYgcHJlc2VudCBiZWZvcmUgdGhlIGRlZmF1bHRzLlxuICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoJHNjb3BlLm1vZGVsIHx8IG1vZGVsKTtcblxuICAgICAgICBuZ01vZGVsLiRzZXRQcmlzdGluZSh0cnVlKTtcbiAgICAgICAgbmdNb2RlbC4kaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZXZlcnkoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gIXZhbHVlW2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLnRvZ2dsZUNoZWNrYm94ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgX21vZGVsID0gYW5ndWxhci5jb3B5KG5nTW9kZWwuJHZpZXdWYWx1ZSB8fCB7fSk7XG4gICAgICAgICAgX21vZGVsW3ZhbHVlXSA9ICFfbW9kZWxbdmFsdWVdO1xuICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShfbW9kZWwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuICBhcHAuY29uZmlnKFtcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3Rlcignc2VsZWN0Ym94ZXMnLCB7XG4gICAgICAgIHRpdGxlOiAnU2VsZWN0IEJveGVzJyxcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9zZWxlY3Rib3hlcy5odG1sJyxcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhLCBjb21wb25lbnQpIHtcbiAgICAgICAgICBpZiAoIWRhdGEpIHJldHVybiAnJztcblxuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBjb21wb25lbnQudmFsdWVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICBpZiAoaXRlbS52YWx1ZSA9PT0gZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBpdGVtLmxhYmVsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgaW5wdXQ6IHRydWUsXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxuICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICBrZXk6ICdzZWxlY3Rib3hlc0ZpZWxkJyxcbiAgICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICAgIGlubGluZTogZmFsc2UsXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXG4gICAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcblxuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3NlbGVjdGJveGVzLWRpcmVjdGl2ZS5odG1sJyxcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJzZWxlY3QtYm94ZXNcXFwiPlxcbiAgPGRpdiBuZy1jbGFzcz1cXFwiY29tcG9uZW50LmlubGluZSA/ICdjaGVja2JveC1pbmxpbmUnIDogJ2NoZWNrYm94J1xcXCIgbmctcmVwZWF0PVxcXCJ2IGluIGNvbXBvbmVudC52YWx1ZXMgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG4gICAgPGxhYmVsIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBmb3I9XFxcInt7IGNvbXBvbmVudElkIH19LXt7IHYudmFsdWUgfX1cXFwiPlxcbiAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCJcXG4gICAgICAgIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fS17eyB2LnZhbHVlIH19XFxcIlxcbiAgICAgICAgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX0te3sgdi52YWx1ZSB9fVxcXCJcXG4gICAgICAgIHZhbHVlPVxcXCJ7eyB2LnZhbHVlIH19XFxcIlxcbiAgICAgICAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcbiAgICAgICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcbiAgICAgICAgbmctY2xpY2s9XFxcInRvZ2dsZUNoZWNrYm94KHYudmFsdWUpXFxcIlxcbiAgICAgICAgbmctY2hlY2tlZD1cXFwibW9kZWxbdi52YWx1ZV1cXFwiXFxuICAgICAgICBncmlkLXJvdz1cXFwiZ3JpZFJvd1xcXCJcXG4gICAgICAgIGdyaWQtY29sPVxcXCJncmlkQ29sXFxcIlxcbiAgICAgID5cXG4gICAgICB7eyB2LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcbiAgICA8L2xhYmVsPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCJcbiAgICAgICk7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3NlbGVjdGJveGVzLmh0bWwnLFxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcInNlbGVjdC1ib3hlc1xcXCI+XFxuICA8bGFiZWwgbmctaWY9XFxcImNvbXBvbmVudC5sYWJlbCAmJiAhY29tcG9uZW50LmhpZGVMYWJlbFxcXCIgZm9yPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+XFxuICAgIHt7IGNvbXBvbmVudC5sYWJlbCB9fVxcbiAgPC9sYWJlbD5cXG4gIDxmb3JtaW8tc2VsZWN0LWJveGVzXFxuICAgIG5hbWU9XFxcInt7Y29tcG9uZW50SWR9fVxcXCJcXG4gICAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiXFxuICAgIG5nLW1vZGVsLW9wdGlvbnM9XFxcInthbGxvd0ludmFsaWQ6IHRydWV9XFxcIlxcbiAgICBjb21wb25lbnQ9XFxcImNvbXBvbmVudFxcXCJcXG4gICAgY29tcG9uZW50LWlkPVxcXCJjb21wb25lbnRJZFxcXCJcXG4gICAgcmVhZC1vbmx5PVxcXCJyZWFkT25seVxcXCJcXG4gICAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXG4gICAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXG4gICAgZ3JpZC1yb3c9XFxcImdyaWRSb3dcXFwiXFxuICAgIGdyaWQtY29sPVxcXCJncmlkQ29sXFxcIlxcbiAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcbiAgPjwvZm9ybWlvLXNlbGVjdC1ib3hlcz5cXG4gIDxkaXYgbmctaWY9XFxcIiEhY29tcG9uZW50LmRlc2NyaXB0aW9uXFxcIiBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCI+XFxuICAgIDxzcGFuPnt7IGNvbXBvbmVudC5kZXNjcmlwdGlvbiB9fTwvc3Bhbj5cXG4gIDwvZGl2PlxcbiAgPGZvcm1pby1lcnJvcnMgbmctaWY9XFxcIjo6IWJ1aWxkZXJcXFwiPjwvZm9ybWlvLWVycm9ycz5cXG48L2Rpdj5cXG5cIlxuICAgICAgKTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgU2lnbmF0dXJlUGFkID0gcmVxdWlyZSgnc2lnbmF0dXJlX3BhZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3NpZ25hdHVyZScsIHtcbiAgICAgICAgdGl0bGU6ICdTaWduYXR1cmUnLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3NpZ25hdHVyZS5odG1sJyxcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEgPyAnWWVzJyA6ICdObyc7XG4gICAgICAgIH0sXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGlucHV0OiB0cnVlLFxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAga2V5OiAnc2lnbmF0dXJlJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgICAgZm9vdGVyOiAnU2lnbiBhYm92ZScsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxNTAnLFxuICAgICAgICAgIHBlbkNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYigyNDUsMjQ1LDIzNSknLFxuICAgICAgICAgIG1pbldpZHRoOiAnMC41JyxcbiAgICAgICAgICBtYXhXaWR0aDogJzIuNScsXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXG4gICAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmlld1RlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHNWaWV3L3NpZ25hdHVyZS5odG1sJ1xuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLmRpcmVjdGl2ZSgnc2lnbmF0dXJlJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICBzY29wZToge1xuICAgICAgICBjb21wb25lbnQ6ICc9J1xuICAgICAgfSxcbiAgICAgIHJlcXVpcmU6ICc/bmdNb2RlbCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcbiAgICAgICAgaWYgKHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcbiAgICAgICAgaWYgKCFuZ01vZGVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0aGUgbGFiZWwgb2YgY29tcG9uZW50IGZvciBlcnJvciBkaXNwbGF5LlxuICAgICAgICBzY29wZS5jb21wb25lbnQubGFiZWwgPSAnU2lnbmF0dXJlJztcbiAgICAgICAgc2NvcGUuY29tcG9uZW50LmhpZGVMYWJlbCA9IHRydWU7XG5cbiAgICAgICAgLy8gU2V0cyB0aGUgZGltZW5zaW9uIG9mIGEgd2lkdGggb3IgaGVpZ2h0LlxuICAgICAgICB2YXIgc2V0RGltZW5zaW9uID0gZnVuY3Rpb24oZGltKSB7XG4gICAgICAgICAgdmFyIHBhcmFtID0gKGRpbSA9PT0gJ3dpZHRoJykgPyAnY2xpZW50V2lkdGgnIDogJ2NsaWVudEhlaWdodCc7XG4gICAgICAgICAgaWYgKHNjb3BlLmNvbXBvbmVudFtkaW1dLnNsaWNlKC0xKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IHBhcnNlRmxvYXQoc2NvcGUuY29tcG9uZW50W2RpbV0uc2xpY2UoMCwgLTEpKSAvIDEwMDtcbiAgICAgICAgICAgIGVsZW1lbnRbMF1bZGltXSA9IGVsZW1lbnQucGFyZW50KCkuZXEoMClbMF1bcGFyYW1dICogcGVyY2VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50WzBdW2RpbV0gPSBwYXJzZUludChzY29wZS5jb21wb25lbnRbZGltXSwgMTApO1xuICAgICAgICAgICAgc2NvcGUuY29tcG9uZW50W2RpbV0gPSBlbGVtZW50WzBdW2RpbV0gKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNhbnZhcy5cbiAgICAgICAgLy8gUmVzZXQgc2l6ZSBpZiBlbGVtZW50IGNoYW5nZXMgdmlzaWJpbGl0eS5cbiAgICAgICAgc2NvcGUuJHdhdGNoKCdjb21wb25lbnQuZGlzcGxheScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNldERpbWVuc2lvbignd2lkdGgnKTtcbiAgICAgICAgICBzZXREaW1lbnNpb24oJ2hlaWdodCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHNpZ25hdHVyZSBwYWQuXG4gICAgICAgIHZhciBzaWduYXR1cmVQYWQgPSBuZXcgU2lnbmF0dXJlUGFkKGVsZW1lbnRbMF0sIHtcbiAgICAgICAgICBtaW5XaWR0aDogc2NvcGUuY29tcG9uZW50Lm1pbldpZHRoLFxuICAgICAgICAgIG1heFdpZHRoOiBzY29wZS5jb21wb25lbnQubWF4V2lkdGgsXG4gICAgICAgICAgcGVuQ29sb3I6IHNjb3BlLmNvbXBvbmVudC5wZW5Db2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHNjb3BlLmNvbXBvbmVudC5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUuJHdhdGNoKCdjb21wb25lbnQucGVuQ29sb3InLCBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgIHNpZ25hdHVyZVBhZC5wZW5Db2xvciA9IG5ld1ZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBzY29wZS4kd2F0Y2goJ2NvbXBvbmVudC5iYWNrZ3JvdW5kQ29sb3InLCBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgIHNpZ25hdHVyZVBhZC5iYWNrZ3JvdW5kQ29sb3IgPSBuZXdWYWx1ZTtcbiAgICAgICAgICBzaWduYXR1cmVQYWQuY2xlYXIoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIHNpZ25hdHVyZS5cbiAgICAgICAgc2NvcGUuY29tcG9uZW50LmNsZWFyU2lnbmF0dXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2lnbmF0dXJlUGFkLmNsZWFyKCk7XG4gICAgICAgICAgcmVhZFNpZ25hdHVyZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBzb21lIENTUyBwcm9wZXJ0aWVzLlxuICAgICAgICBlbGVtZW50LmNzcyh7XG4gICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiAnNHB4JyxcbiAgICAgICAgICAnYm94LXNoYWRvdyc6ICcwIDAgNXB4IHJnYmEoMCwgMCwgMCwgMC4wMikgaW5zZXQnLFxuICAgICAgICAgICdib3JkZXInOiAnMXB4IHNvbGlkICNmNGY0ZjQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRTaWduYXR1cmUoKSB7XG4gICAgICAgICAgaWYgKHNjb3BlLiRwYXJlbnQuaXNSZXF1aXJlZChzY29wZS5jb21wb25lbnQpICYmIHNpZ25hdHVyZVBhZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZSgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHNpZ25hdHVyZVBhZC50b0RhdGFVUkwoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmdNb2RlbC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2lnbmF0dXJlUGFkLmZyb21EYXRhVVJMKG5nTW9kZWwuJHZpZXdWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHNpZ25hdHVyZVBhZC5vbkVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNjb3BlLiRldmFsQXN5bmMocmVhZFNpZ25hdHVyZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIGFwcC5ydW4oW1xuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgJ0Zvcm1pb1V0aWxzJyxcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSxcbiAgICAgICAgICAgICAgRm9ybWlvVXRpbHMpIHtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvc2lnbmF0dXJlLmh0bWwnLCBGb3JtaW9VdGlscy5maWVsZFdyYXAoXG4gICAgICAgIFwiPGRpdiBuZy1pZj1cXFwicmVhZE9ubHlcXFwiPlxcbiAgPGRpdiBuZy1pZj1cXFwiZGF0YVtjb21wb25lbnQua2V5XSA9PT0gJ1lFUydcXFwiPlxcbiAgICBbIFNpZ25hdHVyZSBpcyBoaWRkZW4gXVxcbiAgPC9kaXY+XFxuICA8ZGl2IG5nLWlmPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldICE9PSAnWUVTJ1xcXCI+XFxuICAgIDxpbWcgY2xhc3M9XFxcInNpZ25hdHVyZVxcXCIgbmctYXR0ci1zcmM9XFxcInt7ZGF0YVtjb21wb25lbnQua2V5XX19XFxcIiBzcmM9XFxcIlxcXCIgLz5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgbmctaWY9XFxcIiFyZWFkT25seVxcXCIgc3R5bGU9XFxcIndpZHRoOiB7eyBjb21wb25lbnQud2lkdGggfX07IGhlaWdodDoge3sgY29tcG9uZW50LmhlaWdodCB9fTtcXFwiPlxcbiAgPGEgY2xhc3M9XFxcImJ0biBidG4teHMgYnRuLWRlZmF1bHRcXFwiIHN0eWxlPVxcXCJwb3NpdGlvbjphYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyB6LWluZGV4OiAxMDAwXFxcIiBuZy1jbGljaz1cXFwiY29tcG9uZW50LmNsZWFyU2lnbmF0dXJlKClcXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZWZyZXNoXFxcIj48L3NwYW4+XFxuICA8L2E+XFxuICA8Y2FudmFzIHNpZ25hdHVyZSBjb21wb25lbnQ9XFxcImNvbXBvbmVudFxcXCIgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIiBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIj48L2NhbnZhcz5cXG4gIDxkaXYgY2xhc3M9XFxcImZvcm1pby1zaWduYXR1cmUtZm9vdGVyXFxcIiBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO2NvbG9yOiNDM0MzQzM7XFxcIiBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGlzUmVxdWlyZWQoY29tcG9uZW50KX1cXFwiPnt7IGNvbXBvbmVudC5mb290ZXIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9kaXY+XFxuPC9kaXY+XFxuXCJcbiAgICAgICkpO1xuXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzVmlldy9zaWduYXR1cmUuaHRtbCcsIEZvcm1pb1V0aWxzLmZpZWxkV3JhcChcbiAgICAgICAgXCI8ZGl2IG5nLWlmPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldID09PSAnWUVTJ1xcXCI+XFxuICBbIFNpZ25hdHVyZSBpcyBoaWRkZW4gXVxcbjwvZGl2PlxcbjxkaXYgbmctaWY9XFxcImRhdGFbY29tcG9uZW50LmtleV0gJiYgKGRhdGFbY29tcG9uZW50LmtleV0gIT09ICdZRVMnKVxcXCI+XFxuICA8aW1nIGNsYXNzPVxcXCJzaWduYXR1cmVcXFwiIG5nLWF0dHItc3JjPVxcXCJ7eyBkYXRhW2NvbXBvbmVudC5rZXldIH19XFxcIiBzcmM9XFxcIlxcXCIgLz5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJ3ZWxsIHRleHQtY2VudGVyXFxcIiBuZy1pZj1cXFwiIWRhdGFbY29tcG9uZW50LmtleV0gfHwgKGRhdGFbY29tcG9uZW50LmtleV0gPT09ICdOTycpXFxcIj5cXG4gIDxzdHJvbmc+Tm8gc2lnbmF0dXJlIHByb3ZpZGVkPC9zdHJvbmc+XFxuPC9kaXY+XFxuXCJcbiAgICAgICkpO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcbiAgYXBwLmNvbmZpZyhbXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3N1cnZleScsIHtcbiAgICAgICAgdGl0bGU6ICdTdXJ2ZXknLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3N1cnZleS5odG1sJyxcbiAgICAgICAgZ3JvdXA6ICdhZHZhbmNlZCcsXG4gICAgICAgIHRhYmxlVmlldzogZnVuY3Rpb24oZGF0YSwgY29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSAnPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZFwiPjx0aGVhZD4nO1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29tcG9uZW50LnZhbHVlcywgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgdmFsdWVzW3YudmFsdWVdID0gdi5sYWJlbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29tcG9uZW50LnF1ZXN0aW9ucywgZnVuY3Rpb24ocXVlc3Rpb24pIHtcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0cj4nO1xuICAgICAgICAgICAgdmlldyArPSAnPHRoPicgKyBxdWVzdGlvbi5sYWJlbCArICc8L3RoPic7XG4gICAgICAgICAgICB2aWV3ICs9ICc8dGQ+JyArIHZhbHVlc1tkYXRhW3F1ZXN0aW9uLnZhbHVlXV0gKyAnPC90ZD4nO1xuICAgICAgICAgICAgdmlldyArPSAnPC90cj4nO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZpZXcgKz0gJzwvdGJvZHk+PC90YWJsZT4nO1xuICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICB9LFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGlucHV0OiB0cnVlLFxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAga2V5OiAnc3VydmV5JyxcbiAgICAgICAgICBxdWVzdGlvbnM6IFtdLFxuICAgICAgICAgIHZhbHVlczogW10sXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnJyxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZSxcbiAgICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tOiAnJyxcbiAgICAgICAgICAgIGN1c3RvbVByaXZhdGU6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIF0pO1xuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgICdGb3JtaW9VdGlscycsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUsIEZvcm1pb1V0aWxzKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3N1cnZleS5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxuICAgICAgICBcIjx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZFxcXCI+XFxuICA8dGhlYWQ+XFxuICAgIDx0cj5cXG4gICAgICA8dGQ+PC90ZD5cXG4gICAgICA8dGggbmctcmVwZWF0PVxcXCJ2IGluIGNvbXBvbmVudC52YWx1ZXMgdHJhY2sgYnkgJGluZGV4XFxcIiBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXCI+e3sgdi5sYWJlbCB9fTwvdGg+XFxuICAgIDwvdHI+XFxuICA8L3RoZWFkPlxcbiAgPHRyIG5nLXJlcGVhdD1cXFwicXVlc3Rpb24gaW4gY29tcG9uZW50LnF1ZXN0aW9uc1xcXCI+XFxuICAgIDx0ZD57eyBxdWVzdGlvbi5sYWJlbCB9fTwvdGQ+XFxuICAgIDx0ZCBuZy1yZXBlYXQ9XFxcInYgaW4gY29tcG9uZW50LnZhbHVlcyB0cmFjayBieSAkaW5kZXhcXFwiIHN0eWxlPVxcXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XFxcIj5cXG4gICAgICA8aW5wdXRcXG4gICAgICAgIHR5cGU9XFxcInJhZGlvXFxcIlxcbiAgICAgICAgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19LXt7IHF1ZXN0aW9uLnZhbHVlIH19LXt7IHYudmFsdWUgfX1cXFwiIG5hbWU9XFxcInt7IGNvbXBvbmVudElkIH19LXt7IHF1ZXN0aW9uLnZhbHVlIH19XFxcIlxcbiAgICAgICAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcbiAgICAgICAgbmctdmFsdWU9XFxcInYudmFsdWVcXFwiXFxuICAgICAgICBuZy1tb2RlbD1cXFwiZGF0YVtjb21wb25lbnQua2V5XVtxdWVzdGlvbi52YWx1ZV1cXFwiXFxuICAgICAgICBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIlxcbiAgICAgICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcbiAgICAgICAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXG4gICAgICA+XFxuICAgIDwvdGQ+XFxuICA8L3RyPlxcbjwvdGFibGU+XFxuXCJcbiAgICAgICkpO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCd0YWJsZScsIHtcbiAgICAgICAgdGl0bGU6ICdUYWJsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvdGFibGUuaHRtbCcsXG4gICAgICAgIGdyb3VwOiAnbGF5b3V0JyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnB1dDogZmFsc2UsXG4gICAgICAgICAga2V5OiAndGFibGUnLFxuICAgICAgICAgIG51bVJvd3M6IDMsXG4gICAgICAgICAgbnVtQ29sczogMyxcbiAgICAgICAgICByb3dzOiBbW3tjb21wb25lbnRzOiBbXX0sIHtjb21wb25lbnRzOiBbXX0sIHtjb21wb25lbnRzOiBbXX1dLCBbe2NvbXBvbmVudHM6IFtdfSwge2NvbXBvbmVudHM6IFtdfSwge2NvbXBvbmVudHM6IFtdfV0sIFt7Y29tcG9uZW50czogW119LCB7Y29tcG9uZW50czogW119LCB7Y29tcG9uZW50czogW119XV0sXG4gICAgICAgICAgaGVhZGVyOiBbXSxcbiAgICAgICAgICBjYXB0aW9uOiAnJyxcbiAgICAgICAgICBzdHJpcGVkOiBmYWxzZSxcbiAgICAgICAgICBib3JkZXJlZDogZmFsc2UsXG4gICAgICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgICAgIGNvbmRlbnNlZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcbiAgYXBwLnJ1bihbXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgdmFyIHRhYmxlQ2xhc3NlcyA9IFwieyd0YWJsZS1zdHJpcGVkJzogY29tcG9uZW50LnN0cmlwZWQsIFwiO1xuICAgICAgdGFibGVDbGFzc2VzICs9IFwiJ3RhYmxlLWJvcmRlcmVkJzogY29tcG9uZW50LmJvcmRlcmVkLCBcIjtcbiAgICAgIHRhYmxlQ2xhc3NlcyArPSBcIid0YWJsZS1ob3Zlcic6IGNvbXBvbmVudC5ob3ZlciwgXCI7XG4gICAgICB0YWJsZUNsYXNzZXMgKz0gXCIndGFibGUtY29uZGVuc2VkJzogY29tcG9uZW50LmNvbmRlbnNlZH1cIjtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvdGFibGUuaHRtbCcsXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwidGFibGUtcmVzcG9uc2l2ZVxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPlxcbiAgPHRhYmxlIG5nLWNsYXNzPVxcXCJ7J3RhYmxlLXN0cmlwZWQnOiBjb21wb25lbnQuc3RyaXBlZCwgJ3RhYmxlLWJvcmRlcmVkJzogY29tcG9uZW50LmJvcmRlcmVkLCAndGFibGUtaG92ZXInOiBjb21wb25lbnQuaG92ZXIsICd0YWJsZS1jb25kZW5zZWQnOiBjb21wb25lbnQuY29uZGVuc2VkfVxcXCIgY2xhc3M9XFxcInRhYmxlXFxcIj5cXG4gICAgPHRoZWFkIG5nLWlmPVxcXCJjb21wb25lbnQuaGVhZGVyLmxlbmd0aFxcXCI+XFxuICAgICAgPHRoIG5nLXJlcGVhdD1cXFwiaGVhZGVyIGluIGNvbXBvbmVudC5oZWFkZXIgdHJhY2sgYnkgJGluZGV4XFxcIj57eyBoZWFkZXIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC90aD5cXG4gICAgPC90aGVhZD5cXG4gICAgPHRib2R5PlxcbiAgICAgIDx0ciBuZy1yZXBlYXQ9XFxcInJvdyBpbiBjb21wb25lbnQucm93cyB0cmFjayBieSAkaW5kZXhcXFwiPlxcbiAgICAgICAgPHRkIG5nLXJlcGVhdD1cXFwiY29sdW1uIGluIHJvdyB0cmFjayBieSAkaW5kZXhcXFwiPlxcbiAgICAgICAgICA8Zm9ybWlvLWNvbXBvbmVudFxcbiAgICAgICAgICAgIG5nLXJlcGVhdD1cXFwiX2NvbXBvbmVudCBpbiBjb2x1bW4uY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiXFxuICAgICAgICAgICAgY29tcG9uZW50PVxcXCJfY29tcG9uZW50XFxcIlxcbiAgICAgICAgICAgIGRhdGE9XFxcImRhdGFcXFwiXFxuICAgICAgICAgICAgZm9ybWlvPVxcXCJmb3JtaW9cXFwiXFxuICAgICAgICAgICAgc3VibWlzc2lvbj1cXFwic3VibWlzc2lvblxcXCJcXG4gICAgICAgICAgICBoaWRlLWNvbXBvbmVudHM9XFxcImhpZGVDb21wb25lbnRzXFxcIlxcbiAgICAgICAgICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxuICAgICAgICAgICAgZm9ybWlvLWZvcm09XFxcImZvcm1pb0Zvcm1cXFwiXFxuICAgICAgICAgICAgcmVhZC1vbmx5PVxcXCJpc0Rpc2FibGVkKF9jb21wb25lbnQsIGRhdGEpXFxcIlxcbiAgICAgICAgICAgIGdyaWQtcm93PVxcXCJncmlkUm93XFxcIlxcbiAgICAgICAgICAgIGdyaWQtY29sPVxcXCJncmlkQ29sXFxcIlxcbiAgICAgICAgICAgIGJ1aWxkZXI9XFxcImJ1aWxkZXJcXFwiXFxuICAgICAgICAgID48L2Zvcm1pby1jb21wb25lbnQ+XFxuICAgICAgICA8L3RkPlxcbiAgICAgIDwvdHI+XFxuICAgIDwvdGJvZHk+XFxuICA8L3RhYmxlPlxcbjwvZGl2PlxcblwiXG4gICAgICApO1xuXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzVmlldy90YWJsZS5odG1sJyxcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJ0YWJsZS1yZXNwb25zaXZlXFxcIiBpZD1cXFwie3sgY29tcG9uZW50LmtleSB9fVxcXCI+XFxuICA8dGFibGUgbmctY2xhc3M9XFxcInsndGFibGUtc3RyaXBlZCc6IGNvbXBvbmVudC5zdHJpcGVkLCAndGFibGUtYm9yZGVyZWQnOiBjb21wb25lbnQuYm9yZGVyZWQsICd0YWJsZS1ob3Zlcic6IGNvbXBvbmVudC5ob3ZlciwgJ3RhYmxlLWNvbmRlbnNlZCc6IGNvbXBvbmVudC5jb25kZW5zZWR9XFxcIiBjbGFzcz1cXFwidGFibGVcXFwiPlxcbiAgICA8dGhlYWQgbmctaWY9XFxcImNvbXBvbmVudC5oZWFkZXIubGVuZ3RoXFxcIj5cXG4gICAgICA8dGggbmctcmVwZWF0PVxcXCJoZWFkZXIgaW4gY29tcG9uZW50LmhlYWRlciB0cmFjayBieSAkaW5kZXhcXFwiPnt7IGhlYWRlciB9fTwvdGg+XFxuICAgIDwvdGhlYWQ+XFxuICAgIDx0Ym9keT5cXG4gICAgICA8dHIgbmctcmVwZWF0PVxcXCJyb3cgaW4gY29tcG9uZW50LnJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG4gICAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImNvbHVtbiBpbiByb3cgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG4gICAgICAgICAgPGZvcm1pby1jb21wb25lbnQtdmlld1xcbiAgICAgICAgICAgIG5nLXJlcGVhdD1cXFwiX2NvbXBvbmVudCBpbiBjb2x1bW4uY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiXFxuICAgICAgICAgICAgY29tcG9uZW50PVxcXCJfY29tcG9uZW50XFxcIlxcbiAgICAgICAgICAgIGRhdGE9XFxcImRhdGFcXFwiXFxuICAgICAgICAgICAgZm9ybT1cXFwiZm9ybVxcXCJcXG4gICAgICAgICAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcbiAgICAgICAgICAgIGlnbm9yZT1cXFwiaWdub3JlXFxcIlxcbiAgICAgICAgICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxuICAgICAgICAgICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXG4gICAgICAgICAgPjwvZm9ybWlvLWNvbXBvbmVudC12aWV3PlxcbiAgICAgICAgPC90ZD5cXG4gICAgICA8L3RyPlxcbiAgICA8L3Rib2R5PlxcbiAgPC90YWJsZT5cXG48L2Rpdj5cXG5cIlxuICAgICAgKTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xuICBhcHAuY29uZmlnKFtcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcigndGV4dGFyZWEnLCB7XG4gICAgICAgIHRpdGxlOiAnVGV4dCBBcmVhJyxcbiAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgIGlmICghJHNjb3BlLnJlYWRPbmx5ICYmICRzY29wZS5jb21wb25lbnQud3lzaXd5Zykge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICB0b29sYmFyR3JvdXBzOiAgW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAnYmFzaWNzdHlsZXMnLCBncm91cHM6IFsnYmFzaWNzdHlsZXMnLCAnY2xlYW51cCddfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3BhcmFncmFwaCcsIGdyb3VwczogWydsaXN0JywgJ2luZGVudCcsICdibG9ja3MnLCAnYWxpZ24nLCAnYmlkaScsICdwYXJhZ3JhcGgnLCAnLScsICdKdXN0aWZ5TGVmdCcsICdKdXN0aWZ5Q2VudGVyJywgJ0p1c3RpZnlSaWdodCcsICdKdXN0aWZ5QmxvY2snXX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICdsaW5rcycsIGdyb3VwczogWydsaW5rcyddfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2luc2VydCcsIGdyb3VwczogWydpbnNlcnQnXX0sXG4gICAgICAgICAgICAgICAgJy8nLFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnc3R5bGVzJywgZ3JvdXBzOiBbJ1N0eWxlcycsICdGb3JtYXQnLCAnRm9udCcsICdGb250U2l6ZSddfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2NvbG9ycycsIGdyb3VwczogWydjb2xvcnMnXX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICdjbGlwYm9hcmQnLCBncm91cHM6IFsnY2xpcGJvYXJkJywgJ3VuZG8nXX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICdlZGl0aW5nJywgZ3JvdXBzOiBbJ2ZpbmQnLCAnc2VsZWN0aW9uJywgJ3NwZWxsY2hlY2tlcicsICdlZGl0aW5nJ119LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnZG9jdW1lbnQnLCBncm91cHM6IFsnbW9kZScsICdkb2N1bWVudCcsICdkb2N0b29scyddfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ290aGVycycsIGdyb3VwczogWydvdGhlcnMnXX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICd0b29scycsIGdyb3VwczogWyd0b29scyddfVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBleHRyYVBsdWdpbnM6ICdqdXN0aWZ5LGZvbnQnLFxuICAgICAgICAgICAgICByZW1vdmVCdXR0b25zOiAnQ3V0LENvcHksUGFzdGUsVW5kZXJsaW5lLFN1YnNjcmlwdCxTdXBlcnNjcmlwdCxTY2F5dCxBYm91dCcsXG4gICAgICAgICAgICAgIHVpQ29sb3I6ICcjZWVlZWVlJyxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnNDAwcHgnLFxuICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCRzY29wZS5jb21wb25lbnQud3lzaXd5ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50Lnd5c2l3eWcgPSBkZWZhdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50Lnd5c2l3eWcgPSBhbmd1bGFyLmV4dGVuZChkZWZhdWx0cywgJHNjb3BlLmNvbXBvbmVudC53eXNpd3lnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnZm9ybWlvL2NvbXBvbmVudHMvdGV4dGVkaXRvci5odG1sJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdmb3JtaW8vY29tcG9uZW50cy90ZXh0YXJlYS5odG1sJztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXG4gICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgIGtleTogJ3RleHRhcmVhRmllbGQnLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnJyxcbiAgICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICAgIHN1ZmZpeDogJycsXG4gICAgICAgICAgcm93czogMyxcbiAgICAgICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnJyxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICB3eXNpd3lnOiBmYWxzZSxcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZSxcbiAgICAgICAgICB2YWxpZGF0ZToge1xuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWluTGVuZ3RoOiAnJyxcbiAgICAgICAgICAgIG1heExlbmd0aDogJycsXG4gICAgICAgICAgICBwYXR0ZXJuOiAnJyxcbiAgICAgICAgICAgIGN1c3RvbTogJydcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgXSk7XG4gIGFwcC5ydW4oW1xuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgJ0Zvcm1pb1V0aWxzJyxcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSxcbiAgICAgICAgICAgICAgRm9ybWlvVXRpbHMpIHtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvdGV4dGFyZWEuaHRtbCcsIEZvcm1pb1V0aWxzLmZpZWxkV3JhcChcbiAgICAgICAgXCI8dGV4dGFyZWFcXG4gIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxuICBuZy1tb2RlbD1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCJcXG4gIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXG4gIG5nLXJlcXVpcmVkPVxcXCJpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiXFxuICBzYWZlLW11bHRpcGxlLXRvLXNpbmdsZVxcbiAgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcbiAgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxuICB0YWJpbmRleD1cXFwie3sgY29tcG9uZW50LnRhYmluZGV4IHx8IDAgfX1cXFwiXFxuICBuZy1hdHRyLXBsYWNlaG9sZGVyPVxcXCJ7eyBjb21wb25lbnQucGxhY2Vob2xkZXIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19XFxcIlxcbiAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXG4gIHJvd3M9XFxcInt7IGNvbXBvbmVudC5yb3dzIH19XFxcIlxcbj48L3RleHRhcmVhPlxcblwiXG4gICAgICApKTtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvdGV4dGVkaXRvci5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxuICAgICAgICBcIjx0ZXh0YXJlYVxcbiAgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCJcXG4gIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIlxcbiAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcbiAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXG4gIGNrZWRpdG9yPVxcXCJjb21wb25lbnQud3lzaXd5Z1xcXCJcXG4gIHNhZmUtbXVsdGlwbGUtdG8tc2luZ2xlXFxuICBpZD1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxuICBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXG4gIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXG4gIG5nLWF0dHItcGxhY2Vob2xkZXI9XFxcInt7IGNvbXBvbmVudC5wbGFjZWhvbGRlciB9fVxcXCJcXG4gIGN1c3RvbS12YWxpZGF0b3I9XFxcImNvbXBvbmVudC52YWxpZGF0ZS5jdXN0b21cXFwiXFxuICByb3dzPVxcXCJ7eyBjb21wb25lbnQucm93cyB9fVxcXCJcXG4+PC90ZXh0YXJlYT5cXG5cIlxuICAgICAgKSk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xuICBhcHAuY29uZmlnKFtcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcigndGV4dGZpZWxkJywge1xuICAgICAgICB0aXRsZTogJ1RleHQgRmllbGQnLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3RleHRmaWVsZC5odG1sJyxcbiAgICAgICAgaWNvbjogJ2ZhIGZhLXRlcm1pbmFsJyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXG4gICAgICAgICAgaW5wdXRUeXBlOiAndGV4dCcsXG4gICAgICAgICAgaW5wdXRNYXNrOiAnJyxcbiAgICAgICAgICBsYWJlbDogJycsXG4gICAgICAgICAga2V5OiAndGV4dEZpZWxkJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgICAgcHJlZml4OiAnJyxcbiAgICAgICAgICBzdWZmaXg6ICcnLFxuICAgICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcnLFxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXG4gICAgICAgICAgdW5pcXVlOiBmYWxzZSxcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXG4gICAgICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbkxlbmd0aDogJycsXG4gICAgICAgICAgICBtYXhMZW5ndGg6ICcnLFxuICAgICAgICAgICAgcGF0dGVybjogJycsXG4gICAgICAgICAgICBjdXN0b206ICcnLFxuICAgICAgICAgICAgY3VzdG9tUHJpdmF0ZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmRpdGlvbmFsOiB7XG4gICAgICAgICAgICBzaG93OiBudWxsLFxuICAgICAgICAgICAgd2hlbjogbnVsbCxcbiAgICAgICAgICAgIGVxOiAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdKTtcblxuICBhcHAucnVuKFtcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAgICdGb3JtaW9VdGlscycsXG4gICAgZnVuY3Rpb24oXG4gICAgICAkdGVtcGxhdGVDYWNoZSxcbiAgICAgIEZvcm1pb1V0aWxzXG4gICAgKSB7XG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3RleHRmaWVsZC5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxuICAgICAgICBcIjxpbnB1dFxcbiAgdHlwZT1cXFwie3sgY29tcG9uZW50LmlucHV0VHlwZSB9fVxcXCJcXG4gIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxuICBpZD1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxuICBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXG4gIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXG4gIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXG4gIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIlxcbiAgbmctbW9kZWwtb3B0aW9ucz1cXFwieyBkZWJvdW5jZTogNTAwIH1cXFwiXFxuICBzYWZlLW11bHRpcGxlLXRvLXNpbmdsZVxcbiAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXG4gIG5nLW1pbmxlbmd0aD1cXFwiY29tcG9uZW50LnZhbGlkYXRlLm1pbkxlbmd0aFxcXCJcXG4gIG5nLW1heGxlbmd0aD1cXFwiY29tcG9uZW50LnZhbGlkYXRlLm1heExlbmd0aFxcXCJcXG4gIG5nLXBhdHRlcm49XFxcImNvbXBvbmVudC52YWxpZGF0ZS5wYXR0ZXJuXFxcIlxcbiAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXG4gIG5nLWF0dHItcGxhY2Vob2xkZXI9XFxcInt7IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXFwiXFxuICB1aS1tYXNrPVxcXCJ7eyBjb21wb25lbnQuaW5wdXRNYXNrIH19XFxcIlxcbiAgdWktbWFzay1wbGFjZWhvbGRlcj1cXFwiXFxcIlxcbiAgdWktb3B0aW9ucz1cXFwidWlNYXNrT3B0aW9uc1xcXCJcXG4+XFxuXCJcbiAgICAgICkpO1xuICAgIH1cbiAgXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCd3ZWxsJywge1xuICAgICAgICB0aXRsZTogJ1dlbGwnLFxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3dlbGwuaHRtbCcsXG4gICAgICAgIGdyb3VwOiAnbGF5b3V0JyxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBrZXk6ICd3ZWxsJyxcbiAgICAgICAgICBpbnB1dDogZmFsc2UsXG4gICAgICAgICAgY29tcG9uZW50czogW11cbiAgICAgICAgfSxcbiAgICAgICAgdmlld1RlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHNWaWV3L3dlbGwuaHRtbCdcbiAgICAgIH0pO1xuICAgIH1cbiAgXSk7XG4gIGFwcC5ydW4oW1xuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvd2VsbC5odG1sJyxcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJ3ZWxsXFxcIiBpZD1cXFwie3sgY29tcG9uZW50LmtleSB9fVxcXCI+XFxuICA8Zm9ybWlvLWNvbXBvbmVudFxcbiAgICBuZy1yZXBlYXQ9XFxcIl9jb21wb25lbnQgaW4gY29tcG9uZW50LmNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIlxcbiAgICBjb21wb25lbnQ9XFxcIl9jb21wb25lbnRcXFwiXFxuICAgIGRhdGE9XFxcImRhdGFcXFwiXFxuICAgIGZvcm1pbz1cXFwiZm9ybWlvXFxcIlxcbiAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcbiAgICBoaWRlLWNvbXBvbmVudHM9XFxcImhpZGVDb21wb25lbnRzXFxcIlxcbiAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogaXNWaXNpYmxlKF9jb21wb25lbnQsIGRhdGEpXFxcIlxcbiAgICByZWFkLW9ubHk9XFxcImlzRGlzYWJsZWQoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxuICAgIGZvcm1pby1mb3JtPVxcXCJmb3JtaW9Gb3JtXFxcIlxcbiAgICBncmlkLXJvdz1cXFwiZ3JpZFJvd1xcXCJcXG4gICAgZ3JpZC1jb2w9XFxcImdyaWRDb2xcXFwiXFxuICAgIGJ1aWxkZXI9XFxcImJ1aWxkZXJcXFwiXFxuICA+PC9mb3JtaW8tY29tcG9uZW50PlxcbjwvZGl2PlxcblwiXG4gICAgICApO1xuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50c1ZpZXcvd2VsbC5odG1sJyxcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJ3ZWxsXFxcIiBpZD1cXFwie3sgY29tcG9uZW50LmtleSB9fVxcXCI+XFxuICA8Zm9ybWlvLWNvbXBvbmVudC12aWV3XFxuICAgIG5nLXJlcGVhdD1cXFwiX2NvbXBvbmVudCBpbiBjb21wb25lbnQuY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiXFxuICAgIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXG4gICAgZGF0YT1cXFwiZGF0YVxcXCJcXG4gICAgZm9ybT1cXFwiZm9ybVxcXCJcXG4gICAgc3VibWlzc2lvbj1cXFwic3VibWlzc2lvblxcXCJcXG4gICAgaWdub3JlPVxcXCJpZ25vcmVcXFwiXFxuICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxuICAgIGJ1aWxkZXI9XFxcImJ1aWxkZXJcXFwiXFxuICA+PC9mb3JtaW8tY29tcG9uZW50LXZpZXc+XFxuPC9kaXY+XFxuXCJcbiAgICAgICk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZSwgYXR0cnMsIGN0cmwpIHtcbiAgICAgIGlmIChzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICBpZiAoXG4gICAgICAgICFzY29wZS5jb21wb25lbnQudmFsaWRhdGUgfHxcbiAgICAgICAgIXNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZS5jdXN0b21cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfZ2V0ID0gZnVuY3Rpb24oaXRlbSwgcGF0aCwgZGVmKSB7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgIHJldHVybiBkZWYgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHBhdGggaXMgYSBzdHJpbmcsIHR1cm4gaXQgaW50byBhbiBhcnJheS5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHBhdGggaXMgYW4gYXJyYXksIHRha2UgdGhlIGZpcnN0IGVsZW1lbnQsIGFuZCByZWN1cnNlIGl0cyBwYXRoXG4gICAgICAgIGlmIChwYXRoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShjdXJyZW50KSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG1vcmUgcGF0aCBpdGVtcywgc3RvcCBoZXJlLlxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtW2N1cnJlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2dldChpdGVtW2N1cnJlbnRdLCBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH07XG5cbiAgICAgIGN0cmwuJHZhbGlkYXRvcnMuY3VzdG9tID0gZnVuY3Rpb24obW9kZWxWYWx1ZSwgdmlld1ZhbHVlKSB7XG4gICAgICAgIHZhciB2YWxpZCA9IHRydWU7XG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgdmFyIGlucHV0ID0gbW9kZWxWYWx1ZSB8fCB2aWV3VmFsdWU7XG5cbiAgICAgICAgLy8gRk9SLTI1NSAtIEVuYWJsZSByb3cgZGF0YSBhbmQgZm9ybSBkYXRhIHRvIGJlIHZpc2libGUgaW4gdGhlIHZhbGlkYXRvci5cbiAgICAgICAgdmFyIGRhdGEgPSBzY29wZS5zdWJtaXNzaW9uLmRhdGE7XG4gICAgICAgIHZhciByb3cgPSBzY29wZS5kYXRhO1xuICAgICAgICAvKmVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAgICAgICB2YXIgY3VzdG9tID0gc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbTtcbiAgICAgICAgY3VzdG9tID0gY3VzdG9tLnJlcGxhY2UoLyh7e1xcc3swLH0oLipbXlxcc10pezF9XFxzezAsfX19KS9nLCBmdW5jdGlvbihtYXRjaCwgJDEsICQyKSB7XG4gICAgICAgICAgcmV0dXJuIF9nZXQoc2NvcGUuc3VibWlzc2lvbi5kYXRhLCAkMik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgICAgICAgICBldmFsKGN1c3RvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgIHZhbGlkID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQgIT09IHRydWUpIHtcbiAgICAgICAgICBzY29wZS5jb21wb25lbnQuY3VzdG9tRXJyb3IgPSB2YWxpZDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7XG4gICAgICBzcmM6ICc9PycsXG4gICAgICB1cmw6ICc9PycsXG4gICAgICBmb3JtQWN0aW9uOiAnPT8nLFxuICAgICAgZm9ybTogJz0/JyxcbiAgICAgIHN1Ym1pc3Npb246ICc9PycsXG4gICAgICByZWFkT25seTogJz0/JyxcbiAgICAgIGhpZGVDb21wb25lbnRzOiAnPT8nLFxuICAgICAgcmVxdWlyZUNvbXBvbmVudHM6ICc9PycsXG4gICAgICBkaXNhYmxlQ29tcG9uZW50czogJz0/JyxcbiAgICAgIGZvcm1pb09wdGlvbnM6ICc9PycsXG4gICAgICBvcHRpb25zOiAnPT8nXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiBbXG4gICAgICAnJHNjb3BlJyxcbiAgICAgICckaHR0cCcsXG4gICAgICAnJGVsZW1lbnQnLFxuICAgICAgJ0Zvcm1pb1Njb3BlJyxcbiAgICAgICdGb3JtaW8nLFxuICAgICAgJ0Zvcm1pb1V0aWxzJyxcbiAgICAgICckcScsXG4gICAgICBmdW5jdGlvbihcbiAgICAgICAgJHNjb3BlLFxuICAgICAgICAkaHR0cCxcbiAgICAgICAgJGVsZW1lbnQsXG4gICAgICAgIEZvcm1pb1Njb3BlLFxuICAgICAgICBGb3JtaW8sXG4gICAgICAgIEZvcm1pb1V0aWxzLFxuICAgICAgICAkcVxuICAgICAgKSB7XG4gICAgICAgIHZhciBpZnJhbWVSZWFkeSA9ICRxLmRlZmVyKCk7XG4gICAgICAgICRzY29wZS5fc3JjID0gJHNjb3BlLnNyYyB8fCAnJztcbiAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFtdO1xuICAgICAgICAkc2NvcGUuaWZyYW1lUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgLy8gU2hvd3MgdGhlIGdpdmVuIGFsZXJ0cyAoc2luZ2xlIG9yIGFycmF5KSwgYW5kIGRpc21pc3NlcyBvbGQgYWxlcnRzXG4gICAgICAgIHRoaXMuc2hvd0FsZXJ0cyA9ICRzY29wZS5zaG93QWxlcnRzID0gZnVuY3Rpb24oYWxlcnRzKSB7XG4gICAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFtdLmNvbmNhdChhbGVydHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS5nZXRJZnJhbWVTcmMgPSBmdW5jdGlvbihwZGYpIHtcbiAgICAgICAgICB2YXIgaWZyYW1lU3JjID0gcGRmLnNyYyArICcuaHRtbCc7XG4gICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICAgIGlmICgkc2NvcGUuZm9ybS5idWlsZGVyKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaCgnYnVpbGRlcj0xJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkc2NvcGUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKCdyZWFkb25seT0xJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZnJhbWVTcmMgKz0gJz8nICsgcGFyYW1zLmpvaW4oJyYnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlmcmFtZVNyYztcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuZG93bmxvYWRVcmwgPSAnJztcblxuICAgICAgICAkc2NvcGUuZ2V0UERGRG93bmxvYWQgPSBmdW5jdGlvbihwZGYpIHtcbiAgICAgICAgICBpZiAoISRzY29wZS5mb3JtaW8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRvd25sb2FkID0gJyc7XG4gICAgICAgICAgaWYgKCRzY29wZS5mb3JtaW8gJiYgJHNjb3BlLmZvcm1pby5zdWJtaXNzaW9uVXJsKSB7XG4gICAgICAgICAgICBkb3dubG9hZCA9ICRzY29wZS5mb3JtaW8uc3VibWlzc2lvblVybDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoJHNjb3BlLnN1Ym1pc3Npb24uX2lkKSB7XG4gICAgICAgICAgICBkb3dubG9hZCA9IEZvcm1pby5iYXNlVXJsICsgJy9wcm9qZWN0LycgKyAkc2NvcGUuZm9ybS5wcm9qZWN0ICsgJy8nO1xuICAgICAgICAgICAgZG93bmxvYWQgKz0gJy9mb3JtLycgKyAkc2NvcGUuZm9ybS5faWQ7XG4gICAgICAgICAgICBkb3dubG9hZCArPSAnL3N1Ym1pc3Npb24vJyArICRzY29wZS5zdWJtaXNzaW9uLl9pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkb3dubG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvd25sb2FkICs9ICcvZG93bmxvYWQvJyArIHBkZi5pZDtcbiAgICAgICAgICB2YXIgYWxsb3dlZFBhdGggPSBkb3dubG9hZC5yZXBsYWNlKEZvcm1pby5iYXNlVXJsLCAnJyk7XG4gICAgICAgICAgYWxsb3dlZFBhdGggPSBhbGxvd2VkUGF0aC5yZXBsYWNlKEZvcm1pby5nZXRQcm9qZWN0VXJsKCksICcnKTtcbiAgICAgICAgICByZXR1cm4gJHNjb3BlLmZvcm1pby5nZXRUZW1wVG9rZW4oMzYwMCwgJ0dFVDonICsgYWxsb3dlZFBhdGgpLnRoZW4oZnVuY3Rpb24odGVtcFRva2VuKSB7XG4gICAgICAgICAgICBkb3dubG9hZCArPSAnP3Rva2VuPScgKyB0ZW1wVG9rZW4ua2V5O1xuICAgICAgICAgICAgJHNjb3BlLmRvd25sb2FkVXJsID0gZG93bmxvYWQ7XG4gICAgICAgICAgICByZXR1cm4gZG93bmxvYWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIHRoZSBsaXZlIGZvcm0gcGFyYW1ldGVyIHRvIHRoZSB1cmwuXG4gICAgICAgIGlmICgkc2NvcGUuX3NyYyAmJiAoJHNjb3BlLl9zcmMuaW5kZXhPZignbGl2ZT0nKSA9PT0gLTEpKSB7XG4gICAgICAgICAgJHNjb3BlLl9zcmMgKz0gKCRzY29wZS5fc3JjLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnO1xuICAgICAgICAgICRzY29wZS5fc3JjICs9ICdsaXZlPTEnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbmRJZnJhbWVNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgIGlmcmFtZVJlYWR5LnByb21pc2UudGhlbihmdW5jdGlvbihpZnJhbWUpIHtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLCAnKicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS4kb24oJ2lmcmFtZS1yZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRzY29wZS5pZnJhbWVSZWFkeSA9IHRydWU7XG4gICAgICAgICAgdmFyIGlmcmFtZSA9ICRlbGVtZW50LmZpbmQoJy5mb3JtaW8taWZyYW1lJylbMF07XG4gICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgaWZyYW1lUmVhZHkucmVzb2x2ZShpZnJhbWUpO1xuICAgICAgICAgICAgaWYgKCRzY29wZS5mb3JtKSB7XG4gICAgICAgICAgICAgIHNlbmRJZnJhbWVNZXNzYWdlKHtuYW1lOiAnZm9ybScsIGRhdGE6ICRzY29wZS5mb3JtfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHNjb3BlLnN1Ym1pc3Npb24pIHtcbiAgICAgICAgICAgICAgc2VuZElmcmFtZU1lc3NhZ2Uoe25hbWU6ICdzdWJtaXNzaW9uJywgZGF0YTogJHNjb3BlLnN1Ym1pc3Npb259KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS4kb24oJ2lmcmFtZU1lc3NhZ2UnLCBmdW5jdGlvbihldmVudCwgbWVzc2FnZSkge1xuICAgICAgICAgIHNlbmRJZnJhbWVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY2FuY2VsRm9ybUxvYWRFdmVudCA9ICRzY29wZS4kb24oJ2Zvcm1Mb2FkJywgZnVuY3Rpb24oZXZlbnQsIGZvcm0pIHtcbiAgICAgICAgICBjYW5jZWxGb3JtTG9hZEV2ZW50KCk7XG4gICAgICAgICAgaWZyYW1lUmVhZHkucHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmdldFBERkRvd25sb2FkKGZvcm0uc2V0dGluZ3MucGRmKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZW5kSWZyYW1lTWVzc2FnZSh7bmFtZTogJ2Zvcm0nLCBkYXRhOiBmb3JtfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS4kb24oJ3N1Ym1pc3Npb25Mb2FkJywgZnVuY3Rpb24oZXZlbnQsIHN1Ym1pc3Npb24pIHtcbiAgICAgICAgICBzdWJtaXNzaW9uLmVkaXRhYmxlID0gISRzY29wZS5yZWFkT25seTtcbiAgICAgICAgICBzZW5kSWZyYW1lTWVzc2FnZSh7bmFtZTogJ3N1Ym1pc3Npb24nLCBkYXRhOiBzdWJtaXNzaW9ufSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1Ym1pdCB0aGUgZm9ybSBmcm9tIHRoZSBpZnJhbWUuXG4gICAgICAgICRzY29wZS4kb24oJ2lmcmFtZS1zdWJtaXNzaW9uJywgZnVuY3Rpb24oZXZlbnQsIHN1Ym1pc3Npb24pIHtcbiAgICAgICAgICAkc2NvcGUuc3VibWl0Rm9ybShzdWJtaXNzaW9uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2FsbGVkIGZyb20gdGhlIHN1Ym1pdCBvbiBpZnJhbWUuXG4gICAgICAgICRzY29wZS5zdWJtaXRJRnJhbWVGb3JtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VuZElmcmFtZU1lc3NhZ2Uoe25hbWU6ICdnZXRTdWJtaXNzaW9uJ30pO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS56b29tSW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZW5kSWZyYW1lTWVzc2FnZSh7bmFtZTogJ3pvb21Jbid9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuem9vbU91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbmRJZnJhbWVNZXNzYWdlKHtuYW1lOiAnem9vbU91dCd9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGT1ItNzFcbiAgICAgICAgaWYgKCEkc2NvcGUuX3NyYyAmJiAhJHNjb3BlLmJ1aWxkZXIpIHtcbiAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdzcmMnLCBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5fc3JjID0gc3JjO1xuICAgICAgICAgICAgJHNjb3BlLmZvcm1pbyA9IEZvcm1pb1Njb3BlLnJlZ2lzdGVyKCRzY29wZSwgJGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgZm9ybTogdHJ1ZSxcbiAgICAgICAgICAgICAgc3VibWlzc2lvbjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGZvcm1pbyBvYmplY3QuXG4gICAgICAgICRzY29wZS5mb3JtaW8gPSBGb3JtaW9TY29wZS5yZWdpc3Rlcigkc2NvcGUsICRlbGVtZW50LCB7XG4gICAgICAgICAgZm9ybTogdHJ1ZSxcbiAgICAgICAgICBzdWJtaXNzaW9uOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzY29wZS5jaGVja0Vycm9ycyA9IGZ1bmN0aW9uKGZvcm0pIHtcbiAgICAgICAgICBpZiAoZm9ybS5zdWJtaXR0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9ybS4kcHJpc3RpbmUgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZm9ybSkge1xuICAgICAgICAgICAgaWYgKGZvcm1ba2V5XSAmJiBmb3JtW2tleV0uaGFzT3duUHJvcGVydHkoJyRwcmlzdGluZScpKSB7XG4gICAgICAgICAgICAgIGZvcm1ba2V5XS4kcHJpc3RpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICFmb3JtLiR2YWxpZDtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuaXNWaXNpYmxlID0gZnVuY3Rpb24oY29tcG9uZW50LCByb3cpIHtcbiAgICAgICAgICByZXR1cm4gRm9ybWlvVXRpbHMuaXNWaXNpYmxlKFxuICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgJHNjb3BlLnN1Ym1pc3Npb24gPyAkc2NvcGUuc3VibWlzc2lvbi5kYXRhIDogbnVsbCxcbiAgICAgICAgICAgICRzY29wZS5oaWRlQ29tcG9uZW50c1xuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2hvdyB0aGUgc3VibWl0IG1lc3NhZ2UgYW5kIHNheSB0aGUgZm9ybSBpcyBubyBsb25nZXIgc3VibWl0dGluZy5cbiAgICAgICAgdmFyIG9uU3VibWl0ID0gZnVuY3Rpb24oc3VibWlzc2lvbiwgbWVzc2FnZSwgZm9ybSkge1xuICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0FsZXJ0cyh7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gYSBzdWJtaXNzaW9uIGhhcyBiZWVuIG1hZGUuXG4gICAgICAgIHZhciBvblN1Ym1pdERvbmUgPSBmdW5jdGlvbihtZXRob2QsIHN1Ym1pc3Npb24sIGZvcm0pIHtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICAgIGlmICgkc2NvcGUub3B0aW9ucyAmJiAkc2NvcGUub3B0aW9ucy5zdWJtaXRNZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gJHNjb3BlLm9wdGlvbnMuc3VibWl0TWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gJ1N1Ym1pc3Npb24gd2FzICcgKyAoKG1ldGhvZCA9PT0gJ3B1dCcpID8gJ3VwZGF0ZWQnIDogJ2NyZWF0ZWQnKSArICcuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb25TdWJtaXQoc3VibWlzc2lvbiwgbWVzc2FnZSwgZm9ybSk7XG4gICAgICAgICAgLy8gVHJpZ2dlciB0aGUgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICAgICRzY29wZS4kZW1pdCgnZm9ybVN1Ym1pc3Npb24nLCBzdWJtaXNzaW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuc3VibWl0Rm9ybSA9IGZ1bmN0aW9uKHN1Ym1pc3Npb25EYXRhLCBmb3JtKSB7XG4gICAgICAgICAgLy8gQWxsb3cgY3VzdG9tIGFjdGlvbiB1cmxzLlxuICAgICAgICAgIGlmICgkc2NvcGUuYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gc3VibWlzc2lvbkRhdGEuX2lkID8gJ3B1dCcgOiAncG9zdCc7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gJHNjb3BlLmFjdGlvbjtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYWN0aW9uIElkIGlmIGl0IGlzIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIHVybC5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdwdXQnICYmIChhY3Rpb24uaW5kZXhPZihzdWJtaXNzaW9uRGF0YS5faWQpID09PSAtMSkpIHtcbiAgICAgICAgICAgICAgYWN0aW9uICs9ICcvJyArIHN1Ym1pc3Npb25EYXRhLl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRodHRwW21ldGhvZF0oYWN0aW9uLCBzdWJtaXNzaW9uRGF0YSkudGhlbihmdW5jdGlvbihzdWJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgIEZvcm1pby5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgICAgIG9uU3VibWl0RG9uZShtZXRob2QsIHN1Ym1pc3Npb24sIGZvcm0pO1xuICAgICAgICAgICAgfSwgRm9ybWlvU2NvcGUub25FcnJvcigkc2NvcGUsICRlbGVtZW50KSlcbiAgICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0dGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhleSB3aXNoIHRvIHN1Ym1pdCB0byB0aGUgZGVmYXVsdCBsb2NhdGlvbi5cbiAgICAgICAgICBlbHNlIGlmICgkc2NvcGUuZm9ybWlvICYmICEkc2NvcGUuZm9ybWlvLm5vU3VibWl0KSB7XG4gICAgICAgICAgICAvLyBjb3B5IHRvIHJlbW92ZSBhbmd1bGFyICQkaGFzaEtleVxuICAgICAgICAgICAgJHNjb3BlLmZvcm1pby5zYXZlU3VibWlzc2lvbihzdWJtaXNzaW9uRGF0YSwgJHNjb3BlLmZvcm1pb09wdGlvbnMpLnRoZW4oZnVuY3Rpb24oc3VibWlzc2lvbikge1xuICAgICAgICAgICAgICBvblN1Ym1pdERvbmUoc3VibWlzc2lvbi5tZXRob2QsIHN1Ym1pc3Npb24sIGZvcm0pO1xuICAgICAgICAgICAgfSwgRm9ybWlvU2NvcGUub25FcnJvcigkc2NvcGUsICRlbGVtZW50KSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtU3VibWlzc2lvbicsIHN1Ym1pc3Npb25EYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmlzRGlzYWJsZWQgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gJHNjb3BlLnJlYWRPbmx5IHx8IGNvbXBvbmVudC5kaXNhYmxlZCB8fCAoQXJyYXkuaXNBcnJheSgkc2NvcGUuZGlzYWJsZUNvbXBvbmVudHMpICYmICRzY29wZS5kaXNhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudC5rZXkpICE9PSAtMSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmlzUmVxdWlyZWQgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gRm9ybWlvVXRpbHMuaXNSZXF1aXJlZChjb21wb25lbnQsICRzY29wZS5yZXF1aXJlQ29tcG9uZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGZvcm0gaXMgc3VibWl0dGVkLlxuICAgICAgICAkc2NvcGUub25TdWJtaXQgPSBmdW5jdGlvbihmb3JtKSB7XG4gICAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFtdO1xuICAgICAgICAgIGlmICgkc2NvcGUuY2hlY2tFcnJvcnMoZm9ybSkpIHtcbiAgICAgICAgICAgICRzY29wZS5mb3JtaW9BbGVydHMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGZpeCB0aGUgZm9sbG93aW5nIGVycm9ycyBiZWZvcmUgc3VibWl0dGluZy4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3JtLnN1Ym1pdHRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgc2FuaXRpemVkIHN1Ym1pc3Npb24gb2JqZWN0LlxuICAgICAgICAgIHZhciBzdWJtaXNzaW9uRGF0YSA9IHtkYXRhOiB7fX07XG4gICAgICAgICAgaWYgKCRzY29wZS5zdWJtaXNzaW9uLl9pZCkge1xuICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuX2lkID0gJHNjb3BlLnN1Ym1pc3Npb24uX2lkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJHNjb3BlLnN1Ym1pc3Npb24uZGF0YS5faWQpIHtcbiAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLl9pZCA9ICRzY29wZS5zdWJtaXNzaW9uLmRhdGEuX2lkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBncmFiSWRzID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICBpbnB1dCA9IFtpbnB1dF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaW5hbCA9IFtdO1xuICAgICAgICAgICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX2lkKSB7XG4gICAgICAgICAgICAgICAgZmluYWwucHVzaChlbGVtZW50Ll9pZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0UGVybWlzc2lvbnMgPSB7fTtcbiAgICAgICAgICBGb3JtaW9VdGlscy5lYWNoQ29tcG9uZW50KCRzY29wZS5mb3JtLmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50eXBlID09PSAncmVzb3VyY2UnICYmIGNvbXBvbmVudC5rZXkgJiYgY29tcG9uZW50LmRlZmF1bHRQZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRQZXJtaXNzaW9uc1tjb21wb25lbnQua2V5XSA9IGNvbXBvbmVudC5kZWZhdWx0UGVybWlzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuc3VibWlzc2lvbi5kYXRhLmhhc093blByb3BlcnR5KGNvbXBvbmVudC5rZXkpKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICRzY29wZS5zdWJtaXNzaW9uLmRhdGFbY29tcG9uZW50LmtleV07XG4gICAgICAgICAgICAgIGlmIChjb21wb25lbnQudHlwZSA9PT0gJ251bWJlcicgJiYgKHZhbHVlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLmRhdGFbY29tcG9uZW50LmtleV0gPSB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uRGF0YS5kYXRhW2NvbXBvbmVudC5rZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuc3VibWlzc2lvbi5kYXRhLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgIXZhbHVlLmhhc093blByb3BlcnR5KCdfaWQnKSkge1xuICAgICAgICAgICAgICBzdWJtaXNzaW9uRGF0YS5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgdGhlIHN1Ym1pc3Npb24gYWNjZXNzLlxuICAgICAgICAgICAgdmFyIHBlcm0gPSBkZWZhdWx0UGVybWlzc2lvbnNba2V5XTtcbiAgICAgICAgICAgIGlmIChwZXJtKSB7XG4gICAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLmFjY2VzcyA9IHN1Ym1pc3Npb25EYXRhLmFjY2VzcyB8fCBbXTtcblxuICAgICAgICAgICAgICAvLyBDb2VyY2UgdmFsdWUgaW50byBhbiBhcnJheSBmb3IgcGx1Y2tpbmcuXG4gICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYW5kIHVwZGF0ZSBhbiBleGlzdGluZyBwZXJtaXNzaW9uLlxuICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuYWNjZXNzLmZvckVhY2goZnVuY3Rpb24ocGVybWlzc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChwZXJtaXNzaW9uLnR5cGUgPT09IHBlcm0pIHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb24ucmVzb3VyY2VzID0gcGVybWlzc2lvbi5yZXNvdXJjZXMgfHwgW107XG4gICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uLnJlc291cmNlcy5jb25jYXQoZ3JhYklkcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gQWRkIGEgcGVybWlzc2lvbiwgYmVjYXVzZSBvbmUgd2FzIG5vdCBmb3VuZC5cbiAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLmFjY2Vzcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHBlcm0sXG4gICAgICAgICAgICAgICAgICByZXNvdXJjZXM6IGdyYWJJZHModmFsdWUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEFsbG93IHRoZSBmb3JtIHRvIGJlIGNvbXBsZXRlZCBleHRlcm5hbGx5LlxuICAgICAgICAgICRzY29wZS4kb24oJ3N1Ym1pdERvbmUnLCBmdW5jdGlvbihldmVudCwgc3VibWlzc2lvbiwgbWVzc2FnZSkge1xuICAgICAgICAgICAgb25TdWJtaXQoc3VibWlzc2lvbiwgbWVzc2FnZSwgZm9ybSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBBbGxvdyBhbiBlcnJvciB0byBiZSB0aHJvd24gZXh0ZXJuYWxseS5cbiAgICAgICAgICAkc2NvcGUuJG9uKCdzdWJtaXRFcnJvcicsIGZ1bmN0aW9uKGV2ZW50LCBlcnJvcikge1xuICAgICAgICAgICAgRm9ybWlvU2NvcGUub25FcnJvcigkc2NvcGUsICRlbGVtZW50KShlcnJvcik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgc3VibWl0RXZlbnQgPSAkc2NvcGUuJGVtaXQoJ2Zvcm1TdWJtaXQnLCBzdWJtaXNzaW9uRGF0YSk7XG4gICAgICAgICAgaWYgKHN1Ym1pdEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIC8vIExpc3RlbmVyIHdhbnRzIHRvIGNhbmNlbCB0aGUgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgICAgICBmb3JtLnN1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gbWFrZSBhIGNvcHkgb2YgdGhlIHN1Ym1pc3Npb24gZGF0YSB0byByZW1vdmUgYmFkIGNoYXJhY3RlcnMuXG4gICAgICAgICAgc3VibWlzc2lvbkRhdGEgPSBhbmd1bGFyLmNvcHkoc3VibWlzc2lvbkRhdGEpO1xuICAgICAgICAgICRzY29wZS5zdWJtaXRGb3JtKHN1Ym1pc3Npb25EYXRhLCBmb3JtKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBdLFxuICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvLmh0bWwnXG4gIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFsnJHNjZScsICckcGFyc2UnLCAnJGNvbXBpbGUnLCBmdW5jdGlvbigkc2NlLCAkcGFyc2UsICRjb21waWxlKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBmb3JtaW9CaW5kSHRtbENvbXBpbGUodEVsZW1lbnQsIHRBdHRycykge1xuICAgICAgdmFyIGZvcm1pb0JpbmRIdG1sR2V0dGVyID0gJHBhcnNlKHRBdHRycy5mb3JtaW9CaW5kSHRtbCk7XG4gICAgICAkY29tcGlsZS4kJGFkZEJpbmRpbmdDbGFzcyh0RWxlbWVudCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gZm9ybWlvQmluZEh0bWxMaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gICAgICAgICRjb21waWxlLiQkYWRkQmluZGluZ0luZm8oZWxlbWVudCwgYXR0ci5mb3JtaW9CaW5kSHRtbCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZvcm1pb0JpbmRIdG1sR2V0dGVyKHNjb3BlKTtcbiAgICAgICAgZWxlbWVudC5odG1sKCRzY2UuZ2V0VHJ1c3RlZEh0bWwodmFsdWUpIHx8ICcnKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufV07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfY2xvbmVEZWVwID0gcmVxdWlyZSgnbG9kYXNoL2Nsb25lRGVlcCcpO1xudmFyIF9maWx0ZXIgPSByZXF1aXJlKCdsb2Rhc2gvZmlsdGVyJyk7XG52YXIgX2dldCA9IHJlcXVpcmUoJ2xvZGFzaC9nZXQnKTtcblxuLy8gRk9SLTUyNCAtIEF0dGVtcHQgdG8gbG9hZCBqc29uIGxvZ2ljLlxudmFyIGpzb25Mb2dpYztcbnRyeSB7XG4gIGpzb25Mb2dpYyA9IHJlcXVpcmUoJ2pzb24tbG9naWMtanMnKSB8fCB1bmRlZmluZWQ7XG59XG5jYXRjaCAoZSkge1xuICAvLyBJZ25vcmUgb3B0aW9uYWwgbW9kdWxlLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ0Zvcm1pbycsXG4gICdmb3JtaW9Db21wb25lbnRzJyxcbiAgZnVuY3Rpb24oXG4gICAgRm9ybWlvLFxuICAgIGZvcm1pb0NvbXBvbmVudHNcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgcmVxdWlyZTogJz9eZm9ybWlvJyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGNvbXBvbmVudDogJz0nLFxuICAgICAgICBkYXRhOiAnPScsXG4gICAgICAgIHN1Ym1pc3Npb246ICc9JyxcbiAgICAgICAgaGlkZUNvbXBvbmVudHM6ICc9JyxcbiAgICAgICAgZm9ybWlvOiAnPScsXG4gICAgICAgIGZvcm1pb0Zvcm06ICc9JyxcbiAgICAgICAgcmVhZE9ubHk6ICc9JyxcbiAgICAgICAgZ3JpZFJvdzogJz0nLFxuICAgICAgICBncmlkQ29sOiAnPScsXG4gICAgICAgIGJ1aWxkZXI6ICc9PydcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9jb21wb25lbnQuaHRtbCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWwsIGF0dHJzLCBmb3JtaW9DdHJsKSB7XG4gICAgICAgIGlmIChmb3JtaW9DdHJsKSB7XG4gICAgICAgICAgc2NvcGUuc2hvd0FsZXJ0cyA9IGZvcm1pb0N0cmwuc2hvd0FsZXJ0cy5iaW5kKGZvcm1pb0N0cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNjb3BlLnNob3dBbGVydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgJHNjb3BlLnNob3dBbGVydHMgdW5sZXNzIHRoaXMgY29tcG9uZW50IGlzIGluc2lkZSBhIGZvcm1pbyBkaXJlY3RpdmUuJyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgJyRzY29wZScsXG4gICAgICAgICckaHR0cCcsXG4gICAgICAgICckY29udHJvbGxlcicsXG4gICAgICAgICdGb3JtaW9VdGlscycsXG4gICAgICAgICckdGltZW91dCcsXG4gICAgICAgIGZ1bmN0aW9uKFxuICAgICAgICAgICRzY29wZSxcbiAgICAgICAgICAkaHR0cCxcbiAgICAgICAgICAkY29udHJvbGxlcixcbiAgICAgICAgICBGb3JtaW9VdGlscyxcbiAgICAgICAgICAkdGltZW91dFxuICAgICAgICApIHtcbiAgICAgICAgICAkc2NvcGUuYnVpbGRlciA9ICRzY29wZS5idWlsZGVyIHx8IGZhbHNlO1xuICAgICAgICAgIC8vIE9wdGlvbnMgdG8gbWF0Y2gganF1ZXJ5Lm1hc2tlZGlucHV0IG1hc2tzXG4gICAgICAgICAgJHNjb3BlLnVpTWFza09wdGlvbnMgPSB7XG4gICAgICAgICAgICBtYXNrRGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgICAgJzknOiAvXFxkLyxcbiAgICAgICAgICAgICAgJ2EnOiAvW2EtekEtWl0vLFxuICAgICAgICAgICAgICAnKic6IC9bYS16QS1aMC05XS9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhck9uQmx1cjogZmFsc2UsXG4gICAgICAgICAgICBldmVudHNUb0hhbmRsZTogWydpbnB1dCcsICdrZXl1cCcsICdjbGljaycsICdmb2N1cyddLFxuICAgICAgICAgICAgc2lsZW50RXZlbnRzOiBbJ2NsaWNrJywgJ2ZvY3VzJ11cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gU2VlIGlmIHRoaXMgY29tcG9uZW50IGlzIHZpc2libGUgb3Igbm90LlxuICAgICAgICAgICRzY29wZS5pc1Zpc2libGUgPSBmdW5jdGlvbihjb21wb25lbnQsIHJvdykge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBGb3JtaW9VdGlscy5pc1Zpc2libGUoXG4gICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAkc2NvcGUuc3VibWlzc2lvbiA/ICRzY29wZS5zdWJtaXNzaW9uLmRhdGEgOiBudWxsLFxuICAgICAgICAgICAgICAkc2NvcGUuaGlkZUNvbXBvbmVudHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEZPUi0yNDUgLSBGaXggcmVzZXQgYnV0dG9ucy5cbiAgICAgICAgICAkc2NvcGUucmVzZXRGb3JtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBNYW51YWxseSByZW1vdmUgZWFjaCBrZXkgc28gd2UgZG9uJ3QgbG9zZSBhIHJlZmVyZW5jZSB0byBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gZGF0YSBpbiBjaGlsZCBzY29wZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gJHNjb3BlLmRhdGEpIHtcbiAgICAgICAgICAgICAgZGVsZXRlICRzY29wZS5kYXRhW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgICRzY29wZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJHNjb3BlLnJlYWRPbmx5IHx8ICh0eXBlb2YgJHNjb3BlLiRwYXJlbnQuaXNEaXNhYmxlZCA9PT0gJ2Z1bmN0aW9uJyAmJiAkc2NvcGUuJHBhcmVudC5pc0Rpc2FibGVkKGNvbXBvbmVudCkpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAkc2NvcGUuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1pb1V0aWxzLmlzUmVxdWlyZWQoY29tcG9uZW50KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gUGFzcyB0aHJvdWdoIGNoZWNrQ29uZGl0aW9uYWwgc2luY2UgdGhpcyBpcyBhbiBpc29sYXRlIHNjb3BlLlxuICAgICAgICAgICRzY29wZS5jaGVja0NvbmRpdGlvbmFsID0gJHNjb3BlLiRwYXJlbnQuY2hlY2tDb25kaXRpb25hbDtcblxuICAgICAgICAgIC8vIEZPUi03MSAtIERvbnQgd2F0Y2ggaW4gdGhlIGJ1aWxkZXIgdmlldy5cbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdmFsdWUgd2hlbiBkYXRhIGNoYW5nZXMuXG4gICAgICAgICAgaWYgKCEkc2NvcGUuYnVpbGRlciAmJiAoJHNjb3BlLmNvbXBvbmVudC5jYWxjdWxhdGVWYWx1ZSB8fCAoanNvbkxvZ2ljICYmIF9nZXQoJHNjb3BlLmNvbXBvbmVudCwgJ3ZhbGlkYXRlLmpzb24nKSkpKSB7XG4gICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdkYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIC8vIFByb2Nlc3MgY2FsY3VsYXRlZCB2YWx1ZSBzdHVmZiBpZiBwcmVzZW50LlxuICAgICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5jYWxjdWxhdGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSBldmFsKCcoZnVuY3Rpb24oZGF0YSkgeyB2YXIgdmFsdWUgPSBbXTsnICsgJHNjb3BlLmNvbXBvbmVudC5jYWxjdWxhdGVWYWx1ZS50b1N0cmluZygpICsgJzsgcmV0dXJuIHZhbHVlOyB9KSgkc2NvcGUuZGF0YSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZWQgY2FsY3VsYXRpbmcgYSB2YWx1ZSBmb3IgJyArICRzY29wZS5jb21wb25lbnQua2V5LCBlKTtcbiAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFByb2Nlc3MganNvbkxvZ2ljIHN0dWZmIGlmIHByZXNlbnQuXG4gICAgICAgICAgICAgIGlmIChqc29uTG9naWMgJiYgX2dldCgkc2NvcGUuY29tcG9uZW50LCAndmFsaWRhdGUuanNvbicpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0O1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBqc29uIHBhcnNlIG9uY2UuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLmpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IEpTT04ucGFyc2UoJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZS5qc29uKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZS5qc29uID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBKU09OIHZhbGlkYXRvciBnaXZlbiBmb3IgJyArICRzY29wZS5jb21wb25lbnQua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCRzY29wZS5jb21wb25lbnQudmFsaWRhdGUuanNvbik7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZS5qc29uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaW5wdXQgPSAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLmpzb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YWxpZCA9IGpzb25Mb2dpYy5hcHBseShpbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAkc2NvcGUuc3VibWlzc2lvbi5kYXRhLFxuICAgICAgICAgICAgICAgICAgICByb3c6ICRzY29wZS5kYXRhXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgdmFsaWQgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuY3VzdG9tRXJyb3IgPSB2YWxpZDtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZm9ybWlvRm9ybVskc2NvcGUuY29tcG9uZW50LmtleV0uJHNldFZhbGlkaXR5KCdjdXN0b20nLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1pb0Zvcm1bJHNjb3BlLmNvbXBvbmVudC5rZXldLiRzZXRWYWxpZGl0eSgnY3VzdG9tJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IGlzc3VlcyB3aGlsZSBlZGl0aW5nIHRoZSBjb21wb25lbnRzLlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHZXQgdGhlIHNldHRpbmdzLlxuICAgICAgICAgIHZhciBjb21wb25lbnQgPSBmb3JtaW9Db21wb25lbnRzLmNvbXBvbmVudHNbJHNjb3BlLmNvbXBvbmVudC50eXBlXSB8fCBmb3JtaW9Db21wb25lbnRzLmNvbXBvbmVudHNbJ2N1c3RvbSddO1xuXG4gICAgICAgICAgLy8gU2V0IHRoZSBjb21wb25lbnQgd2l0aCB0aGUgZGVmYXVsdHMgZnJvbSB0aGUgY29tcG9uZW50IHNldHRpbmdzLlxuICAgICAgICAgIC8vIERvbnQgYWRkIHRoZSBkZWZhdWx0IGtleSwgc28gdGhhdCBjb21wb25lbnRzIHdpdGhvdXQga2V5cyB3aWxsIHJlbWFpbiB2aXNpYmxlIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbXBvbmVudC5zZXR0aW5ncywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50Lmhhc093blByb3BlcnR5KGtleSkgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50W2tleV0gPSBhbmd1bGFyLmNvcHkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQWRkIGEgbmV3IGZpZWxkIHZhbHVlLlxuICAgICAgICAgICRzY29wZS5hZGRGaWVsZFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdjdXN0b21EZWZhdWx0VmFsdWUnKSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfY2xvbmVEZWVwKCRzY29wZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBldmFsKCcoZnVuY3Rpb24oZGF0YSkgeyB2YXIgdmFsdWUgPSBcIlwiOycgKyAkc2NvcGUuY29tcG9uZW50LmN1c3RvbURlZmF1bHRWYWx1ZS50b1N0cmluZygpICsgJzsgcmV0dXJuIHZhbHVlOyB9KShkYXRhKScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZW5kIGluIGEgY3VzdG9tIGRlZmF1bHQgdmFsdWUgaW4gJyArICRzY29wZS5jb21wb25lbnQua2V5LCBlKTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgkc2NvcGUuY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgICAgICAgICAgICAvLyBGaXggZm9yIHNlbGVjdCBjb21wb25lbnRzXG4gICAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LnR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGEga2V5OnZhbHVlIHNlYXJjaFxuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gJHNjb3BlLmNvbXBvbmVudC5kZWZhdWx0VmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgLy8gSWYgb25seSBvbmUgcGFydCB3YXMgc3BlY2lmaWVkLCBzZWFyY2ggYnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2ZpbHRlcigkc2NvcGUuc2VsZWN0SXRlbXMsIHt2YWx1ZTogcGFydHNbMF19KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmltIHJlc3VsdHMgYmFzZWQgb24gbXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50Lm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0d28gcGFydHMgd2VyZSBzcGVjaWZpZWQsIGFsbG93IGZvciBrZXkgYW5kIHZhbHVlIGN1c3RvbWl6YXRpb24uXG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hbcGFydHNbMF1dID0gcGFydHNbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IF9maWx0ZXIoJHNjb3BlLnNlbGVjdEl0ZW1zLCBzZWFyY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaW0gcmVzdWx0cyBiYXNlZCBvbiBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS5jb21wb25lbnQubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBbiBpc3N1ZSBvY2N1cnJlZCB3aXRoIHRoZSBzZWxlY3QgZGVmYXVsdFZhbHVlIGZvcjogJyArICRzY29wZS5jb21wb25lbnQua2V5KTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgZmluZCBkZWZhdWx0VmFsdWUgKCcgKyAkc2NvcGUuZGVmYXVsdFZhbHVlICsgJykgaW4gdGhlIHNlbGVjdEl0ZW1zJyk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygkc2NvcGUuc2VsZWN0SXRlbXMpO1xuICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHNjb3BlLmNvbXBvbmVudC5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSB8fCBbXTtcbiAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIGEgZmllbGQgdmFsdWUuXG4gICAgICAgICAgJHNjb3BlLnJlbW92ZUZpZWxkVmFsdWUgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KCRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSkpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gU2V0IHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudC50ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgJHNjb3BlLnRlbXBsYXRlID0gY29tcG9uZW50LnRlbXBsYXRlKCRzY29wZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnRlbXBsYXRlID0gY29tcG9uZW50LnRlbXBsYXRlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFsbG93IGNvbXBvbmVudCBrZXlzIHRvIGxvb2sgbGlrZSBcInNldHRpbmdzW3VzZXJuYW1lXVwiXG4gICAgICAgICAgaWYgKCRzY29wZS5jb21wb25lbnQua2V5ICYmICRzY29wZS5jb21wb25lbnQua2V5LmluZGV4T2YoJ1snKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gJHNjb3BlLmNvbXBvbmVudC5rZXkubWF0Y2goLyhbXlxcW10rKVxcWyhbXl0rKVxcXS8pO1xuICAgICAgICAgICAgaWYgKChtYXRjaGVzLmxlbmd0aCA9PT0gMykgJiYgJHNjb3BlLmRhdGEuaGFzT3duUHJvcGVydHkobWF0Y2hlc1sxXSkpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGEgPSAkc2NvcGUuZGF0YVttYXRjaGVzWzFdXTtcbiAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5rZXkgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgaGFzIGEgY29udHJvbGxlci5cbiAgICAgICAgICBpZiAoY29tcG9uZW50LmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIE1haW50YWluIHJldmVyc2UgY29tcGF0aWJpbGl0eSBieSBleGVjdXRpbmcgdGhlIG9sZCBtZXRob2Qgc3R5bGUuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5jb250cm9sbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5jb250cm9sbGVyKCRzY29wZS5jb21wb25lbnQsICRzY29wZSwgJGh0dHAsIEZvcm1pbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgJGNvbnRyb2xsZXIoY29tcG9uZW50LmNvbnRyb2xsZXIsIHskc2NvcGU6ICRzY29wZSwgJHRpbWVvdXQ6ICR0aW1lb3V0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRk9SLTcxIC0gRG9udCB3YXRjaCBpbiB0aGUgYnVpbGRlciB2aWV3LlxuICAgICAgICAgIGlmICghJHNjb3BlLmJ1aWxkZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNpbmcgdGhlIGxpc3Qgb2YgZGVmYXVsdCBvcHRpb25zLCBzcGxpdCB0aGVtIHdpdGggdGhlIGlkZW50aWZpZXIsIGFuZCB1c2UgZmlsdGVyIHRvIGdldCBlYWNoIGl0ZW0uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIGRlZmF1bHRJdGVtc1xuICAgICAgICAgICAgICogQHBhcmFtIHNlYXJjaEl0ZW1zXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBwbHVja0l0ZW1zID0gZnVuY3Rpb24oZGVmYXVsdEl0ZW1zLCBzZWFyY2hJdGVtcykge1xuICAgICAgICAgICAgICB2YXIgdGVtcCA9IFtdO1xuICAgICAgICAgICAgICBpZiAoIWRlZmF1bHRJdGVtcyB8fCAhZGVmYXVsdEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdEl0ZW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRJdGVtcyA9IFtkZWZhdWx0SXRlbXNdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVmYXVsdEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGl0ZW0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2ZpbHRlcihzZWFyY2hJdGVtcywgZnVuY3Rpb24ocG90ZW50aWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZ2V0KHBvdGVudGlhbCwgcGFydHNbMF0pID09PSBwYXJ0c1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdGVtcC5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybiB0ZW1wO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaCgnY29tcG9uZW50Lm11bHRpcGxlJywgZnVuY3Rpb24obXVsdCkge1xuICAgICAgICAgICAgICAvLyBFc3RhYmxpc2ggYSBkZWZhdWx0IGZvciBkYXRhLlxuICAgICAgICAgICAgICAkc2NvcGUuZGF0YSA9ICRzY29wZS5kYXRhIHx8IHt9O1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuXG4gICAgICAgICAgICAgIC8vIFVzZSB0aGUgY3VycmVudCBkYXRhIG9yIGRlZmF1bHQuXG4gICAgICAgICAgICAgIGlmICgkc2NvcGUuZGF0YS5oYXNPd25Qcm9wZXJ0eSgkc2NvcGUuY29tcG9uZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW11bHQpIHtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIHZhbHVlIGlzIHByZXNlbnQsIGFuZCBpdHMgYW4gYXJyYXksIGFzc2lnbiBpdCB0byB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgYSB2YWx1ZSBpcyBwcmVzZW50IGFuZCBpdCBpcyBub3QgYW4gYXJyYXksIHdyYXAgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoJHNjb3BlLmNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tRGVmYXVsdFZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW11bHQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXZhbCgnKGZ1bmN0aW9uKGRhdGEpIHsgdmFyIHZhbHVlID0gXCJcIjsnICsgJHNjb3BlLmNvbXBvbmVudC5jdXN0b21EZWZhdWx0VmFsdWUudG9TdHJpbmcoKSArICc7IHJldHVybiB2YWx1ZTsgfSkoJHNjb3BlLmRhdGEpJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZW5kIGluIGEgY3VzdG9tIGRlZmF1bHQgdmFsdWUgaW4gJyArICRzY29wZS5jb21wb25lbnQua2V5LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBldmFsKCcoZnVuY3Rpb24oZGF0YSkgeyB2YXIgdmFsdWUgPSBcIlwiOycgKyAkc2NvcGUuY29tcG9uZW50LmN1c3RvbURlZmF1bHRWYWx1ZS50b1N0cmluZygpICsgJzsgcmV0dXJuIHZhbHVlOyB9KSgkc2NvcGUuZGF0YSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZW5kIGluIGEgY3VzdG9tIGRlZmF1bHQgdmFsdWUgaW4gJyArICRzY29wZS5jb21wb25lbnQua2V5LCBlKTtcbiAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCRzY29wZS5jb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgLy8gRkEtODM1IC0gVGhlIGRlZmF1bHQgdmFsdWVzIGZvciBzZWxlY3QgYm94ZXMgYXJlIHNldCBpbiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LnR5cGUgPT09ICdzZWxlY3Rib3hlcycpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGRlZmF1bHQgdmFsdWUgYW5kIGl0IGlzIG5vdCBhbiBhcnJheSwgd3JhcCB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKG11bHQgJiYgdHlwZW9mICRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkc2NvcGUuY29tcG9uZW50LmRlZmF1bHRWYWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNjb3BlLmNvbXBvbmVudC5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZGVmYXVsdCBpcyBwcm92aWRlZCwgdGhlbiBza2lwLi4uXG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRk9SLTE5MyAtIEZpeCBkZWZhdWx0IHZhbHVlIGZvciB0aGUgbnVtYmVyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAvLyBGT1ItMjYyIC0gRml4IG11bHRpcGxlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBudW1iZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW11bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRk9SLTI5MCAtIEZpeCBkZWZhdWx0IHZhbHVlcyBmb3IgbnVtYmVyIGNvbXBvbmVudHMsIHRvIGFsbG93IGRlY2ltYWwgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSBwYXJzZUZsb2F0KCRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSBwYXJzZUludCgkc2NvcGUuY29tcG9uZW50LmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gdmFsdWUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGT1ItMjkwIC0gRml4IGRlZmF1bHQgdmFsdWVzIGZvciBudW1iZXIgY29tcG9uZW50cywgdG8gYWxsb3cgZGVjaW1hbCBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRk9SLTEzNSAtIEFkZCBkZWZhdWx0IHZhbHVlcyBmb3Igc2VsZWN0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJHNjb3BlLmNvbXBvbmVudC50eXBlID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgICAgICAgLy8gRk9SLTMzNyAtIEZpeCBkZWZhdWx0IHZhbHVlcyBmb3Igc2VsZWN0IGNvbXBvbmVudHMgd2l0aG91dCBtdWx0aSBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgaWYgKCFtdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vIElmIHVzaW5nIHRoZSB2YWx1ZXMgaW5wdXQsIHNwbGl0IHRoZSBkZWZhdWx0IHZhbHVlcywgYW5kIHNlYXJjaCB0aGUgb3B0aW9ucyBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LmRhdGFTcmMgPT09ICd2YWx1ZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5kYXRhLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihpdGVtLnZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIElmIHVzaW5nIGpzb24gaW5wdXQsIHNwbGl0IHRoZSB2YWx1ZXMgYW5kIHNlYXJjaCBlYWNoIGtleSBwYXRoIGZvciB0aGUgaXRlbVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJHNjb3BlLmNvbXBvbmVudC5kYXRhU3JjID09PSAnanNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAkc2NvcGUuY29tcG9uZW50LmRhdGEuanNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5kYXRhLmpzb24gPSBKU09OLnBhcnNlKCRzY29wZS5jb21wb25lbnQuZGF0YS5qc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBwYXJzZSB0aGUgZ2l2ZW4gSlNPTiBmb3IgdGhlIHNlbGVjdCBjb21wb25lbnQ6ICcgKyAkc2NvcGUuY29tcG9uZW50LmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygkc2NvcGUuY29tcG9uZW50LmRhdGEuanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuZGF0YS5qc29uID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gcGx1Y2tJdGVtcyh2YWx1ZSwgJHNjb3BlLmNvbXBvbmVudC5kYXRhLmpzb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICgkc2NvcGUuY29tcG9uZW50LmRhdGFTcmMgPT09ICd1cmwnIHx8ICRzY29wZS5jb21wb25lbnQuZGF0YVNyYyA9PT0gJ3Jlc291cmNlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IHVudGlsIGxvYWRpbmcgaXMgZG9uZS5cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbignc2VsZWN0TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gcGx1Y2tJdGVtcyh2YWx1ZSwgJHNjb3BlLnNlbGVjdEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZPUi01MDQgLSBGaXggZGVmYXVsdCB2YWx1ZXMgZm9yIHN1cnZleSBjb21wb25lbnRzLlxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCRzY29wZS5jb21wb25lbnQudHlwZSA9PT0gJ3N1cnZleScpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLmNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gfHwge307XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LnF1ZXN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHF1ZXN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XVtxdWVzdGlvbi52YWx1ZV0gPSAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV1bcXVlc3Rpb24udmFsdWVdIHx8ICRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSAkc2NvcGUuY29tcG9uZW50LmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGRlZmF1bHQgdmFsdWUgYW5kIGl0IGlzIGFuIGFycmF5LCBhc3NpZ24gaXQgdG8gdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gJHNjb3BlLmNvbXBvbmVudC5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgZGVmYXVsdFZhbHVlIGEgc2luZ2xlIGVsZW1lbnQgYXJyYXkgYmVjYXVzZSB3ZXJlIG11bHRpLlxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gWyRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBDb3VsZG4ndCBzYWZlbHkgZGVmYXVsdCwgZG9uJ3QgYWRkIGEgZ2FyYmFnZSB2YWx1ZS5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRoZSBjb21wb25lbnQgbmFtZS5cbiAgICAgICAgICAkc2NvcGUuY29tcG9uZW50SWQgPSAkc2NvcGUuY29tcG9uZW50LmtleTtcbiAgICAgICAgICBpZiAoJHNjb3BlLmdyaWRSb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudElkICs9ICgnLScgKyAkc2NvcGUuZ3JpZFJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkc2NvcGUuZ3JpZENvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50SWQgKz0gKCctJyArICRzY29wZS5ncmlkQ29sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XG5dO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2Zvcm1pb0NvbXBvbmVudHMnLFxuICBmdW5jdGlvbihcbiAgICBmb3JtaW9Db21wb25lbnRzXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGNvbXBvbmVudDogJz0nLFxuICAgICAgICBkYXRhOiAnPScsXG4gICAgICAgIGZvcm06ICc9JyxcbiAgICAgICAgc3VibWlzc2lvbjogJz0nLFxuICAgICAgICBpZ25vcmU6ICc9PycsXG4gICAgICAgIGJ1aWxkZXI6ICc9PydcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9jb21wb25lbnQtdmlldy5odG1sJyxcbiAgICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICAgJyRzY29wZScsXG4gICAgICAgICdGb3JtaW8nLFxuICAgICAgICAnRm9ybWlvVXRpbHMnLFxuICAgICAgICBmdW5jdGlvbihcbiAgICAgICAgICAkc2NvcGUsXG4gICAgICAgICAgRm9ybWlvLFxuICAgICAgICAgIEZvcm1pb1V0aWxzXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFNldCB0aGUgZm9ybSB1cmwuXG4gICAgICAgICAgJHNjb3BlLmZvcm1VcmwgPSAkc2NvcGUuZm9ybSA/IEZvcm1pby5nZXRBcHBVcmwoKSArICcvZm9ybS8nICsgJHNjb3BlLmZvcm0uX2lkLnRvU3RyaW5nKCkgOiAnJztcbiAgICAgICAgICAkc2NvcGUuaXNWaXNpYmxlID0gZnVuY3Rpb24oY29tcG9uZW50LCByb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBGb3JtaW9VdGlscy5pc1Zpc2libGUoXG4gICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAkc2NvcGUuc3VibWlzc2lvbiA/ICRzY29wZS5zdWJtaXNzaW9uLmRhdGEgOiBudWxsLFxuICAgICAgICAgICAgICAkc2NvcGUuaGlkZUNvbXBvbmVudHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEdldCB0aGUgc2V0dGluZ3MuXG4gICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGZvcm1pb0NvbXBvbmVudHMuY29tcG9uZW50c1skc2NvcGUuY29tcG9uZW50LnR5cGVdIHx8IGZvcm1pb0NvbXBvbmVudHMuY29tcG9uZW50c1snY3VzdG9tJ107XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIHRlbXBsYXRlIGZvciB0aGUgY29tcG9uZW50LlxuICAgICAgICAgIGlmICghY29tcG9uZW50LnZpZXdUZW1wbGF0ZSkge1xuICAgICAgICAgICAgJHNjb3BlLnRlbXBsYXRlID0gJ2Zvcm1pby9lbGVtZW50LXZpZXcuaHRtbCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb21wb25lbnQudmlld1RlbXBsYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAkc2NvcGUudGVtcGxhdGUgPSBjb21wb25lbnQudmlld1RlbXBsYXRlKCRzY29wZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnRlbXBsYXRlID0gY29tcG9uZW50LnZpZXdUZW1wbGF0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGNvbXBvbmVudCBuYW1lLlxuICAgICAgICAgICRzY29wZS5jb21wb25lbnRJZCA9ICRzY29wZS5jb21wb25lbnQua2V5O1xuICAgICAgICAgIGlmICgkc2NvcGUuZ3JpZFJvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50SWQgKz0gKCctJyArICRzY29wZS5ncmlkUm93KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRzY29wZS5ncmlkQ29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRzY29wZS5jb21wb25lbnRJZCArPSAoJy0nICsgJHNjb3BlLmdyaWRDb2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cbl07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7XG4gICAgICBmb3JtOiAnPT8nLFxuICAgICAgc3VibWlzc2lvbjogJz0/JyxcbiAgICAgIHNyYzogJz0/JyxcbiAgICAgIGZvcm1BY3Rpb246ICc9PycsXG4gICAgICByZXNvdXJjZU5hbWU6ICc9PycsXG4gICAgICBtZXNzYWdlOiAnPT8nXG4gICAgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby1kZWxldGUuaHRtbCcsXG4gICAgY29udHJvbGxlcjogW1xuICAgICAgJyRzY29wZScsXG4gICAgICAnJGVsZW1lbnQnLFxuICAgICAgJ0Zvcm1pb1Njb3BlJyxcbiAgICAgICdGb3JtaW8nLFxuICAgICAgJyRodHRwJyxcbiAgICAgIGZ1bmN0aW9uKFxuICAgICAgICAkc2NvcGUsXG4gICAgICAgICRlbGVtZW50LFxuICAgICAgICBGb3JtaW9TY29wZSxcbiAgICAgICAgRm9ybWlvLFxuICAgICAgICAkaHR0cFxuICAgICAgKSB7XG4gICAgICAgICRzY29wZS5fc3JjID0gJHNjb3BlLnNyYyB8fCAnJztcbiAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFtdO1xuICAgICAgICAvLyBTaG93cyB0aGUgZ2l2ZW4gYWxlcnRzIChzaW5nbGUgb3IgYXJyYXkpLCBhbmQgZGlzbWlzc2VzIG9sZCBhbGVydHNcbiAgICAgICAgJHNjb3BlLnNob3dBbGVydHMgPSBmdW5jdGlvbihhbGVydHMpIHtcbiAgICAgICAgICAkc2NvcGUuZm9ybWlvQWxlcnRzID0gW10uY29uY2F0KGFsZXJ0cyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXNvdXJjZU5hbWUgPSAncmVzb3VyY2UnO1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9ICcnO1xuICAgICAgICB2YXIgbG9hZGVyID0gRm9ybWlvU2NvcGUucmVnaXN0ZXIoJHNjb3BlLCAkZWxlbWVudCwge1xuICAgICAgICAgIGZvcm06IHRydWUsXG4gICAgICAgICAgc3VibWlzc2lvbjogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgcmVzb3VyY2VOYW1lID0gbG9hZGVyLnN1Ym1pc3Npb25JZCA/ICdzdWJtaXNzaW9uJyA6ICdmb3JtJztcbiAgICAgICAgICB2YXIgcmVzb3VyY2VUaXRsZSA9IHJlc291cmNlTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHJlc291cmNlTmFtZS5zbGljZSgxKTtcbiAgICAgICAgICBtZXRob2ROYW1lID0gJ2RlbGV0ZScgKyByZXNvdXJjZVRpdGxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSByZXNvdXJjZSBuYW1lXG4gICAgICAgICRzY29wZS5fcmVzb3VyY2VOYW1lID0gJHNjb3BlLnJlc291cmNlTmFtZSB8fCByZXNvdXJjZU5hbWU7XG4gICAgICAgICRzY29wZS5kZWxldGVNZXNzYWdlID0gJHNjb3BlLm1lc3NhZ2UgfHwgJ0FyZSB5b3Ugc3VyZSB5b3Ugd2lzaCB0byBkZWxldGUgdGhlICcgKyAkc2NvcGUuX3Jlc291cmNlTmFtZSArICc/JztcblxuICAgICAgICAvLyBDcmVhdGUgZGVsZXRlIGNhcGFiaWxpdHkuXG4gICAgICAgICRzY29wZS5vbkRlbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFJlYnVpbGQgcmVzb3VyY2VUaXRsZSwgJHNjb3BlLnJlc291cmNlTmFtZSBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICB2YXIgcmVzb3VyY2VOYW1lID0gJHNjb3BlLnJlc291cmNlTmFtZSB8fCAkc2NvcGUuX3Jlc291cmNlTmFtZTtcbiAgICAgICAgICB2YXIgcmVzb3VyY2VUaXRsZSA9IHJlc291cmNlTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHJlc291cmNlTmFtZS5zbGljZSgxKTtcbiAgICAgICAgICAvLyBDYWxsZWQgd2hlbiB0aGUgZGVsZXRlIGlzIGRvbmUuXG4gICAgICAgICAgdmFyIG9uRGVsZXRlRG9uZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiByZXNvdXJjZVRpdGxlICsgJyB3YXMgZGVsZXRlZC4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEZvcm1pby5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ2RlbGV0ZScsIGRhdGEpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoJHNjb3BlLmFjdGlvbikge1xuICAgICAgICAgICAgJGh0dHAuZGVsZXRlKCRzY29wZS5hY3Rpb24pLnRoZW4ob25EZWxldGVEb25lLCBGb3JtaW9TY29wZS5vbkVycm9yKCRzY29wZSwgJGVsZW1lbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGhvZE5hbWUpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyW21ldGhvZE5hbWVdICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG4gICAgICAgICAgICBsb2FkZXJbbWV0aG9kTmFtZV0oKS50aGVuKG9uRGVsZXRlRG9uZSwgRm9ybWlvU2NvcGUub25FcnJvcigkc2NvcGUsICRlbGVtZW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUub25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkc2NvcGUuJGVtaXQoJ2NhbmNlbCcpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIF1cbiAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnJGNvbXBpbGUnLFxuICAnJHRlbXBsYXRlQ2FjaGUnLFxuICBmdW5jdGlvbihcbiAgICAkY29tcGlsZSxcbiAgICAkdGVtcGxhdGVDYWNoZVxuICApIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IGZhbHNlLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aCgkY29tcGlsZSgkdGVtcGxhdGVDYWNoZS5nZXQoc2NvcGUudGVtcGxhdGUpKShzY29wZSkpO1xuICAgICAgICBzY29wZS4kZW1pdCgnZm9ybUVsZW1lbnRSZW5kZXInLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5dO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHNjb3BlOiBmYWxzZSxcbiAgICByZXN0cmljdDogJ0UnLFxuICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvL2Vycm9ycy5odG1sJ1xuICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHJlc3RyaWN0OiAnRScsXG4gICAgc2NvcGU6IHtcbiAgICAgIGZvcm06ICc9JyxcbiAgICAgIHN1Ym1pc3Npb246ICc9JyxcbiAgICAgIGlnbm9yZTogJz0/J1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICdmb3JtaW8vc3VibWlzc2lvbi5odG1sJyxcbiAgICBjb250cm9sbGVyOiBbXG4gICAgICAnJHNjb3BlJyxcbiAgICAgICdGb3JtaW9VdGlscycsXG4gICAgICBmdW5jdGlvbihcbiAgICAgICAgJHNjb3BlLFxuICAgICAgICBGb3JtaW9VdGlsc1xuICAgICAgKSB7XG4gICAgICAgICRzY29wZS5pc1Zpc2libGUgPSBmdW5jdGlvbihjb21wb25lbnQsIHJvdykge1xuICAgICAgICAgIHJldHVybiBGb3JtaW9VdGlscy5pc1Zpc2libGUoXG4gICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICByb3csXG4gICAgICAgICAgICAkc2NvcGUuc3VibWlzc2lvbiA/ICRzY29wZS5zdWJtaXNzaW9uLmRhdGEgOiBudWxsLFxuICAgICAgICAgICAgJHNjb3BlLmlnbm9yZVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgXVxuICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHJlc3RyaWN0OiAnRScsXG4gICAgc2NvcGU6IHtcbiAgICAgIHNyYzogJz0/JyxcbiAgICAgIGZvcm06ICc9PycsXG4gICAgICBzdWJtaXNzaW9uczogJz0/JyxcbiAgICAgIHBlclBhZ2U6ICc9PydcbiAgICB9LFxuICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvL3N1Ym1pc3Npb25zLmh0bWwnLFxuICAgIGNvbnRyb2xsZXI6IFtcbiAgICAgICckc2NvcGUnLFxuICAgICAgJyRlbGVtZW50JyxcbiAgICAgICdGb3JtaW9TY29wZScsXG4gICAgICBmdW5jdGlvbihcbiAgICAgICAgJHNjb3BlLFxuICAgICAgICAkZWxlbWVudCxcbiAgICAgICAgRm9ybWlvU2NvcGVcbiAgICAgICkge1xuICAgICAgICAkc2NvcGUuX3NyYyA9ICRzY29wZS5zcmMgfHwgJyc7XG4gICAgICAgICRzY29wZS5mb3JtaW9BbGVydHMgPSBbXTtcbiAgICAgICAgLy8gU2hvd3MgdGhlIGdpdmVuIGFsZXJ0cyAoc2luZ2xlIG9yIGFycmF5KSwgYW5kIGRpc21pc3NlcyBvbGQgYWxlcnRzXG4gICAgICAgIHRoaXMuc2hvd0FsZXJ0cyA9ICRzY29wZS5zaG93QWxlcnRzID0gZnVuY3Rpb24oYWxlcnRzKSB7XG4gICAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFtdLmNvbmNhdChhbGVydHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS5wZXJQYWdlID0gJHNjb3BlLnBlclBhZ2UgPT09IHVuZGVmaW5lZCA/IDEwIDogJHNjb3BlLnBlclBhZ2U7XG4gICAgICAgICRzY29wZS5mb3JtaW8gPSBGb3JtaW9TY29wZS5yZWdpc3Rlcigkc2NvcGUsICRlbGVtZW50LCB7XG4gICAgICAgICAgZm9ybTogdHJ1ZSxcbiAgICAgICAgICBzdWJtaXNzaW9uczogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUuY3VycmVudFBhZ2UgPSAxO1xuICAgICAgICAkc2NvcGUucGFnZUNoYW5nZWQgPSBmdW5jdGlvbihwYWdlKSB7XG4gICAgICAgICAgJHNjb3BlLnNraXAgPSAocGFnZSAtIDEpICogJHNjb3BlLnBlclBhZ2U7XG4gICAgICAgICAgJHNjb3BlLnVwZGF0ZVN1Ym1pc3Npb25zKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLnRhYmxlVmlldyA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiAhY29tcG9uZW50Lmhhc093blByb3BlcnR5KCd0YWJsZVZpZXcnKSB8fCBjb21wb25lbnQudGFibGVWaWV3O1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ3N1Ym1pc3Npb25zJywgZnVuY3Rpb24oc3VibWlzc2lvbnMpIHtcbiAgICAgICAgICBpZiAoc3VibWlzc2lvbnMgJiYgc3VibWlzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzdWJtaXNzaW9uTG9hZCcsICRzY29wZS5zdWJtaXNzaW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBdXG4gIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby13aXphcmQuaHRtbCcsXG4gICAgc2NvcGU6IHtcbiAgICAgIHNyYzogJz0/JyxcbiAgICAgIGZvcm1BY3Rpb246ICc9PycsXG4gICAgICBmb3JtOiAnPT8nLFxuICAgICAgc3VibWlzc2lvbjogJz0/JyxcbiAgICAgIHJlYWRPbmx5OiAnPT8nLFxuICAgICAgaGlkZUNvbXBvbmVudHM6ICc9PycsXG4gICAgICBkaXNhYmxlQ29tcG9uZW50czogJz0/JyxcbiAgICAgIGZvcm1pb09wdGlvbnM6ICc9PycsXG4gICAgICBzdG9yYWdlOiAnPT8nXG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xuICAgICAgLy8gRnJvbSBodHRwczovL3Npb25ndWkuZ2l0aHViLmlvLzIwMTMvMDUvMTIvYW5ndWxhcmpzLWdldC1lbGVtZW50LW9mZnNldC1wb3NpdGlvbi9cbiAgICAgIHZhciBvZmZzZXQgPSBmdW5jdGlvbihlbG0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZWxtLm9mZnNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gRG8gbm90aGluZy4uLlxuICAgICAgICB9XG4gICAgICAgIHZhciByYXdEb20gPSBlbG1bMF07XG4gICAgICAgIHZhciBfeCA9IDA7XG4gICAgICAgIHZhciBfeSA9IDA7XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIHZhciBzY3JvbGxYID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHNjcm9sbFkgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgYm9keS5zY3JvbGxUb3A7XG4gICAgICAgIF94ID0gcmF3RG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyBzY3JvbGxYO1xuICAgICAgICBfeSA9IHJhd0RvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBzY3JvbGxZO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6IF94LFxuICAgICAgICAgIHRvcDogX3lcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLndpemFyZExvYWRlZCA9IGZhbHNlO1xuICAgICAgc2NvcGUud2l6YXJkVG9wID0gb2Zmc2V0KGVsZW1lbnQpLnRvcDtcbiAgICAgIGlmIChzY29wZS53aXphcmRUb3AgPiA1MCkge1xuICAgICAgICBzY29wZS53aXphcmRUb3AgLT0gNTA7XG4gICAgICB9XG4gICAgICBzY29wZS53aXphcmRFbGVtZW50ID0gYW5ndWxhci5lbGVtZW50KCcuZm9ybWlvLXdpemFyZCcsIGVsZW1lbnQpO1xuICAgIH0sXG4gICAgY29udHJvbGxlcjogW1xuICAgICAgJyRzY29wZScsXG4gICAgICAnJGNvbXBpbGUnLFxuICAgICAgJyRlbGVtZW50JyxcbiAgICAgICdGb3JtaW8nLFxuICAgICAgJ0Zvcm1pb1Njb3BlJyxcbiAgICAgICdGb3JtaW9VdGlscycsXG4gICAgICAnJGh0dHAnLFxuICAgICAgJyR0aW1lb3V0JyxcbiAgICAgIGZ1bmN0aW9uKFxuICAgICAgICAkc2NvcGUsXG4gICAgICAgICRjb21waWxlLFxuICAgICAgICAkZWxlbWVudCxcbiAgICAgICAgRm9ybWlvLFxuICAgICAgICBGb3JtaW9TY29wZSxcbiAgICAgICAgRm9ybWlvVXRpbHMsXG4gICAgICAgICRodHRwLFxuICAgICAgICAkdGltZW91dFxuICAgICAgKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gKCRzY29wZS5zdG9yYWdlICYmICEkc2NvcGUucmVhZE9ubHkpID8gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJHNjb3BlLnN0b3JhZ2UpIDogZmFsc2U7XG4gICAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgICAgc2Vzc2lvbiA9IGFuZ3VsYXIuZnJvbUpzb24oc2Vzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICAkc2NvcGUuZm9ybWlvID0gbnVsbDtcbiAgICAgICAgJHNjb3BlLnBhZ2UgPSB7fTtcbiAgICAgICAgJHNjb3BlLnBhZ2VzID0gW107XG4gICAgICAgICRzY29wZS5oYXNUaXRsZXMgPSBmYWxzZTtcbiAgICAgICAgJHNjb3BlLmNvbGNsYXNzID0gJyc7XG4gICAgICAgIGlmICghJHNjb3BlLnN1Ym1pc3Npb24gfHwgIU9iamVjdC5rZXlzKCRzY29wZS5zdWJtaXNzaW9uKS5sZW5ndGgpIHtcbiAgICAgICAgICAkc2NvcGUuc3VibWlzc2lvbiA9IHNlc3Npb24gPyB7ZGF0YTogc2Vzc2lvbi5kYXRhfSA6IHtkYXRhOiB7fX07XG4gICAgICAgIH1cbiAgICAgICAgJHNjb3BlLmN1cnJlbnRQYWdlID0gc2Vzc2lvbiA/IHNlc3Npb24ucGFnZSA6IDA7XG4gICAgICAgICRzY29wZS5mb3JtaW9BbGVydHMgPSBbXTtcblxuICAgICAgICB2YXIgZ2V0Rm9ybSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gJGVsZW1lbnQuZmluZCgnI2Zvcm1pby13aXphcmQtZm9ybScpO1xuICAgICAgICAgIGlmICghZWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4oKS5zY29wZSgpLmZvcm1pb0Zvcm07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2hvdyB0aGUgY3VycmVudCBwYWdlLlxuICAgICAgICB2YXIgc2hvd1BhZ2UgPSBmdW5jdGlvbihzY3JvbGwpIHtcbiAgICAgICAgICAkc2NvcGUud2l6YXJkTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgJHNjb3BlLnBhZ2UuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICRzY29wZS5wYWdlLmNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYWdlIGlzIHBhc3QgdGhlIGNvbXBvbmVudHMgbGVuZ3RoLCB0cnkgdG8gY2xlYXIgZmlyc3QuXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmN1cnJlbnRQYWdlID49ICRzY29wZS5wYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkc2NvcGUuc3RvcmFnZSAmJiAhJHNjb3BlLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCRzY29wZS5zdG9yYWdlLCBhbmd1bGFyLnRvSnNvbih7XG4gICAgICAgICAgICAgICAgcGFnZTogJHNjb3BlLmN1cnJlbnRQYWdlLFxuICAgICAgICAgICAgICAgIGRhdGE6ICRzY29wZS5zdWJtaXNzaW9uLmRhdGFcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkc2NvcGUucGFnZS5jb21wb25lbnRzID0gJHNjb3BlLnBhZ2VzWyRzY29wZS5jdXJyZW50UGFnZV0uY29tcG9uZW50cztcbiAgICAgICAgICAgICRzY29wZS5mb3JtaW9BbGVydHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsICRzY29wZS53aXphcmRUb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLndpemFyZExvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ3dpemFyZFBhZ2UnLCAkc2NvcGUuY3VycmVudFBhZ2UpO1xuICAgICAgICAgICAgJHRpbWVvdXQoJHNjb3BlLiRhcHBseS5iaW5kKCRzY29wZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghJHNjb3BlLmZvcm0gJiYgJHNjb3BlLnNyYykge1xuICAgICAgICAgIChuZXcgRm9ybWlvKCRzY29wZS5zcmMpKS5sb2FkRm9ybSgpLnRoZW4oZnVuY3Rpb24oZm9ybSkge1xuICAgICAgICAgICAgJHNjb3BlLmZvcm0gPSBmb3JtO1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUud2l6YXJkTG9hZGVkKSB7XG4gICAgICAgICAgICAgIHNob3dQYWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93cyB0aGUgZ2l2ZW4gYWxlcnRzIChzaW5nbGUgb3IgYXJyYXkpLCBhbmQgZGlzbWlzc2VzIG9sZCBhbGVydHNcbiAgICAgICAgdGhpcy5zaG93QWxlcnRzID0gJHNjb3BlLnNob3dBbGVydHMgPSBmdW5jdGlvbihhbGVydHMpIHtcbiAgICAgICAgICAkc2NvcGUuZm9ybWlvQWxlcnRzID0gW10uY29uY2F0KGFsZXJ0cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5zdG9yYWdlICYmICEkc2NvcGUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCRzY29wZS5zdG9yYWdlLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgICRzY29wZS5zdWJtaXNzaW9uID0ge2RhdGE6IHt9fTtcbiAgICAgICAgICAkc2NvcGUuY3VycmVudFBhZ2UgPSAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBlcnJvcnMuXG4gICAgICAgICRzY29wZS5jaGVja0Vycm9ycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghJHNjb3BlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gQ2hhbmdlIGFsbCBvZiB0aGUgZmllbGRzIHRvIG5vdCBiZSBwcmlzdGluZS5cbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkZWxlbWVudC5maW5kKCdbbmFtZT1cImZvcm1pb0Zvcm1cIl0nKS5jaGlsZHJlbigpLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50U2NvcGUgPSBhbmd1bGFyLmVsZW1lbnQoZWxlbWVudCkuc2NvcGUoKTtcbiAgICAgICAgICAgICAgdmFyIGZpZWxkRm9ybSA9IGVsZW1lbnRTY29wZS5mb3JtaW9Gb3JtO1xuICAgICAgICAgICAgICBpZiAoZmllbGRGb3JtW2VsZW1lbnRTY29wZS5jb21wb25lbnQua2V5XSkge1xuICAgICAgICAgICAgICAgIGZpZWxkRm9ybVtlbGVtZW50U2NvcGUuY29tcG9uZW50LmtleV0uJHByaXN0aW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFt7XG4gICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGZpeCB0aGUgZm9sbG93aW5nIGVycm9ycyBiZWZvcmUgcHJvY2VlZGluZy4nXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3VibWl0IHRoZSBzdWJtaXNzaW9uLlxuICAgICAgICAkc2NvcGUuc3VibWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5jaGVja0Vycm9ycygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgc2FuaXRpemVkIHN1Ym1pc3Npb24gb2JqZWN0LlxuICAgICAgICAgIHZhciBzdWJtaXNzaW9uRGF0YSA9IHtkYXRhOiB7fX07XG4gICAgICAgICAgaWYgKCRzY29wZS5zdWJtaXNzaW9uLl9pZCkge1xuICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuX2lkID0gJHNjb3BlLnN1Ym1pc3Npb24uX2lkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJHNjb3BlLnN1Ym1pc3Npb24uZGF0YS5faWQpIHtcbiAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLl9pZCA9ICRzY29wZS5zdWJtaXNzaW9uLmRhdGEuX2lkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBncmFiSWRzID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICBpbnB1dCA9IFtpbnB1dF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaW5hbCA9IFtdO1xuICAgICAgICAgICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX2lkKSB7XG4gICAgICAgICAgICAgICAgZmluYWwucHVzaChlbGVtZW50Ll9pZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0UGVybWlzc2lvbnMgPSB7fTtcbiAgICAgICAgICBGb3JtaW9VdGlscy5lYWNoQ29tcG9uZW50KCRzY29wZS5mb3JtLmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50eXBlID09PSAncmVzb3VyY2UnICYmIGNvbXBvbmVudC5rZXkgJiYgY29tcG9uZW50LmRlZmF1bHRQZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRQZXJtaXNzaW9uc1tjb21wb25lbnQua2V5XSA9IGNvbXBvbmVudC5kZWZhdWx0UGVybWlzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJtaXNzaW9uRGF0YS5kYXRhLmhhc093blByb3BlcnR5KGNvbXBvbmVudC5rZXkpICYmIChjb21wb25lbnQudHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICRzY29wZS5zdWJtaXNzaW9uLmRhdGFbY29tcG9uZW50LmtleV07XG4gICAgICAgICAgICAgIGlmIChjb21wb25lbnQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uRGF0YS5kYXRhW2NvbXBvbmVudC5rZXldID0gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuZGF0YVtjb21wb25lbnQua2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLnN1Ym1pc3Npb24uZGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuZGF0YVtrZXldID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIHRoZSBzdWJtaXNzaW9uIGFjY2Vzcy5cbiAgICAgICAgICAgIHZhciBwZXJtID0gZGVmYXVsdFBlcm1pc3Npb25zW2tleV07XG4gICAgICAgICAgICBpZiAocGVybSkge1xuICAgICAgICAgICAgICBzdWJtaXNzaW9uRGF0YS5hY2Nlc3MgPSBzdWJtaXNzaW9uRGF0YS5hY2Nlc3MgfHwgW107XG5cbiAgICAgICAgICAgICAgLy8gQ29lcmNlIHZhbHVlIGludG8gYW4gYXJyYXkgZm9yIHBsdWNraW5nLlxuICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGFuZCB1cGRhdGUgYW4gZXhpc3RpbmcgcGVybWlzc2lvbi5cbiAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLmFjY2Vzcy5mb3JFYWNoKGZ1bmN0aW9uKHBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocGVybWlzc2lvbi50eXBlID09PSBwZXJtKSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uLnJlc291cmNlcyA9IHBlcm1pc3Npb24ucmVzb3VyY2VzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbi5yZXNvdXJjZXMuY29uY2F0KGdyYWJJZHModmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIEFkZCBhIHBlcm1pc3Npb24sIGJlY2F1c2Ugb25lIHdhcyBub3QgZm91bmQuXG4gICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uRGF0YS5hY2Nlc3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBwZXJtLFxuICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzOiBncmFiSWRzKHZhbHVlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gU3RyaXAgb3V0IGFueSBhbmd1bGFyIGtleXMuXG4gICAgICAgICAgc3VibWlzc2lvbkRhdGEgPSBhbmd1bGFyLmNvcHkoc3VibWlzc2lvbkRhdGEpO1xuXG4gICAgICAgICAgdmFyIHN1Ym1pdEV2ZW50ID0gJHNjb3BlLiRlbWl0KCdmb3JtU3VibWl0Jywgc3VibWlzc2lvbkRhdGEpO1xuICAgICAgICAgIGlmIChzdWJtaXRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIC8vIExpc3RlbmVyIHdhbnRzIHRvIGNhbmNlbCB0aGUgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb25Eb25lID0gZnVuY3Rpb24oc3VibWlzc2lvbikge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5zdG9yYWdlICYmICEkc2NvcGUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJHNjb3BlLnN0b3JhZ2UsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnU3VibWlzc2lvbiBDb21wbGV0ZSEnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS4kZW1pdCgnZm9ybVN1Ym1pc3Npb24nLCBzdWJtaXNzaW9uKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gU2F2ZSB0byBzcGVjaWZpZWQgYWN0aW9uLlxuICAgICAgICAgIGlmICgkc2NvcGUuYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gc3VibWlzc2lvbkRhdGEuX2lkID8gJ3B1dCcgOiAncG9zdCc7XG4gICAgICAgICAgICAkaHR0cFttZXRob2RdKCRzY29wZS5hY3Rpb24sIHN1Ym1pc3Npb25EYXRhKS50aGVuKGZ1bmN0aW9uKHN1Ym1pc3Npb24pIHtcbiAgICAgICAgICAgICAgRm9ybWlvLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICAgICAgb25Eb25lKHN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgfSwgRm9ybWlvU2NvcGUub25FcnJvcigkc2NvcGUsICRlbGVtZW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCRzY29wZS5mb3JtaW8gJiYgISRzY29wZS5mb3JtaW8ubm9TdWJtaXQpIHtcbiAgICAgICAgICAgICRzY29wZS5mb3JtaW8uc2F2ZVN1Ym1pc3Npb24oc3VibWlzc2lvbkRhdGEpLnRoZW4ob25Eb25lKS5jYXRjaChGb3JtaW9TY29wZS5vbkVycm9yKCRzY29wZSwgJGVsZW1lbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkRvbmUoc3VibWlzc2lvbkRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHNjb3BlLmNsZWFyKCk7XG4gICAgICAgICAgc2hvd1BhZ2UodHJ1ZSk7XG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCdjYW5jZWwnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBNb3ZlIG9udG8gdGhlIG5leHQgcGFnZS5cbiAgICAgICAgJHNjb3BlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoJHNjb3BlLmNoZWNrRXJyb3JzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRzY29wZS5jdXJyZW50UGFnZSA+PSAoJHNjb3BlLnBhZ2VzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgICRzY29wZS5jdXJyZW50UGFnZSsrO1xuICAgICAgICAgIHNob3dQYWdlKHRydWUpO1xuICAgICAgICAgICRzY29wZS4kZW1pdCgnd2l6YXJkTmV4dCcsICRzY29wZS5jdXJyZW50UGFnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTW92ZSBvbnRvIHRoZSBwcmV2aW91cyBwYWdlLlxuICAgICAgICAkc2NvcGUucHJldiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICgkc2NvcGUuY3VycmVudFBhZ2UgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgICRzY29wZS5jdXJyZW50UGFnZS0tO1xuICAgICAgICAgIHNob3dQYWdlKHRydWUpO1xuICAgICAgICAgICRzY29wZS4kZW1pdCgnd2l6YXJkUHJldicsICRzY29wZS5jdXJyZW50UGFnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHNjb3BlLmdvdG8gPSBmdW5jdGlvbihwYWdlKSB7XG4gICAgICAgICAgaWYgKHBhZ2UgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYWdlID49ICRzY29wZS5wYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgJHNjb3BlLmN1cnJlbnRQYWdlID0gcGFnZTtcbiAgICAgICAgICBzaG93UGFnZSh0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuaXNWYWxpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBnZXRGb3JtKCkuJHZhbGlkO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS4kb24oJ3dpemFyZEdvVG9QYWdlJywgZnVuY3Rpb24oZXZlbnQsIHBhZ2UpIHtcbiAgICAgICAgICAkc2NvcGUuZ290byhwYWdlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHVwZGF0ZVBhZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5wYWdlcy5sZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAkc2NvcGUubWFyZ2luID0gKCgxIC0gKCRzY29wZS5wYWdlcy5sZW5ndGggKiAwLjA4MzMzMzMzMzMpKSAvIDIpICogMTAwO1xuICAgICAgICAgICAgJHNjb3BlLmNvbGNsYXNzID0gJ2NvbC1zbS0xJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUubWFyZ2luID0gKCgxIC0gKCRzY29wZS5wYWdlcy5sZW5ndGggKiAwLjE2NjY2NjY2NjcpKSAvIDIpICogMTAwO1xuICAgICAgICAgICAgJHNjb3BlLmNvbGNsYXNzID0gJ2NvbC1zbS0yJztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFsbFBhZ2VzID0gW107XG4gICAgICAgIHZhciBoYXNDb25kaXRpb25hbFBhZ2VzID0gZmFsc2U7XG4gICAgICAgIHZhciBzZXRGb3JtID0gZnVuY3Rpb24oZm9ybSkge1xuICAgICAgICAgICRzY29wZS5wYWdlcyA9IFtdO1xuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmb3JtLmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gT25seSBpbmNsdWRlIHBhbmVscyBmb3IgdGhlIHBhZ2VzLlxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50eXBlID09PSAncGFuZWwnKSB7XG4gICAgICAgICAgICAgIGlmICghJHNjb3BlLmhhc1RpdGxlcyAmJiBjb21wb25lbnQudGl0bGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuaGFzVGl0bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmN1c3RvbUNvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgaGFzQ29uZGl0aW9uYWxQYWdlcyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50LmNvbmRpdGlvbmFsICYmIGNvbXBvbmVudC5jb25kaXRpb25hbC53aGVuKSB7XG4gICAgICAgICAgICAgICAgaGFzQ29uZGl0aW9uYWxQYWdlcyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgcGFnZSBpcyBub3QgaW4gdGhlIGhpZGUgY29tcG9lbmVudHMgYXJyYXkuXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoJHNjb3BlLmhpZGVDb21wb25lbnRzKSAmJlxuICAgICAgICAgICAgICAgIChjb21wb25lbnQua2V5KSAmJlxuICAgICAgICAgICAgICAgICgkc2NvcGUuaGlkZUNvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQua2V5KSAhPT0gLTEpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbGxQYWdlcy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICRzY29wZS5wYWdlcy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBGT1ItNzFcbiAgICAgICAgICBpZiAoISRzY29wZS5idWlsZGVyICYmIGhhc0NvbmRpdGlvbmFsUGFnZXMpIHtcbiAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJ3N1Ym1pc3Npb24uZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld1BhZ2VzID0gW107XG4gICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChhbGxQYWdlcywgZnVuY3Rpb24ocGFnZSkge1xuICAgICAgICAgICAgICAgIGlmIChGb3JtaW9VdGlscy5pc1Zpc2libGUocGFnZSwgbnVsbCwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgIG5ld1BhZ2VzLnB1c2gocGFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgJHNjb3BlLnBhZ2VzID0gbmV3UGFnZXM7XG4gICAgICAgICAgICAgIHVwZGF0ZVBhZ2VzKCk7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoJHNjb3BlLiRhcHBseS5iaW5kKCRzY29wZSksIDEwKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRzY29wZS5mb3JtID0gJHNjb3BlLmZvcm0gPyBhbmd1bGFyLm1lcmdlKCRzY29wZS5mb3JtLCBhbmd1bGFyLmNvcHkoZm9ybSkpIDogYW5ndWxhci5jb3B5KGZvcm0pO1xuICAgICAgICAgICRzY29wZS5wYWdlID0gYW5ndWxhci5jb3B5KGZvcm0pO1xuICAgICAgICAgICRzY29wZS5wYWdlLmRpc3BsYXkgPSAnZm9ybSc7XG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCd3aXphcmRGb3JtTG9hZCcsIGZvcm0pO1xuICAgICAgICAgIHVwZGF0ZVBhZ2VzKCk7XG4gICAgICAgICAgc2hvd1BhZ2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGT1ItNzFcbiAgICAgICAgaWYgKCEkc2NvcGUuYnVpbGRlcikge1xuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2Zvcm0nLCBmdW5jdGlvbihmb3JtKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICRzY29wZS5zcmMgfHxcbiAgICAgICAgICAgICAgIWZvcm0gfHxcbiAgICAgICAgICAgICAgIU9iamVjdC5rZXlzKGZvcm0pLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAhZm9ybS5jb21wb25lbnRzIHx8XG4gICAgICAgICAgICAgICFmb3JtLmNvbXBvbmVudHMubGVuZ3RoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvcm1VcmwgPSBmb3JtLnByb2plY3QgPyAnL3Byb2plY3QvJyArIGZvcm0ucHJvamVjdCA6ICcnO1xuICAgICAgICAgICAgZm9ybVVybCArPSAnL2Zvcm0vJyArIGZvcm0uX2lkO1xuICAgICAgICAgICAgJHNjb3BlLmZvcm1pbyA9IG5ldyBGb3JtaW8oZm9ybVVybCk7XG4gICAgICAgICAgICBzZXRGb3JtKGZvcm0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgY29tcG9uZW50cyBsZW5ndGggY2hhbmdlcyB1cGRhdGUgdGhlIHBhZ2VzLlxuICAgICAgICAkc2NvcGUuJHdhdGNoKCdmb3JtLmNvbXBvbmVudHMubGVuZ3RoJywgdXBkYXRlUGFnZXMpO1xuXG4gICAgICAgIC8vIExvYWQgdGhlIGZvcm0uXG4gICAgICAgIGlmICgkc2NvcGUuc3JjKSB7XG4gICAgICAgICAgJHNjb3BlLmZvcm1pbyA9IG5ldyBGb3JtaW8oJHNjb3BlLnNyYyk7XG4gICAgICAgICAgJHNjb3BlLmZvcm1pby5sb2FkRm9ybSgpLnRoZW4oZnVuY3Rpb24oZm9ybSkge1xuICAgICAgICAgICAgc2V0Rm9ybShmb3JtKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAkc2NvcGUuc3JjID0gJyc7XG4gICAgICAgICAgJHNjb3BlLmZvcm1pbyA9IG5ldyBGb3JtaW8oJHNjb3BlLnNyYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ0Zvcm1pbycsXG4gICdmb3JtaW9Db21wb25lbnRzJyxcbiAgJyR0aW1lb3V0JyxcbiAgZnVuY3Rpb24oXG4gICAgRm9ybWlvLFxuICAgIGZvcm1pb0NvbXBvbmVudHMsXG4gICAgJHRpbWVvdXRcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKChlcnJvci5uYW1lID09PSAnVmFsaWRhdGlvbkVycm9yJykgJiYgJGVsZW1lbnQpIHtcbiAgICAgICAgICAgICRlbGVtZW50LmZpbmQoJyNmb3JtLWdyb3VwLScgKyBlcnJvci5kZXRhaWxzWzBdLnBhdGgpLmFkZENsYXNzKCdoYXMtZXJyb3InKTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJ1ZhbGlkYXRpb25FcnJvcjogJyArIGVycm9yLmRldGFpbHNbMF0ubWVzc2FnZTtcbiAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcbiAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIGVycm9yID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkc2NvcGUuc2hvd0FsZXJ0cyh7XG4gICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgICRzY29wZS4kZW1pdCgnZm9ybUVycm9yJywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSBudWxsO1xuICAgICAgICAkc2NvcGUuZm9ybUxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAkc2NvcGUuZm9ybSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5mb3JtKSA/ICRzY29wZS5mb3JtIDoge307XG4gICAgICAgICRzY29wZS5zdWJtaXNzaW9uID0gYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLnN1Ym1pc3Npb24pID8gJHNjb3BlLnN1Ym1pc3Npb24gOiB7ZGF0YToge319O1xuICAgICAgICAkc2NvcGUuc3VibWlzc2lvbnMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUuc3VibWlzc2lvbnMpID8gJHNjb3BlLnN1Ym1pc3Npb25zIDogW107XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZWxlbWVudHMgcmVuZGVyZWQuXG4gICAgICAgIHZhciBlbGVtZW50c1JlbmRlcmVkID0gMDtcbiAgICAgICAgJHNjb3BlLiRvbignZm9ybUVsZW1lbnRSZW5kZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50c1JlbmRlcmVkKys7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzUmVuZGVyZWQgPT09ICRzY29wZS5mb3JtLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtUmVuZGVyJywgJHNjb3BlLmZvcm0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUuc2V0TG9hZGluZyA9IGZ1bmN0aW9uKF9sb2FkaW5nKSB7XG4gICAgICAgICAgJHNjb3BlLmZvcm1Mb2FkaW5nID0gX2xvYWRpbmc7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXNlZCB0byBzZXQgdGhlIGZvcm0gYWN0aW9uLlxuICAgICAgICB2YXIgZ2V0QWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgaWYgKCFhY3Rpb24pIHJldHVybiAnJztcbiAgICAgICAgICBpZiAoYWN0aW9uLnN1YnN0cigwLCAxKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBGb3JtaW8uZ2V0QmFzZVVybCgpICsgYWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCB0aGUgYWN0aW9uLlxuICAgICAgICAkc2NvcGUuYWN0aW9uID0gZ2V0QWN0aW9uKCRzY29wZS5mb3JtQWN0aW9uKTtcblxuICAgICAgICAvLyBBbGxvdyBzdWIgY29tcG9uZW50cyB0aGUgYWJpbGl0eSB0byBhZGQgbmV3IGZvcm0gY29tcG9uZW50cyB0byB0aGUgZm9ybS5cbiAgICAgICAgdmFyIGFkZGVkRGF0YSA9IHt9O1xuICAgICAgICAkc2NvcGUuJG9uKCdhZGRGb3JtQ29tcG9uZW50JywgZnVuY3Rpb24oZXZlbnQsIGNvbXBvbmVudCkge1xuICAgICAgICAgIGlmICghYWRkZWREYXRhLmhhc093blByb3BlcnR5KGNvbXBvbmVudC5zZXR0aW5ncy5rZXkpKSB7XG4gICAgICAgICAgICBhZGRlZERhdGFbY29tcG9uZW50LnNldHRpbmdzLmtleV0gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRDb21wb25lbnQgPSBmb3JtaW9Db21wb25lbnRzLmNvbXBvbmVudHNbY29tcG9uZW50LnR5cGVdO1xuICAgICAgICAgICAgJHNjb3BlLmZvcm0uY29tcG9uZW50cy5wdXNoKGFuZ3VsYXIuZXh0ZW5kKGRlZmF1bHRDb21wb25lbnQuc2V0dGluZ3MsIGNvbXBvbmVudC5zZXR0aW5ncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBhY3Rpb24gaWYgdGhleSBwcm92aWRlZCBpdCBpbiB0aGUgZm9ybS5cbiAgICAgICAgJHNjb3BlLiR3YXRjaCgnZm9ybS5hY3Rpb24nLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgICB2YXIgYWN0aW9uID0gZ2V0QWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVHJpZ2dlciBhIGZvcm0gbG9hZCBldmVudCB3aGVuIHRoZSBjb21wb25lbnRzIGxlbmd0aCBpcyBtb3JlIHRoYW4gMC5cbiAgICAgICAgJHNjb3BlLiR3YXRjaCgnZm9ybS5jb21wb25lbnRzLmxlbmd0aCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEkc2NvcGUuZm9ybSB8fFxuICAgICAgICAgICAgISRzY29wZS5mb3JtLmNvbXBvbmVudHMgfHxcbiAgICAgICAgICAgICEkc2NvcGUuZm9ybS5jb21wb25lbnRzLmxlbmd0aFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkc2NvcGUuc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtTG9hZCcsICRzY29wZS5mb3JtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHNjb3BlLnVwZGF0ZVN1Ym1pc3Npb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHNjb3BlLnNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgICAgIGlmICgkc2NvcGUucGVyUGFnZSkgcGFyYW1zLmxpbWl0ID0gJHNjb3BlLnBlclBhZ2U7XG4gICAgICAgICAgaWYgKCRzY29wZS5za2lwKSBwYXJhbXMuc2tpcCA9ICRzY29wZS5za2lwO1xuICAgICAgICAgIGxvYWRlci5sb2FkU3VibWlzc2lvbnMoe3BhcmFtczogcGFyYW1zfSkudGhlbihmdW5jdGlvbihzdWJtaXNzaW9ucykge1xuICAgICAgICAgICAgYW5ndWxhci5tZXJnZSgkc2NvcGUuc3VibWlzc2lvbnMsIGFuZ3VsYXIuY29weShzdWJtaXNzaW9ucykpO1xuICAgICAgICAgICAgJHNjb3BlLnNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzdWJtaXNzaW9uc0xvYWQnLCBzdWJtaXNzaW9ucyk7XG4gICAgICAgICAgfSwgdGhpcy5vbkVycm9yKCRzY29wZSkpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgaWYgKCRzY29wZS5fc3JjKSB7XG4gICAgICAgICAgbG9hZGVyID0gbmV3IEZvcm1pbygkc2NvcGUuX3NyYyk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZm9ybSkge1xuICAgICAgICAgICAgJHNjb3BlLnNldExvYWRpbmcodHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIElmIGEgZm9ybSBpcyBhbHJlYWR5IHByb3ZpZGVkLCB0aGVuIHNraXAgdGhlIGxvYWQuXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmZvcm0gJiYgT2JqZWN0LmtleXMoJHNjb3BlLmZvcm0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAkc2NvcGUuc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICRzY29wZS4kZW1pdCgnZm9ybUxvYWQnLCAkc2NvcGUuZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbG9hZGVyLmxvYWRGb3JtKCkudGhlbihmdW5jdGlvbihmb3JtKSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZSgkc2NvcGUuZm9ybSwgYW5ndWxhci5jb3B5KGZvcm0pKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtTG9hZCcsICRzY29wZS5mb3JtKTtcbiAgICAgICAgICAgICAgfSwgdGhpcy5vbkVycm9yKCRzY29wZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5zdWJtaXNzaW9uICYmIGxvYWRlci5zdWJtaXNzaW9uSWQpIHtcbiAgICAgICAgICAgICRzY29wZS5zZXRMb2FkaW5nKHRydWUpO1xuXG4gICAgICAgICAgICAvLyBJZiBhIHN1Ym1pc3Npb24gaXMgYWxyZWFkeSBwcm92aWRlZCwgdGhlbiBza2lwIHRoZSBsb2FkLlxuICAgICAgICAgICAgaWYgKCRzY29wZS5zdWJtaXNzaW9uICYmIE9iamVjdC5rZXlzKCRzY29wZS5zdWJtaXNzaW9uLmRhdGEpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAkc2NvcGUuc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICRzY29wZS4kZW1pdCgnc3VibWlzc2lvbkxvYWQnLCAkc2NvcGUuc3VibWlzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbG9hZGVyLmxvYWRTdWJtaXNzaW9uKCkudGhlbihmdW5jdGlvbihzdWJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZSgkc2NvcGUuc3VibWlzc2lvbiwgYW5ndWxhci5jb3B5KHN1Ym1pc3Npb24pKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzdWJtaXNzaW9uTG9hZCcsIHN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgICB9LCB0aGlzLm9uRXJyb3IoJHNjb3BlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLnN1Ym1pc3Npb25zKSB7XG4gICAgICAgICAgICAkc2NvcGUudXBkYXRlU3VibWlzc2lvbnMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhleSBwcm92aWRlIGEgdXJsIHRvIHRoZSBmb3JtLCB3ZSBzdGlsbCBuZWVkIHRvIGNyZWF0ZSBpdCBidXQgdGVsbCBpdCB0byBub3Qgc3VibWl0LlxuICAgICAgICAgIGlmICgkc2NvcGUudXJsKSB7XG4gICAgICAgICAgICBsb2FkZXIgPSBuZXcgRm9ybWlvKCRzY29wZS51cmwpO1xuICAgICAgICAgICAgbG9hZGVyLm5vU3VibWl0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkc2NvcGUuZm9ybW9Mb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICRzY29wZS5mb3JtTG9hZGluZyA9ICEkc2NvcGUuZm9ybSB8fCAoT2JqZWN0LmtleXMoJHNjb3BlLmZvcm0pLmxlbmd0aCA9PT0gMCkgfHwgISRzY29wZS5mb3JtLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICAgICRzY29wZS5zZXRMb2FkaW5nKCRzY29wZS5mb3JtTG9hZGluZyk7XG5cbiAgICAgICAgICAvLyBFbWl0IHRoZSBldmVudHMgaWYgdGhlc2Ugb2JqZWN0cyBhcmUgYWxyZWFkeSBsb2FkZWQuXG4gICAgICAgICAgaWYgKCEkc2NvcGUuZm9ybUxvYWRpbmcpIHtcbiAgICAgICAgICAgICRzY29wZS4kZW1pdCgnZm9ybUxvYWQnLCAkc2NvcGUuZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkc2NvcGUuc3VibWlzc2lvbikge1xuICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzdWJtaXNzaW9uTG9hZCcsICRzY29wZS5zdWJtaXNzaW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRzY29wZS5zdWJtaXNzaW9ucykge1xuICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzdWJtaXNzaW9uc0xvYWQnLCAkc2NvcGUuc3VibWlzc2lvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbG9hZGVyLlxuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgfVxuICAgIH07XG4gIH1cbl07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBmb3JtaW9VdGlscyA9IHJlcXVpcmUoJ2Zvcm1pb2pzL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgY2hlY2tWaXNpYmxlOiBmdW5jdGlvbihjb21wb25lbnQsIHJvdywgZGF0YSkge1xuICAgICAgdmFyIHZpc2libGUgPSBmb3JtaW9VdGlscy5jaGVja0NvbmRpdGlvbihjb21wb25lbnQsIHJvdywgZGF0YSk7XG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2NsZWFyT25IaWRlJykgfHwgY29tcG9uZW50LmNsZWFyT25IaWRlLnRvU3RyaW5nKCkgPT09ICd0cnVlJykge1xuICAgICAgICAgIGlmIChyb3cgJiYgcm93Lmhhc093blByb3BlcnR5KGNvbXBvbmVudC5rZXkpKSB7XG4gICAgICAgICAgICBkZWxldGUgcm93W2NvbXBvbmVudC5rZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmhhc093blByb3BlcnR5KGNvbXBvbmVudC5rZXkpKSB7XG4gICAgICAgICAgICBkZWxldGUgZGF0YVtjb21wb25lbnQua2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKGNvbXBvbmVudCwgcm93LCBkYXRhLCBoaWRlKSB7XG4gICAgICAvLyBJZiB0aGUgY29tcG9uZW50IGlzIGluIHRoZSBoaWRlQ29tcG9uZW50cyBhcnJheSwgdGhlbiBoaWRlIGl0IGJ5IGRlZmF1bHQuXG4gICAgICBpZiAoaGlkZSAmJiBBcnJheS5pc0FycmF5KGhpZGUpICYmIChoaWRlLmluZGV4T2YoY29tcG9uZW50LmtleSkgIT09IC0xKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNoZWNrVmlzaWJsZShjb21wb25lbnQsIHJvdywgZGF0YSk7XG4gICAgfSxcbiAgICBmbGF0dGVuQ29tcG9uZW50czogZm9ybWlvVXRpbHMuZmxhdHRlbkNvbXBvbmVudHMsXG4gICAgZWFjaENvbXBvbmVudDogZm9ybWlvVXRpbHMuZWFjaENvbXBvbmVudCxcbiAgICBnZXRDb21wb25lbnQ6IGZvcm1pb1V0aWxzLmdldENvbXBvbmVudCxcbiAgICBnZXRWYWx1ZTogZm9ybWlvVXRpbHMuZ2V0VmFsdWUsXG4gICAgaGlkZUZpZWxkczogZnVuY3Rpb24oZm9ybSwgY29tcG9uZW50cykge1xuICAgICAgdGhpcy5lYWNoQ29tcG9uZW50KGZvcm0uY29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gY29tcG9uZW50cykge1xuICAgICAgICAgIGlmIChjb21wb25lbnQua2V5ID09PSBjb21wb25lbnRzW2ldKSB7XG4gICAgICAgICAgICBjb21wb25lbnQudHlwZSA9ICdoaWRkZW4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1bmlxdWVOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcGFydHMgPSBuYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW14wLTlhLXpcXC5dL2csICcnKS5zcGxpdCgnLicpO1xuICAgICAgdmFyIGZpbGVOYW1lID0gcGFydHNbMF07XG4gICAgICB2YXIgZXh0ID0gJyc7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICBleHQgPSAnLicgKyBwYXJ0c1socGFydHMubGVuZ3RoIC0gMSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbGVOYW1lLnN1YnN0cigwLCAxMCkgKyAnLScgKyB0aGlzLmd1aWQoKSArIGV4dDtcbiAgICB9LFxuICAgIGd1aWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkqMTZ8MCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociYweDN8MHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmaWVsZFdyYXA6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICB2YXIgbXVsdGlJbnB1dCA9IGlucHV0LnJlcGxhY2UoJ2RhdGFbY29tcG9uZW50LmtleV0nLCAnZGF0YVtjb21wb25lbnQua2V5XVskaW5kZXhdJyk7XG4gICAgICB2YXIgaW5wdXRMYWJlbCA9ICc8bGFiZWwgbmctaWY9XCJjb21wb25lbnQubGFiZWwgJiYgIWNvbXBvbmVudC5oaWRlTGFiZWxcIiBmb3I9XCJ7eyBjb21wb25lbnQua2V5IH19XCIgY2xhc3M9XCJjb250cm9sLWxhYmVsXCIgbmctY2xhc3M9XCJ7XFwnZmllbGQtcmVxdWlyZWRcXCc6IGlzUmVxdWlyZWQoY29tcG9uZW50KX1cIj57eyBjb21wb25lbnQubGFiZWwgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9sYWJlbD4nO1xuICAgICAgdmFyIHJlcXVpcmVkSW5saW5lID0gJzxzcGFuIG5nLWlmPVwiKGNvbXBvbmVudC5oaWRlTGFiZWwgPT09IHRydWUgfHwgY29tcG9uZW50LmxhYmVsID09PSBcXCdcXCcgfHwgIWNvbXBvbmVudC5sYWJlbCkgJiYgaXNSZXF1aXJlZChjb21wb25lbnQpXCIgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWFzdGVyaXNrIGZvcm0tY29udHJvbC1mZWVkYmFjayBmaWVsZC1yZXF1aXJlZC1pbmxpbmVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+JztcbiAgICAgIHZhciB0ZW1wbGF0ZSA9XG4gICAgICAgICc8ZGl2IG5nLWlmPVwiIWNvbXBvbmVudC5tdWx0aXBsZVwiPicgK1xuICAgICAgICAgIGlucHV0TGFiZWwgK1xuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj4nICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiBuZy1pZj1cIiEhY29tcG9uZW50LnByZWZpeFwiPnt7IGNvbXBvbmVudC5wcmVmaXggfX08L2Rpdj4nICtcbiAgICAgICAgICAgIGlucHV0ICtcbiAgICAgICAgICAgIHJlcXVpcmVkSW5saW5lICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiBuZy1pZj1cIiEhY29tcG9uZW50LnN1ZmZpeFwiPnt7IGNvbXBvbmVudC5zdWZmaXggfX08L2Rpdj4nICtcbiAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtaW8tZXJyb3JzXCI+JyArXG4gICAgICAgICAgICAnPGZvcm1pby1lcnJvcnMgbmctaWY9XCI6OiFidWlsZGVyXCI+PC9mb3JtaW8tZXJyb3JzPicgK1xuICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPGRpdiBuZy1pZj1cIiEhY29tcG9uZW50LmRlc2NyaXB0aW9uXCIgY2xhc3M9XCJoZWxwLWJsb2NrXCI+JyArXG4gICAgICAgICAgJzxzcGFuPnt7IGNvbXBvbmVudC5kZXNjcmlwdGlvbiB9fTwvc3Bhbj4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPGRpdiBuZy1pZj1cImNvbXBvbmVudC5tdWx0aXBsZVwiPjx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLWJvcmRlcmVkXCI+JyArXG4gICAgICAgICAgaW5wdXRMYWJlbCArXG4gICAgICAgICAgJzx0ciBuZy1yZXBlYXQ9XCJ2YWx1ZSBpbiBkYXRhW2NvbXBvbmVudC5rZXldIHRyYWNrIGJ5ICRpbmRleFwiPicgK1xuICAgICAgICAgICAgJzx0ZD4nICtcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cFwiPicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiBuZy1pZj1cIiEhY29tcG9uZW50LnByZWZpeFwiPnt7IGNvbXBvbmVudC5wcmVmaXggfX08L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgIG11bHRpSW5wdXQgK1xuICAgICAgICAgICAgICAgICAgcmVxdWlyZWRJbmxpbmUgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiBuZy1pZj1cIiEhY29tcG9uZW50LnN1ZmZpeFwiPnt7IGNvbXBvbmVudC5zdWZmaXggfX08L2Rpdj4nICtcbiAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm1pby1lcnJvcnNcIj4nICtcbiAgICAgICAgICAgICAgICAnPGZvcm1pby1lcnJvcnMgbmctaWY9XCI6OiFidWlsZGVyXCI+PC9mb3JtaW8tZXJyb3JzPicgK1xuICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAnPC90ZD4nICtcbiAgICAgICAgICAgICc8dGQ+PGEgbmctY2xpY2s9XCJyZW1vdmVGaWVsZFZhbHVlKCRpbmRleClcIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdFwiPjxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUtY2lyY2xlXCI+PC9zcGFuPjwvYT48L3RkPicgK1xuICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAnPHRkIGNvbHNwYW49XCIyXCI+PGEgbmctY2xpY2s9XCJhZGRGaWVsZFZhbHVlKClcIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiPjxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPiB7eyBjb21wb25lbnQuYWRkQW5vdGhlciB8fCBcIkFkZCBBbm90aGVyXCIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9hPjwvdGQ+JyArXG4gICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICc8L3RhYmxlPjwvZGl2Pic7XG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgY29tcG9uZW50IGlzIHJlcXVpcmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gYmUgY2hlY2tlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHNUb1JlcXVpcmUgQW4gYXJyYXkgb2YgY29tcG9uZW50IGtleXMgbWFudWFsbHkgc2V0IHRvIG1hcmsgc3BlY2lmaWMgY29tcG9uZW50cyBhcyByZXF1aXJlZFxuICAgICAqL1xuICAgIGlzUmVxdWlyZWQ6IGZ1bmN0aW9uKGNvbXBvbmVudCwgY29tcG9uZW50c1RvUmVxdWlyZSkge1xuICAgICAgcmV0dXJuIChjb21wb25lbnQudmFsaWRhdGUgJiYgY29tcG9uZW50LnZhbGlkYXRlLnJlcXVpcmVkKSB8fCAoQXJyYXkuaXNBcnJheShjb21wb25lbnRzVG9SZXF1aXJlKSAmJiBjb21wb25lbnRzVG9SZXF1aXJlLmluZGV4T2YoY29tcG9uZW50LmtleSkgIT09IC0xKTtcbiAgICB9XG4gIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZ2VuZXJpYyA9IGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB2YXIgc3RhcnRUYWJsZSA9IGZ1bmN0aW9uKGxhYmVscykge1xuICAgICAgaWYgKCEobGFiZWxzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIGxhYmVscyA9IFtsYWJlbHNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmlldyA9ICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkXCI+PHRoZWFkPjx0cj4nO1xuXG4gICAgICBsYWJlbHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZpZXcgKz0gJzx0aD4nICsgaXRlbSArICc8L3RoPic7XG4gICAgICB9KTtcblxuICAgICAgdmlldyArPSAnPC90cj48L3RoZWFkPic7XG4gICAgICB2aWV3ICs9ICc8dGJvZHk+JztcbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH07XG5cbiAgICB2YXIgZmluaXNoVGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnPC90Ym9keT48L3RhYmxlPic7XG4gICAgfTtcblxuICAgIHZhciBtYWtlUm93ID0gZnVuY3Rpb24oZGF0YSwgbm9Sb3cpIHtcbiAgICAgIHZhciB2aWV3ID0gIW5vUm93ID8gJzx0cj4nIDogJyc7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZpZXcgKz0gJzx0ZD4nICsgZGF0YSArICc8L3RkPic7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2aWV3ICs9ICc8dGQ+PC90ZD4nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgdmlldyArPSBtYWtlUm93KGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbGFiZWxzID0gT2JqZWN0LmtleXMoZGF0YSk7XG5cbiAgICAgICAgdmlldyArPSAnPHRkPicgKyBzdGFydFRhYmxlKGxhYmVscyk7XG4gICAgICAgIGxhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHZpZXcgKz0gbWFrZVJvdyhkYXRhW2tleV0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmlldyArPSBmaW5pc2hUYWJsZSgpICsgJzwvdGQ+JztcbiAgICAgIH1cblxuICAgICAgdmlldyArPSAhbm9Sb3cgPyAnPC90cj4nIDogJyc7XG4gICAgICByZXR1cm4gdmlldztcbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIGEgdGVtcGxhdGVcbiAgICB2YXIgdmlldyA9ICcnO1xuICAgIHZhciBsYWJlbDtcbiAgICBpZiAoIWxhYmVsICYmIGNvbXBvbmVudCAmJiBjb21wb25lbnQubGFiZWwpIHtcbiAgICAgIGxhYmVsID0gY29tcG9uZW50LmxhYmVsO1xuICAgIH1cbiAgICBlbHNlIGlmICghbGFiZWwgJiYgY29tcG9uZW50ICYmIGNvbXBvbmVudC5rZXkpIHtcbiAgICAgIGxhYmVsID0gY29tcG9uZW50LmtleTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsYWJlbCA9ICcnO1xuICAgIH1cblxuICAgIHZpZXcgKz0gc3RhcnRUYWJsZShsYWJlbCk7XG4gICAgdmlldyArPSBtYWtlUm93KGRhdGEpO1xuICAgIHZpZXcgKz0gZmluaXNoVGFibGUoKTtcbiAgICByZXR1cm4gdmlldztcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGdlbmVyaWM6IGdlbmVyaWNcbiAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnJHEnLFxuICAnJHJvb3RTY29wZScsXG4gICdGb3JtaW8nLFxuICBmdW5jdGlvbigkcSwgJHJvb3RTY29wZSwgRm9ybWlvKSB7XG4gICAgdmFyIEludGVyY2VwdG9yID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgSldUIHRva2VuIHJlY2VpdmVkIGZyb20gcmVzcG9uc2UuXG4gICAgICAgKi9cbiAgICAgIHJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSByZXNwb25zZS5oZWFkZXJzKCd4LWp3dC10b2tlbicpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDAgJiYgdG9rZW4gJiYgdG9rZW4gIT09ICcnKSB7XG4gICAgICAgICAgRm9ybWlvLnNldFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEludGVyY2VwdCBhIHJlc3BvbnNlIGVycm9yLlxuICAgICAgICovXG4gICAgICByZXNwb25zZUVycm9yOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAocGFyc2VJbnQocmVzcG9uc2Uuc3RhdHVzLCAxMCkgPT09IDQ0MCkge1xuICAgICAgICAgIHJlc3BvbnNlLmxvZ2dlZE91dCA9IHRydWU7XG4gICAgICAgICAgRm9ybWlvLnNldFRva2VuKG51bGwpO1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZm9ybWlvLnNlc3Npb25FeHBpcmVkJywgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VJbnQocmVzcG9uc2Uuc3RhdHVzLCAxMCkgPT09IDQwMSkge1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZm9ybWlvLnVuYXV0aG9yaXplZCcsIHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcS5yZWplY3QocmVzcG9uc2UpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIHRva2VuIGluIHRoZSByZXF1ZXN0IGhlYWRlcnMuXG4gICAgICAgKi9cbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLmRpc2FibGVKV1QpIHJldHVybiBjb25maWc7XG4gICAgICAgIHZhciB0b2tlbiA9IEZvcm1pby5nZXRUb2tlbigpO1xuICAgICAgICBpZiAodG9rZW4pIGNvbmZpZy5oZWFkZXJzWyd4LWp3dC10b2tlbiddID0gdG9rZW47XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBJbnRlcmNlcHRvcjtcbiAgfVxuXTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdGb3JtaW8nLFxuICAnZm9ybWlvQ29tcG9uZW50cycsXG4gICckaW50ZXJwb2xhdGUnLFxuICBmdW5jdGlvbihcbiAgICBGb3JtaW8sXG4gICAgZm9ybWlvQ29tcG9uZW50cyxcbiAgICAkaW50ZXJwb2xhdGVcbiAgKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBjb21wb25lbnQpIHtcbiAgICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC5pbnB1dHx8ICFjb21wb25lbnQudHlwZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgY29tcG9uZW50SW5mbyA9IGZvcm1pb0NvbXBvbmVudHMuY29tcG9uZW50c1tjb21wb25lbnQudHlwZV07XG4gICAgICBpZiAoIWNvbXBvbmVudEluZm8udGFibGVWaWV3KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wb25lbnQubXVsdGlwbGUgJiYgKHZhbHVlLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbihhcnJheVZhbHVlKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2goY29tcG9uZW50SW5mby50YWJsZVZpZXcoYXJyYXlWYWx1ZSwgY29tcG9uZW50LCAkaW50ZXJwb2xhdGUsIGZvcm1pb0NvbXBvbmVudHMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcG9uZW50SW5mby50YWJsZVZpZXcodmFsdWUsIGNvbXBvbmVudCwgJGludGVycG9sYXRlLCBmb3JtaW9Db21wb25lbnRzKTtcbiAgICB9O1xuICB9XG5dO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ0Zvcm1pb1V0aWxzJyxcbiAgZnVuY3Rpb24oRm9ybWlvVXRpbHMpIHtcbiAgICByZXR1cm4gRm9ybWlvVXRpbHMuZmxhdHRlbkNvbXBvbmVudHM7XG4gIH1cbl07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnJHNjZScsXG4gIGZ1bmN0aW9uKFxuICAgICRzY2VcbiAgKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgIHJldHVybiAkc2NlLnRydXN0QXNIdG1sKGh0bWwpO1xuICAgIH07XG4gIH1cbl07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gW1xuICBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY29tcG9uZW50cykge1xuICAgICAgdmFyIHRhYmxlQ29tcHMgPSBbXTtcbiAgICAgIGlmICghY29tcG9uZW50cyB8fCAhY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlQ29tcHM7XG4gICAgICB9XG4gICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQudGFibGVWaWV3KSB7XG4gICAgICAgICAgdGFibGVDb21wcy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRhYmxlQ29tcHM7XG4gICAgfTtcbiAgfVxuXTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdmb3JtaW9UYWJsZVZpZXcnLFxuICBmdW5jdGlvbihcbiAgICBmb3JtaW9UYWJsZVZpZXdcbiAgKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBmb3JtaW9UYWJsZVZpZXcodmFsdWUsIGNvbXBvbmVudCk7XG4gICAgfTtcbiAgfVxuXTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdGb3JtaW8nLFxuICAnZm9ybWlvVGFibGVWaWV3JyxcbiAgZnVuY3Rpb24oXG4gICAgRm9ybWlvLFxuICAgIGZvcm1pb1RhYmxlVmlld1xuICApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gZm9ybWlvVGFibGVWaWV3KEZvcm1pby5maWVsZERhdGEoZGF0YSwgY29tcG9uZW50KSwgY29tcG9uZW50KTtcbiAgICB9O1xuICB9XG5dO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJyRmaWx0ZXInLFxuICAnJGluamVjdG9yJyxcbiAgZnVuY3Rpb24oXG4gICAgJGZpbHRlcixcbiAgICAkaW5qZWN0b3JcbiAgKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQsIGtleSwgYnVpbGRlcikge1xuICAgICAgLyoqXG4gICAgICAgKiBMb29rdXAgdGhlIGF2YWlsYWJsZSB0cmFuc2xhdGUgbGlicmFyaWVzLCBjdXJyZW50bHkgc3VwcG9ydHM6XG4gICAgICAgKiBhbmd1bGFyLXRyYW5zbGF0ZTogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci10cmFuc2xhdGUvYW5ndWxhci10cmFuc2xhdGVcbiAgICAgICAqIGFuZ3VsYXItZ2V0dGV4dDogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcnViZW52L2FuZ3VsYXItZ2V0dGV4dFxuICAgICAgICovXG4gICAgICB2YXIgJHRyYW5zbGF0ZSwgZ2V0dGV4dENhdGFsb2c7XG4gICAgICBpZiAoJGluamVjdG9yLmhhcygnJHRyYW5zbGF0ZScpKSB7XG4gICAgICAgICR0cmFuc2xhdGUgPSAkaW5qZWN0b3IuZ2V0KCckdHJhbnNsYXRlJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgkaW5qZWN0b3IuaGFzKCdnZXR0ZXh0Q2F0YWxvZycpKSB7XG4gICAgICAgIGdldHRleHRDYXRhbG9nID0gJGluamVjdG9yLmdldCgnZ2V0dGV4dENhdGFsb2cnKTtcbiAgICAgIH1cbiAgICAgIGlmIChidWlsZGVyKSByZXR1cm4gdGV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0ZXh0IHVzaW5nIGVpdGhlciBhbmd1bGFyLXRyYW5zbGF0ZSBvciBhbmd1bGFyLWdldHRleHRcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgaWYgKCR0cmFuc2xhdGUpIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQodGV4dCk7XG4gICAgICAgICAgaWYgKGdldHRleHRDYXRhbG9nKSByZXR1cm4gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHRleHQpO1xuICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFsbG93IHRyYW5zbGF0aW5nIGJ5IGZpZWxkIGtleSB3aGljaCBoZWxwcyB3aXRoIGxhcmdlIGJsb2NrcyBvZiBodG1sLlxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZVRleHQoa2V5KTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRyYW5zbGF0ZVRleHQodGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhbnNsYXRlVGV4dCh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfVxuICAgIH07XG4gIH1cbl07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gWyckc2NlJywgZnVuY3Rpb24oJHNjZSkge1xuICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKHZhbCk7XG4gIH07XG59XTtcbiIsIlwidXNlIHN0cmljdFwiO1xucmVxdWlyZSgnLi9wb2x5ZmlsbHMvcG9seWZpbGxzJyk7XG5cblxudmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdmb3JtaW8nLCBbXG4gICduZ1Nhbml0aXplJyxcbiAgJ3VpLmJvb3RzdHJhcCcsXG4gICd1aS5ib290c3RyYXAuZGF0ZXRpbWVwaWNrZXInLFxuICAndWkuc2VsZWN0JyxcbiAgJ3VpLm1hc2snLFxuICAnYW5ndWxhck1vbWVudCcsXG4gICduZ0ZpbGVVcGxvYWQnLFxuICAnbmdGaWxlU2F2ZXInXG5dKTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGZvcm1pbyBwcm92aWRlcnMuXG4gKi9cbmFwcC5wcm92aWRlcignRm9ybWlvJywgcmVxdWlyZSgnLi9wcm92aWRlcnMvRm9ybWlvJykpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHJlZ2lzdGVyIHRoZSBGb3JtaW8gc2NvcGUuXG4gKi9cbmFwcC5mYWN0b3J5KCdGb3JtaW9TY29wZScsIHJlcXVpcmUoJy4vZmFjdG9yaWVzL0Zvcm1pb1Njb3BlJykpO1xuXG5hcHAuZmFjdG9yeSgnRm9ybWlvVXRpbHMnLCByZXF1aXJlKCcuL2ZhY3Rvcmllcy9Gb3JtaW9VdGlscycpKTtcblxuYXBwLmZhY3RvcnkoJ2Zvcm1pb0ludGVyY2VwdG9yJywgcmVxdWlyZSgnLi9mYWN0b3JpZXMvZm9ybWlvSW50ZXJjZXB0b3InKSk7XG5cbmFwcC5mYWN0b3J5KCdmb3JtaW9UYWJsZVZpZXcnLCByZXF1aXJlKCcuL2ZhY3Rvcmllcy9mb3JtaW9UYWJsZVZpZXcnKSk7XG5cbmFwcC5kaXJlY3RpdmUoJ2Zvcm1pbycsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtaW8nKSk7XG5cbmFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0RlbGV0ZScsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtaW9EZWxldGUnKSk7XG5cbmFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0Vycm9ycycsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtaW9FcnJvcnMnKSk7XG5cbmFwcC5kaXJlY3RpdmUoJ2N1c3RvbVZhbGlkYXRvcicsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9jdXN0b21WYWxpZGF0b3InKSk7XG5cbmFwcC5kaXJlY3RpdmUoJ2Zvcm1pb1N1Ym1pc3Npb25zJywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1pb1N1Ym1pc3Npb25zJykpO1xuXG5hcHAuZGlyZWN0aXZlKCdmb3JtaW9TdWJtaXNzaW9uJywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1pb1N1Ym1pc3Npb24nKSk7XG5cbmFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0NvbXBvbmVudCcsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtaW9Db21wb25lbnQnKSk7XG5cbmFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0NvbXBvbmVudFZpZXcnLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZm9ybWlvQ29tcG9uZW50VmlldycpKTtcblxuYXBwLmRpcmVjdGl2ZSgnZm9ybWlvRWxlbWVudCcsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtaW9FbGVtZW50JykpO1xuXG5hcHAuZGlyZWN0aXZlKCdmb3JtaW9XaXphcmQnLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZm9ybWlvV2l6YXJkJykpO1xuXG5hcHAuZGlyZWN0aXZlKCdmb3JtaW9CaW5kSHRtbCcsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtaW9CaW5kSHRtbC5qcycpKTtcblxuLyoqXG4gKiBGaWx0ZXIgdG8gZmxhdHRlbiBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbmFwcC5maWx0ZXIoJ2ZsYXR0ZW5Db21wb25lbnRzJywgcmVxdWlyZSgnLi9maWx0ZXJzL2ZsYXR0ZW5Db21wb25lbnRzJykpO1xuYXBwLmZpbHRlcigndGFibGVDb21wb25lbnRzJywgcmVxdWlyZSgnLi9maWx0ZXJzL3RhYmxlQ29tcG9uZW50cycpKTtcbmFwcC5maWx0ZXIoJ3RhYmxlVmlldycsIHJlcXVpcmUoJy4vZmlsdGVycy90YWJsZVZpZXcnKSk7XG5hcHAuZmlsdGVyKCd0YWJsZUZpZWxkVmlldycsIHJlcXVpcmUoJy4vZmlsdGVycy90YWJsZUZpZWxkVmlldycpKTtcbmFwcC5maWx0ZXIoJ3NhZmVodG1sJywgcmVxdWlyZSgnLi9maWx0ZXJzL3NhZmVodG1sJykpO1xuYXBwLmZpbHRlcignZm9ybWlvVHJhbnNsYXRlJywgcmVxdWlyZSgnLi9maWx0ZXJzL3RyYW5zbGF0ZScpKTtcbmFwcC5maWx0ZXIoJ3RydXN0QXNSZXNvdXJjZVVybCcsIHJlcXVpcmUoJy4vZmlsdGVycy90cnVzdHVybCcpKTtcbmFwcC5jb25maWcoW1xuICAnJGh0dHBQcm92aWRlcicsXG4gICckaW5qZWN0b3InLFxuICBmdW5jdGlvbihcbiAgICAkaHR0cFByb3ZpZGVyLFxuICAgICRpbmplY3RvclxuICApIHtcbiAgICBpZiAoISRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5nZXQpIHtcbiAgICAgICRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5nZXQgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBuZ0FuaW1hdGUgZG9lc24ndCBtZXNzIHVwIGxvYWRlci5cbiAgICB0cnkge1xuICAgICAgJGluamVjdG9yLmdldCgnJGFuaW1hdGVQcm92aWRlcicpLmNsYXNzTmFtZUZpbHRlcigvXigoPyEoZmEtc3Bpbm5lcnxnbHlwaGljb24tc3BpbikpLikqJC8pO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICAgIGNhdGNoIChlcnIpIHt9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXG4gICAgLy8gRGlzYWJsZSBJRSBjYWNoaW5nIGZvciBHRVQgcmVxdWVzdHMuXG4gICAgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLmdldFsnQ2FjaGUtQ29udHJvbCddID0gJ25vLWNhY2hlJztcbiAgICAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLmhlYWRlcnMuZ2V0LlByYWdtYSA9ICduby1jYWNoZSc7XG4gICAgJGh0dHBQcm92aWRlci5pbnRlcmNlcHRvcnMucHVzaCgnZm9ybWlvSW50ZXJjZXB0b3InKTtcbiAgfVxuXSk7XG5cbmFwcC5ydW4oW1xuICAnJHRlbXBsYXRlQ2FjaGUnLFxuICAnJHJvb3RTY29wZScsXG4gICckd2luZG93JyxcbiAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUsICRyb290U2NvcGUsICR3aW5kb3cpIHtcbiAgICAkd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGV2ZW50RGF0YSA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBldmVudERhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICBldmVudERhdGEgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50RGF0YSAmJiBldmVudERhdGEubmFtZSkge1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2lmcmFtZS0nICsgZXZlbnREYXRhLm5hbWUsIGV2ZW50RGF0YS5kYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRoZSB0ZW1wbGF0ZSBmb3IgdGhlIGZvcm1pbyBmb3Jtcy5cbiAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby5odG1sJyxcbiAgICAgIFwiPGRpdj5cXG4gIDxpIHN0eWxlPVxcXCJmb250LXNpemU6IDJlbTtcXFwiIG5nLWlmPVxcXCJmb3JtTG9hZGluZ1xcXCIgbmctY2xhc3M9XFxcInsnZm9ybWlvLWhpZGRlbic6ICFmb3JtTG9hZGluZ31cXFwiIGNsYXNzPVxcXCJmb3JtaW8tbG9hZGluZyBnbHlwaGljb24gZ2x5cGhpY29uLXJlZnJlc2ggZ2x5cGhpY29uLXNwaW5cXFwiPjwvaT5cXG4gIDxmb3JtaW8td2l6YXJkIG5nLWlmPVxcXCJmb3JtLmRpc3BsYXkgPT09ICd3aXphcmQnXFxcIiBzcmM9XFxcInNyY1xcXCIgZm9ybT1cXFwiZm9ybVxcXCIgc3VibWlzc2lvbj1cXFwic3VibWlzc2lvblxcXCIgZm9ybS1hY3Rpb249XFxcImZvcm1BY3Rpb25cXFwiIHJlYWQtb25seT1cXFwicmVhZE9ubHlcXFwiIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiIGRpc2FibGUtY29tcG9uZW50cz1cXFwiZGlzYWJsZUNvbXBvbmVudHNcXFwiIGZvcm1pby1vcHRpb25zPVxcXCJmb3JtaW9PcHRpb25zXFxcIiBzdG9yYWdlPVxcXCJmb3JtLm5hbWVcXFwiPjwvZm9ybWlvLXdpemFyZD5cXG4gIDxkaXYgbmctaWY9XFxcImZvcm0uZGlzcGxheSA9PT0gJ3BkZicgJiYgZm9ybS5zZXR0aW5ncy5wZGZcXFwiIHN0eWxlPVxcXCJwb3NpdGlvbjpyZWxhdGl2ZTtcXFwiPlxcbiAgICA8c3BhbiBzdHlsZT1cXFwicG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MTBweDt0b3A6MTBweDtjdXJzb3I6cG9pbnRlcjtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgbm8tZGlzYWJsZVxcXCIgbmctY2xpY2s9XFxcInpvb21JbigpXFxcIj48c3Bhbm4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tem9vbS1pblxcXCI+PC9zcGFubj48L3NwYW4+XFxuICAgIDxzcGFuIHN0eWxlPVxcXCJwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoxMHB4O3RvcDo2MHB4O2N1cnNvcjpwb2ludGVyO1xcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBuby1kaXNhYmxlXFxcIiBuZy1jbGljaz1cXFwiem9vbU91dCgpXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi16b29tLW91dFxcXCI+PC9zcGFuPjwvc3Bhbj5cXG4gICAgPGEgbmctaWY9XFxcImRvd25sb2FkVXJsXFxcIiBzdHlsZT1cXFwicG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MTBweDt0b3A6MTEwcHg7Y3Vyc29yOnBvaW50ZXI7XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IG5vLWRpc2FibGVcXFwiIGhyZWY9XFxcInt7IGRvd25sb2FkVXJsIHwgdHJ1c3RBc1Jlc291cmNlVXJsIH19XFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2xvdWQtZG93bmxvYWRcXFwiPjwvc3Bhbj48L2E+XFxuICAgIDxpZnJhbWUgc3JjPVxcXCJ7eyBnZXRJZnJhbWVTcmMoZm9ybS5zZXR0aW5ncy5wZGYpIHwgdHJ1c3RBc1Jlc291cmNlVXJsIH19XFxcIiBzZWFtbGVzcyBjbGFzcz1cXFwiZm9ybWlvLWlmcmFtZVxcXCI+PC9pZnJhbWU+XFxuICAgIDxidXR0b24gbmctaWY9XFxcIiFyZWFkT25seSAmJiAhZm9ybS5idWlsZGVyXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIG5nLWNsaWNrPVxcXCJzdWJtaXRJRnJhbWVGb3JtKClcXFwiPlN1Ym1pdDwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuICA8Zm9ybSBuZy1pZj1cXFwiIWZvcm0uZGlzcGxheSB8fCAoZm9ybS5kaXNwbGF5ID09PSAnZm9ybScpXFxcIiByb2xlPVxcXCJmb3JtXFxcIiBuYW1lPVxcXCJmb3JtaW9Gb3JtXFxcIiBuZy1zdWJtaXQ9XFxcIm9uU3VibWl0KGZvcm1pb0Zvcm0pXFxcIiBub3ZhbGlkYXRlPlxcbiAgICA8ZGl2IG5nLXJlcGVhdD1cXFwiYWxlcnQgaW4gZm9ybWlvQWxlcnRzIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXt7IGFsZXJ0LnR5cGUgfX1cXFwiIHJvbGU9XFxcImFsZXJ0XFxcIiBuZy1pZj1cXFwiOjohYnVpbGRlclxcXCI+XFxuICAgICAge3sgYWxlcnQubWVzc2FnZSB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXG4gICAgPC9kaXY+XFxuICAgIDwhLS0gRE8gTk9UIFBVVCBcXFwidHJhY2sgYnkgJGluZGV4XFxcIiBIRVJFIFNJTkNFIERZTkFNSUNBTExZIEFERElORy9SRU1PVklORyBDT01QT05FTlRTIFdJTEwgQlJFQUsgLS0+XFxuICAgIDxmb3JtaW8tY29tcG9uZW50XFxuICAgICAgbmctcmVwZWF0PVxcXCJjb21wb25lbnQgaW4gZm9ybS5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCJcXG4gICAgICBjb21wb25lbnQ9XFxcImNvbXBvbmVudFxcXCJcXG4gICAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogaXNWaXNpYmxlKGNvbXBvbmVudClcXFwiXFxuICAgICAgZGF0YT1cXFwic3VibWlzc2lvbi5kYXRhXFxcIlxcbiAgICAgIGZvcm1pby1mb3JtPVxcXCJmb3JtaW9Gb3JtXFxcIlxcbiAgICAgIGZvcm1pbz1cXFwiZm9ybWlvXFxcIlxcbiAgICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxuICAgICAgaGlkZS1jb21wb25lbnRzPVxcXCJoaWRlQ29tcG9uZW50c1xcXCJcXG4gICAgICByZWFkLW9ubHk9XFxcImlzRGlzYWJsZWQoY29tcG9uZW50LCBzdWJtaXNzaW9uLmRhdGEpXFxcIlxcbiAgICAgIGJ1aWxkZXI9XFxcImJ1aWxkZXJcXFwiXFxuICAgID48L2Zvcm1pby1jb21wb25lbnQ+XFxuICA8L2Zvcm0+XFxuPC9kaXY+XFxuXCJcbiAgICApO1xuXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8td2l6YXJkLmh0bWwnLFxuICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJmb3JtaW8td2l6YXJkLXdyYXBwZXJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicm93IGJzLXdpemFyZFxcXCIgc3R5bGU9XFxcImJvcmRlci1ib3R0b206MDtcXFwiIG5nLWNsYXNzPVxcXCJ7aGFzVGl0bGVzOiBoYXNUaXRsZXN9XFxcIj5cXG4gICAgPGRpdiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiAoJGluZGV4ID4gY3VycmVudFBhZ2UpLCBhY3RpdmU6ICgkaW5kZXggPT0gY3VycmVudFBhZ2UpLCBjb21wbGV0ZTogKCRpbmRleCA8IGN1cnJlbnRQYWdlKSwgbm9UaXRsZTogIXBhZ2UudGl0bGV9XFxcIiBjbGFzcz1cXFwie3sgY29sY2xhc3MgfX0gYnMtd2l6YXJkLXN0ZXBcXFwiIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlcyB0cmFjayBieSAkaW5kZXhcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJzLXdpemFyZC1zdGVwbnVtLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dC1jZW50ZXIgYnMtd2l6YXJkLXN0ZXBudW1cXFwiIG5nLWlmPVxcXCJwYWdlLnRpdGxlXFxcIj57eyBwYWdlLnRpdGxlIH19PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPjxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItcHJpbWFyeVxcXCI+PC9kaXY+PC9kaXY+XFxuICAgICAgPGEgbmctY2xpY2s9XFxcImdvdG8oJGluZGV4KVxcXCIgY2xhc3M9XFxcImJzLXdpemFyZC1kb3QgYmctcHJpbWFyeVxcXCI+PGRpdiBjbGFzcz1cXFwiYnMtd2l6YXJkLWRvdC1pbm5lciBiZy1zdWNjZXNzXFxcIj48L2Rpdj48L2E+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICA8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPi5icy13aXphcmQgPiAuYnMtd2l6YXJkLXN0ZXA6Zmlyc3QtY2hpbGQgeyBtYXJnaW4tbGVmdDoge3sgbWFyZ2luIH19JTsgfTwvc3R5bGU+XFxuICA8aSBuZy1zaG93PVxcXCIhd2l6YXJkTG9hZGVkXFxcIiBpZD1cXFwiZm9ybWlvLWxvYWRpbmdcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6IDJlbTtcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXJlZnJlc2ggZ2x5cGhpY29uLXNwaW5cXFwiPjwvaT5cXG4gIDxkaXYgbmctcmVwZWF0PVxcXCJhbGVydCBpbiBmb3JtaW9BbGVydHMgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQte3sgYWxlcnQudHlwZSB9fVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPnt7IGFsZXJ0Lm1lc3NhZ2UgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJmb3JtaW8td2l6YXJkXFxcIj5cXG4gICAgPGZvcm1pb1xcbiAgICAgIG5nLWlmPVxcXCJ3aXphcmRMb2FkZWRcXFwiXFxuICAgICAgc3VibWlzc2lvbj1cXFwic3VibWlzc2lvblxcXCJcXG4gICAgICBmb3JtPVxcXCJwYWdlXFxcIlxcbiAgICAgIHJlYWQtb25seT1cXFwicmVhZE9ubHlcXFwiXFxuICAgICAgaGlkZS1jb21wb25lbnRzPVxcXCJoaWRlQ29tcG9uZW50c1xcXCJcXG4gICAgICBkaXNhYmxlLWNvbXBvbmVudHM9XFxcImRpc2FibGVDb21wb25lbnRzXFxcIlxcbiAgICAgIGZvcm1pby1vcHRpb25zPVxcXCJmb3JtaW9PcHRpb25zXFxcIlxcbiAgICAgIGlkPVxcXCJmb3JtaW8td2l6YXJkLWZvcm1cXFwiXFxuICAgID48L2Zvcm1pbz5cXG4gIDwvZGl2PlxcbiAgPHVsIG5nLXNob3c9XFxcIndpemFyZExvYWRlZFxcXCIgY2xhc3M9XFxcImxpc3QtaW5saW5lXFxcIj5cXG4gICAgPGxpPjxhIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIG5nLWNsaWNrPVxcXCJjYW5jZWwoKVxcXCI+Q2FuY2VsPC9hPjwvbGk+XFxuICAgIDxsaSBuZy1pZj1cXFwiY3VycmVudFBhZ2UgPiAwXFxcIj48YSBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiBuZy1jbGljaz1cXFwicHJldigpXFxcIj5QcmV2aW91czwvYT48L2xpPlxcbiAgICA8bGkgbmctaWY9XFxcImN1cnJlbnRQYWdlIDwgKHBhZ2VzLmxlbmd0aCAtIDEpXFxcIj5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiBuZy1jbGljaz1cXFwibmV4dCgpXFxcIj5OZXh0PC9hPlxcbiAgICA8L2xpPlxcbiAgICA8bGkgbmctaWY9XFxcImN1cnJlbnRQYWdlID49IChwYWdlcy5sZW5ndGggLSAxKVxcXCI+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgbmctY2xpY2s9XFxcInN1Ym1pdCgpXFxcIj5TdWJtaXQgRm9ybTwvYT5cXG4gICAgPC9saT5cXG4gIDwvdWw+XFxuPC9kaXY+XFxuXCJcbiAgICApO1xuXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8tZGVsZXRlLmh0bWwnLFxuICAgICAgXCI8Zm9ybSByb2xlPVxcXCJmb3JtXFxcIj5cXG4gIDxkaXYgbmctcmVwZWF0PVxcXCJhbGVydCBpbiBmb3JtaW9BbGVydHMgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQte3sgYWxlcnQudHlwZSB9fVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcbiAgICB7eyBhbGVydC5tZXNzYWdlIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcbiAgPC9kaXY+XFxuICA8aDM+e3sgZGVsZXRlTWVzc2FnZSB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2gzPlxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuLXRvb2xiYXJcXFwiPlxcbiAgICA8YnV0dG9uIG5nLWNsaWNrPVxcXCJvbkRlbGV0ZSgpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kYW5nZXJcXFwiPnt7ICdZZXMnIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIG5nLWNsaWNrPVxcXCJvbkNhbmNlbCgpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIj57eyAnTm8nIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuPC9mb3JtPlxcblwiXG4gICAgKTtcblxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL3N1Ym1pc3Npb24uaHRtbCcsXG4gICAgICBcIjxkaXY+XFxuICA8ZGl2IG5nLXJlcGVhdD1cXFwiY29tcG9uZW50IGluIGZvcm0uY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWlmPVxcXCJzdWJtaXNzaW9uICYmIHN1Ym1pc3Npb24uZGF0YVxcXCI+XFxuICAgIDxmb3JtaW8tY29tcG9uZW50LXZpZXdcXG4gICAgICBmb3JtPVxcXCJmb3JtXFxcIlxcbiAgICAgIGNvbXBvbmVudD1cXFwiY29tcG9uZW50XFxcIlxcbiAgICAgIGRhdGE9XFxcInN1Ym1pc3Npb24uZGF0YVxcXCJcXG4gICAgICBpZ25vcmU9XFxcImlnbm9yZVxcXCJcXG4gICAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcbiAgICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoY29tcG9uZW50KVxcXCJcXG4gICAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcbiAgICA+PC9mb3JtaW8tY29tcG9uZW50LXZpZXc+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIlxuICAgICk7XG5cbiAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9zdWJtaXNzaW9ucy5odG1sJyxcbiAgICAgIFwiPGRpdj5cXG4gIDxkaXYgbmctcmVwZWF0PVxcXCJhbGVydCBpbiBmb3JtaW9BbGVydHMgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQte3sgYWxlcnQudHlwZSB9fVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcbiAgICB7eyBhbGVydC5tZXNzYWdlIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcbiAgPC9kaXY+XFxuICA8dGFibGUgY2xhc3M9XFxcInRhYmxlXFxcIj5cXG4gICAgPHRoZWFkPlxcbiAgICAgIDx0cj5cXG4gICAgICAgIDx0aCBuZy1yZXBlYXQ9XFxcImNvbXBvbmVudCBpbiBmb3JtLmNvbXBvbmVudHMgfCBmbGF0dGVuQ29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWlmPVxcXCJ0YWJsZVZpZXcoY29tcG9uZW50KVxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHx8IGNvbXBvbmVudC5rZXkgfX08L3RoPlxcbiAgICAgICAgPHRoPlN1Ym1pdHRlZDwvdGg+XFxuICAgICAgICA8dGg+VXBkYXRlZDwvdGg+XFxuICAgICAgICA8dGg+T3BlcmF0aW9uczwvdGg+XFxuICAgICAgPC90cj5cXG4gICAgPC90aGVhZD5cXG4gICAgPHRib2R5PlxcbiAgICAgIDx0ciBuZy1yZXBlYXQ9XFxcInN1Ym1pc3Npb24gaW4gc3VibWlzc2lvbnMgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwiZm9ybWlvLXN1Ym1pc3Npb25cXFwiIG5nLWNsaWNrPVxcXCIkZW1pdCgnc3VibWlzc2lvblZpZXcnLCBzdWJtaXNzaW9uKVxcXCI+XFxuICAgICAgICA8dGQgbmctcmVwZWF0PVxcXCJjb21wb25lbnQgaW4gZm9ybS5jb21wb25lbnRzIHwgZmxhdHRlbkNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1pZj1cXFwidGFibGVWaWV3KGNvbXBvbmVudClcXFwiPnt7IHN1Ym1pc3Npb24uZGF0YSB8IHRhYmxlVmlldzpjb21wb25lbnQgfX08L3RkPlxcbiAgICAgICAgPHRkPnt7IHN1Ym1pc3Npb24uY3JlYXRlZCB8IGFtRGF0ZUZvcm1hdDonbCwgaDptbTpzcyBhJyB9fTwvdGQ+XFxuICAgICAgICA8dGQ+e3sgc3VibWlzc2lvbi5tb2RpZmllZCB8IGFtRGF0ZUZvcm1hdDonbCwgaDptbTpzcyBhJyB9fTwvdGQ+XFxuICAgICAgICA8dGQ+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbi1ncm91cFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6ZmxleDtcXFwiPlxcbiAgICAgICAgICAgIDxhIG5nLWNsaWNrPVxcXCIkZW1pdCgnc3VibWlzc2lvblZpZXcnLCBzdWJtaXNzaW9uKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4teHNcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWV5ZS1vcGVuXFxcIj48L3NwYW4+PC9hPiZuYnNwO1xcbiAgICAgICAgICAgIDxhIG5nLWNsaWNrPVxcXCIkZW1pdCgnc3VibWlzc2lvbkVkaXQnLCBzdWJtaXNzaW9uKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4teHNcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWVkaXRcXFwiPjwvc3Bhbj48L2E+Jm5ic3A7XFxuICAgICAgICAgICAgPGEgbmctY2xpY2s9XFxcIiRlbWl0KCdzdWJtaXNzaW9uRGVsZXRlJywgc3VibWlzc2lvbik7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRhbmdlciBidG4teHNcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZS1jaXJjbGVcXFwiPjwvc3Bhbj48L2E+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC90ZD5cXG4gICAgICA8L3RyPlxcbiAgICA8L3Rib2R5PlxcbiAgPC90YWJsZT5cXG4gIDxwYWdpbmF0aW9uXFxuICAgIG5nLWlmPVxcXCJzdWJtaXNzaW9ucy5zZXJ2ZXJDb3VudCA+IHBlclBhZ2VcXFwiXFxuICAgIG5nLW1vZGVsPVxcXCJjdXJyZW50UGFnZVxcXCJcXG4gICAgbmctY2hhbmdlPVxcXCJwYWdlQ2hhbmdlZChjdXJyZW50UGFnZSlcXFwiXFxuICAgIHRvdGFsLWl0ZW1zPVxcXCJzdWJtaXNzaW9ucy5zZXJ2ZXJDb3VudFxcXCJcXG4gICAgaXRlbXMtcGVyLXBhZ2U9XFxcInBlclBhZ2VcXFwiXFxuICAgIGRpcmVjdGlvbi1saW5rcz1cXFwiZmFsc2VcXFwiXFxuICAgIGJvdW5kYXJ5LWxpbmtzPVxcXCJ0cnVlXFxcIlxcbiAgICBmaXJzdC10ZXh0PVxcXCImbGFxdW87XFxcIlxcbiAgICBsYXN0LXRleHQ9XFxcIiZyYXF1bztcXFwiXFxuICAgID5cXG4gIDwvcGFnaW5hdGlvbj5cXG48L2Rpdj5cXG5cIlxuICAgICk7XG5cbiAgICAvLyBBIGZvcm1pbyBjb21wb25lbnQgdGVtcGxhdGUuXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50Lmh0bWwnLFxuICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGZvcm0tZmllbGQtdHlwZS17eyBjb21wb25lbnQudHlwZSB9fSBmb3JtaW8tY29tcG9uZW50LXt7IGNvbXBvbmVudC5rZXkgfX0ge3tjb21wb25lbnQuY3VzdG9tQ2xhc3N9fVxcXCIgaWQ9XFxcImZvcm0tZ3JvdXAte3sgY29tcG9uZW50SWQgfX1cXFwiXFxuICAgICBuZy1jbGFzcz1cXFwieydoYXMtZmVlZGJhY2sgJzogKGNvbXBvbmVudC5oaWRlTGFiZWwgPT09IHRydWUgfHwgY29tcG9uZW50LmxhYmVsID09PSAnJyB8fCAhY29tcG9uZW50LmxhYmVsKSAmJiBjb21wb25lbnQudmFsaWRhdGUucmVxdWlyZWQsXFxuICAgICAgICAgICAgICdoYXMtZXJyb3InOiBmb3JtaW9Gb3JtW2NvbXBvbmVudElkXS4kaW52YWxpZCAmJiAhZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJHByaXN0aW5lIH1cXFwiXFxuICAgICBuZy1zdHlsZT1cXFwiY29tcG9uZW50LnN0eWxlXFxcIlxcbiAgICAgbmctaGlkZT1cXFwiY29tcG9uZW50LmhpZGRlblxcXCI+XFxuICA8Zm9ybWlvLWVsZW1lbnQ+PC9mb3JtaW8tZWxlbWVudD5cXG48L2Rpdj5cXG5cXG5cIlxuICAgICk7XG5cbiAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnQtdmlldy5odG1sJyxcbiAgICAgIFwiPGRpdiBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgY2xhc3M9XFxcImZvcm0tZ3JvdXAgaGFzLWZlZWRiYWNrIGZvcm0tZmllbGQtdHlwZS17eyBjb21wb25lbnQudHlwZSB9fSB7e2NvbXBvbmVudC5jdXN0b21DbGFzc319IGZvcm1pby1jb21wb25lbnQte3sgY29tcG9uZW50LmtleSB9fVxcXCIgaWQ9XFxcImZvcm0tZ3JvdXAte3sgY29tcG9uZW50SWQgfX1cXFwiIG5nLXN0eWxlPVxcXCJjb21wb25lbnQuc3R5bGVcXFwiPlxcbiAgPGZvcm1pby1lbGVtZW50PjwvZm9ybWlvLWVsZW1lbnQ+XFxuPC9kaXY+XFxuXCJcbiAgICApO1xuXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZWxlbWVudC12aWV3Lmh0bWwnLFxuICAgICAgXCI8ZGl2PlxcbiAgPGRpdiBuZy1pZj1cXFwiY29tcG9uZW50LmxhYmVsXFxcIj48c3Ryb25nPnt7IGNvbXBvbmVudC5sYWJlbCB9fTwvc3Ryb25nPjwvZGl2PlxcbiAgPGRpdiBmb3JtaW8tYmluZC1odG1sPVxcXCJkYXRhIHwgdGFibGVWaWV3OmNvbXBvbmVudFxcXCI+PC9kaXY+XFxuPC9kaXY+XFxuXCJcbiAgICApO1xuXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZXJyb3JzLmh0bWwnLFxuICAgICAgXCI8ZGl2IG5nLXNob3c9XFxcImZvcm1pb0Zvcm1bY29tcG9uZW50SWRdLiRlcnJvciAmJiAhZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJHByaXN0aW5lXFxcIj5cXG4gIDxwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIiBuZy1zaG93PVxcXCJmb3JtaW9Gb3JtW2NvbXBvbmVudElkXS4kZXJyb3IuZW1haWxcXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8fCBjb21wb25lbnQucGxhY2Vob2xkZXIgfHwgY29tcG9uZW50LmtleSB9fSB7eydtdXN0IGJlIGEgdmFsaWQgZW1haWwnIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlcn19LjwvcD5cXG4gIDxwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIiBuZy1zaG93PVxcXCJmb3JtaW9Gb3JtW2NvbXBvbmVudElkXS4kZXJyb3IucmVxdWlyZWRcXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8fCBjb21wb25lbnQucGxhY2Vob2xkZXIgfHwgY29tcG9uZW50LmtleSB9fSB7eydpcyByZXF1aXJlZCcgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyfX0uPC9wPlxcbiAgPHAgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiIG5nLXNob3c9XFxcImZvcm1pb0Zvcm1bY29tcG9uZW50SWRdLiRlcnJvci5udW1iZXJcXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8fCBjb21wb25lbnQucGxhY2Vob2xkZXIgfHwgY29tcG9uZW50LmtleSB9fSB7eydtdXN0IGJlIGEgbnVtYmVyJyB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXJ9fS48L3A+XFxuICA8cCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCIgbmctc2hvdz1cXFwiZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJGVycm9yLm1heGxlbmd0aFxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHx8IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8fCBjb21wb25lbnQua2V5IH19IHt7J211c3QgYmUgc2hvcnRlciB0aGFuJyB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXJ9fSB7eyBjb21wb25lbnQudmFsaWRhdGUubWF4TGVuZ3RoICsgMSB9fSB7eydjaGFyYWN0ZXJzJyB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXJ9fS48L3A+XFxuICA8cCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCIgbmctc2hvdz1cXFwiZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJGVycm9yLm1pbmxlbmd0aFxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHx8IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8fCBjb21wb25lbnQua2V5IH19IHt7J211c3QgYmUgbG9uZ2VyIHRoYW4nIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlcn19IHt7IGNvbXBvbmVudC52YWxpZGF0ZS5taW5MZW5ndGggLSAxIH19IHt7J2NoYXJhY3RlcnMnIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlcn19LjwvcD5cXG4gIDxwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIiBuZy1zaG93PVxcXCJmb3JtaW9Gb3JtW2NvbXBvbmVudElkXS4kZXJyb3IubWluXFxcIj57eyBjb21wb25lbnQubGFiZWwgfHwgY29tcG9uZW50LnBsYWNlaG9sZGVyIHx8IGNvbXBvbmVudC5rZXkgfX0ge3snbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8nIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlcn19IHt7IGNvbXBvbmVudC52YWxpZGF0ZS5taW4gfX0uPC9wPlxcbiAgPHAgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiIG5nLXNob3c9XFxcImZvcm1pb0Zvcm1bY29tcG9uZW50SWRdLiRlcnJvci5tYXhcXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8fCBjb21wb25lbnQucGxhY2Vob2xkZXIgfHwgY29tcG9uZW50LmtleSB9fSB7eydtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0bycgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyfX0ge3sgY29tcG9uZW50LnZhbGlkYXRlLm1heCB9fS48L3A+XFxuICA8cCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCIgbmctc2hvdz1cXFwiZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJGVycm9yLmN1c3RvbVxcXCI+e3sgY29tcG9uZW50LmN1c3RvbUVycm9yIHwgZm9ybWlvVHJhbnNsYXRlIH19PC9wPlxcbiAgPHAgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiIG5nLXNob3c9XFxcImZvcm1pb0Zvcm1bY29tcG9uZW50SWRdLiRlcnJvci5wYXR0ZXJuXFxcIj57eyBjb21wb25lbnQubGFiZWwgfHwgY29tcG9uZW50LnBsYWNlaG9sZGVyIHx8IGNvbXBvbmVudC5rZXkgfX0ge3snZG9lcyBub3QgbWF0Y2ggdGhlIHBhdHRlcm4nIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlcn19IHt7IGNvbXBvbmVudC52YWxpZGF0ZS5wYXR0ZXJuIH19PC9wPlxcbiAgPHAgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiIG5nLXNob3c9XFxcImZvcm1pb0Zvcm1bY29tcG9uZW50SWRdLiRlcnJvci5kYXlcXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8fCBjb21wb25lbnQucGxhY2Vob2xkZXIgfHwgY29tcG9uZW50LmtleSB9fSB7eydtdXN0IGJlIGEgdmFsaWQgZGF0ZScgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyfX0uPC9wPlxcbjwvZGl2PlxcblwiXG4gICAgKTtcbiAgfVxuXSk7XG5cbnJlcXVpcmUoJy4vY29tcG9uZW50cycpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4ndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPSAnZnVuY3Rpb24nKSB7XG4gIChmdW5jdGlvbigpIHtcbiAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAndXNlIHN0cmljdCc7XG4gICAgICAvLyBXZSBtdXN0IGNoZWNrIGFnYWluc3QgdGhlc2Ugc3BlY2lmaWMgY2FzZXMuXG4gICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGggKi9cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgfSkoKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gVGhlIGZvcm1pbyBjbGFzcy5cbiAgdmFyIEZvcm1pbyA9IHJlcXVpcmUoJ2Zvcm1pb2pzJyk7XG5cbiAgLy8gUmV0dXJuIHRoZSBwcm92aWRlciBpbnRlcmZhY2UuXG4gIHJldHVybiB7XG5cbiAgICAvLyBFeHBvc2UgRm9ybWlvIGNvbmZpZ3VyYXRpb24gZnVuY3Rpb25zXG4gICAgc2V0QmFzZVVybDogRm9ybWlvLnNldEJhc2VVcmwsXG4gICAgZ2V0QmFzZVVybDogRm9ybWlvLmdldEJhc2VVcmwsXG4gICAgc2V0QXBpVXJsOiBGb3JtaW8uc2V0QmFzZVVybCxcbiAgICBnZXRBcGlVcmw6IEZvcm1pby5nZXRCYXNlVXJsLFxuICAgIHNldEFwcFVybDogRm9ybWlvLnNldEFwcFVybCxcbiAgICBnZXRBcHBVcmw6IEZvcm1pby5nZXRBcHBVcmwsXG4gICAgcmVnaXN0ZXJQbHVnaW46IEZvcm1pby5yZWdpc3RlclBsdWdpbixcbiAgICBnZXRQbHVnaW46IEZvcm1pby5nZXRQbHVnaW4sXG4gICAgcHJvdmlkZXJzOiBGb3JtaW8ucHJvdmlkZXJzLFxuICAgIHNldERvbWFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBSZW1vdmUgdGhpcz9cbiAgICB9LFxuXG4gICAgJGdldDogW1xuICAgICAgJyRyb290U2NvcGUnLFxuICAgICAgJyRxJyxcbiAgICAgIGZ1bmN0aW9uKFxuICAgICAgICAkcm9vdFNjb3BlLFxuICAgICAgICAkcVxuICAgICAgKSB7XG4gICAgICAgIHZhciB3cmFwUVByb21pc2UgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuICRxLndoZW4ocHJvbWlzZSlcbiAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gJ1VuYXV0aG9yaXplZCcpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmb3JtaW8udW5hdXRob3JpemVkJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgPT09ICdMb2dpbiBUaW1lb3V0Jykge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Zvcm1pby5zZXNzaW9uRXhwaXJlZCcsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSBlcnJvclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgRm9ybWlvLnJlZ2lzdGVyUGx1Z2luKHtcbiAgICAgICAgICBwcmlvcml0eTogLTEwMCxcbiAgICAgICAgICAvLyBXcmFwIEZvcm1pby5yZXF1ZXN0J3MgcHJvbWlzZXMgd2l0aCAkcSBzbyAkYXBwbHkgZ2V0cyBjYWxsZWQgY29ycmVjdGx5LlxuICAgICAgICAgIHdyYXBSZXF1ZXN0UHJvbWlzZTogd3JhcFFQcm9taXNlLFxuICAgICAgICAgIHdyYXBTdGF0aWNSZXF1ZXN0UHJvbWlzZTogd3JhcFFQcm9taXNlXG4gICAgICAgIH0sICduZ0Zvcm1pb1Byb21pc2VXcmFwcGVyJyk7XG5cbiAgICAgICAgLy8gQnJvYWRjYXN0IG9mZmxpbmUgZXZlbnRzIGZyb20gJHJvb3RTY29wZVxuICAgICAgICBGb3JtaW8uZXZlbnRzLm9uQW55KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBldmVudCA9ICdmb3JtaW8uJyArIHRoaXMuZXZlbnQ7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgIGFyZ3MudW5zaGlmdChldmVudCk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QuYXBwbHkoJHJvb3RTY29wZSwgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgZm9ybWlvIGludGVyZmFjZS5cbiAgICAgICAgcmV0dXJuIEZvcm1pbztcbiAgICAgIH1cbiAgICBdXG4gIH07XG59O1xuIl19